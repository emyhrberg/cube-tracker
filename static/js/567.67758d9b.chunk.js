"use strict";(self.webpackChunkcube_tracker=self.webpackChunkcube_tracker||[]).push([[567],{567:(t,e,s)=>{s.r(e),s.d(e,{EXPERIMENTAL_PUZZLE_BASE_SHAPES:()=>rt,EXPERIMENTAL_PUZZLE_CUT_TYPES:()=>at,ExperimentalPGNotation:()=>gt,PuzzleGeometry:()=>dt,Quat:()=>_,getPG3DNamedPuzzles:()=>ot,getPuzzleDescriptionString:()=>nt,getPuzzleGeometryByDesc:()=>lt,getPuzzleGeometryByName:()=>ct,parseOptions:()=>vt,parsePuzzleDescription:()=>ht,schreierSims:()=>X});var i=s(908);var o=class{constructor(t,e){this.facenames=t,e&&(this.gripnames=e);for(let s=0;this.prefixFree&&s<t.length;s++)for(let e=0;this.prefixFree&&e<t.length;e++)s!==e&&t[s].startsWith(t[e])&&(this.prefixFree=!1)}prefixFree=!0;gripnames=[];setGripNames(t){this.gripnames=t}splitByFaceNames(t){const e=[];let s=0;for(;s<t.length;){s>0&&s<t.length&&"_"===t[s]&&s++;let i=-1;for(let e=0;e<this.facenames.length;e++)t.substr(s).startsWith(this.facenames[e])&&(i<0||this.facenames[e].length>this.facenames[i].length)&&(i=e);if(!(i>=0))throw new Error(`Could not split ${t} into face names.`);e.push(i),s+=this.facenames[i].length}return e}joinByFaceIndices(t){let e="";const s=[];for(let i=0;i<t.length;i++)s.push(e),s.push(this.facenames[t[i]]),this.prefixFree||(e="_");return s.join("")}spinmatch(t,e){if(t===e)return!0;try{const s=this.splitByFaceNames(t),i=this.splitByFaceNames(e);if(s.length!==i.length&&s.length<3)return!1;for(let t=0;t<s.length;t++){for(let i=0;i<t;i++)if(s[t]===s[i])return!1;let e=!1;for(let o=0;o<i.length;o++)if(s[t]===i[o]){e=!0;break}if(!e)return!1}return!0}catch{return!1}}spinmatchv(t,e){return t.endsWith("v")&&e.endsWith("v")?this.spinmatch(t.slice(0,t.length-1),e.slice(0,e.length-1)):this.spinmatch(t,e)}unswizzle(t){(t.endsWith("v")||t.endsWith("w"))&&t[0]<="Z"&&(t=t.slice(0,t.length-1));const e=t.toUpperCase();for(let s=0;s<this.gripnames.length;s++){const t=this.gripnames[s];if(this.spinmatch(e,t))return t}return t}},n=class{constructor(t,e){this.internalNames=t,this.externalNames=e}convertString(t,e,s){let i="";(t.endsWith("v")||t.endsWith("v"))&&t<="_"&&(i=t.slice(t.length-1),t=t.slice(0,t.length-1));const o=t.toUpperCase();let n=!1;return t!==o&&(n=!0,t=o),t=s.joinByFaceIndices(e.splitByFaceNames(t)),n&&(t=t.toLowerCase()),t+i}convert(t,e,s){const o=t.family,n=this.convertString(o,e,s);return o===n?t:new i.yU(new i.VL(n,t.innerLayer,t.outerLayer),t.amount)}notationToInternal(t){return this.convert(t,this.externalNames,this.internalNames)}notationToExternal(t){return this.convert(t,this.internalNames,this.externalNames)}},r=class{constructor(t,e){this.child=t,this.sw=e}notationToInternal(t){if("T"===t.family&&void 0===t.innerLayer&&void 0===t.outerLayer)return new i.yU(new i.VL("FLRv",t.innerLayer,t.outerLayer),t.amount);return this.child.notationToInternal(t)}notationToExternal(t){let e=t.family;return e.length>0&&"v"===e[e.length-1]&&(e=e.substring(0,e.length-1)),this.sw.spinmatch(e,"FLUR")?new i.yU(new i.VL("T",t.innerLayer,t.outerLayer),t.amount):this.child.notationToExternal(t)}},a=class{constructor(t){this.child=t}notationToInternal(t){if(void 0===t.innerLayer&&void 0===t.outerLayer){if(1===Math.abs(t.amount)){if("R++"===t.family)return new i.yU(new i.VL("L",3,2),-2*t.amount);if("R--"===t.family)return new i.yU(new i.VL("L",3,2),2*t.amount);if("D++"===t.family)return new i.yU(new i.VL("U",3,2),-2*t.amount);if("D--"===t.family)return new i.yU(new i.VL("U",3,2),2*t.amount);if("R_PLUSPLUS_"===t.family)return new i.yU(new i.VL("L",3,2),-2*t.amount);if("D_PLUSPLUS_"===t.family)return new i.yU(new i.VL("U",3,2),-2*t.amount)}if("y"===t.family)return new i.yU("Uv",t.amount);if("x"===t.family&&2===Math.abs(t.amount))return new i.yU("ERv",t.amount/2)}return this.child.notationToInternal(t)}notationToExternal(t){return"ERv"===t.family&&1===Math.abs(t.amount)?new i.yU(new i.VL("x",t.innerLayer,t.outerLayer),2*t.amount):"ILv"===t.family&&1===Math.abs(t.amount)?new i.yU(new i.VL("x",t.innerLayer,t.outerLayer),2*-t.amount):"Uv"===t.family?new i.yU(new i.VL("y",t.innerLayer,t.outerLayer),t.amount):"Dv"===t.family?new i.yU("y",-t.amount):this.child.notationToExternal(t)}},h=class{notationToInternal(t){return t}notationToExternal(t){return t}},l=class{constructor(t){this.slices=t}notationToInternal(t){const e=t.family;return t.innerLayer||t.outerLayer||("x"===e?t=new i.yU("Rv",t.amount):"y"===e?t=new i.yU("Uv",t.amount):"z"===e&&(t=new i.yU("Fv",t.amount)),1===(1&this.slices)&&("E"===e?t=new i.yU(new i.VL("D",(this.slices+1)/2),t.amount):"M"===e?t=new i.yU(new i.VL("L",(this.slices+1)/2),t.amount):"S"===e&&(t=new i.yU(new i.VL("F",(this.slices+1)/2),t.amount))),this.slices>2&&("e"===e?t=new i.yU(new i.VL("D",this.slices-1,2),t.amount):"m"===e?t=new i.yU(new i.VL("L",this.slices-1,2),t.amount):"s"===e&&(t=new i.yU(new i.VL("F",this.slices-1,2),t.amount)))),t}notationToExternal(t){const e=t.family;if(!t.innerLayer&&!t.outerLayer){if("Rv"===e)return new i.yU("x",t.amount);if("Uv"===e)return new i.yU("y",t.amount);if("Fv"===e)return new i.yU("z",t.amount);if("Lv"===e)return new i.yU("x",-t.amount);if("Dv"===e)return new i.yU("y",-t.amount);if("Bv"===e)return new i.yU("z",-t.amount)}return t}},c={U:"frl",L:"fld",R:"fdr",B:"dlr",u:"FRL",l:"FLD",r:"FDR",b:"DLR",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R"},f={U:"FRL",L:"FLD",R:"FDR",B:"DLR",u:"frl",l:"fld",r:"fdr",b:"dlr",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R",d:"d",f:"f",bl:"l",br:"r"},u={U:"FRL",L:"FLD",R:"FDR",B:"DLR"},m=new i.VL("y"),p=new i.VL("Dv"),d=class{constructor(t){this.child=t}wcaHack=!1;map=(()=>c)();notationToInternal(t){if(this.wcaHack&&2===t.innerLayer&&null===t.outerLayer){const e=u[t.family];if(e)return new i.yU(new i.VL(e,t.innerLayer,t.outerLayer),t.amount)}const e=this.map[t.family];return e?new i.yU(new i.VL(e,t.innerLayer,t.outerLayer),t.amount):m.isIdentical(t.quantum)?new i.yU(p,-t.amount):null}notationToExternal(t){if(this.wcaHack&&2===t.innerLayer&&null===t.outerLayer)for(const[e,s]of Object.entries(u))if(this.child.spinmatch(t.family,s))return new i.yU(new i.VL(e,t.innerLayer,t.outerLayer),t.amount);for(const[e,s]of Object.entries(this.map))if(this.child.spinmatch(t.family,s))return new i.yU(new i.VL(e,t.innerLayer,t.outerLayer),t.amount);return p.isIdentical(t.quantum)?new i.yU(m,-t.amount):null}},g=class extends d{wcaHack=!0;constructor(t){super(t),this.map=f}},v={U:"UBL",UL:"ULF",F:"UFR",UR:"URB",B:"DBL",D:"DFR",L:"DLF",R:"DRB",Uv:"UBLv",ULv:"ULFv",Fv:"UFRv",URv:"URBv",Bv:"DBLv",Dv:"DFRv",Lv:"DLFv",Rv:"DRBv"},b=new i.VL("x"),w=new i.VL("Rv"),y=new i.VL("Lv"),L=new i.VL("y"),F=new i.VL("Uv"),R=new i.VL("Dv"),B=new i.VL("z"),M=new i.VL("Fv"),x=new i.VL("Bv"),D=class{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer||t.outerLayer)return null;const e=v[t.family];return e?new i.yU(new i.VL(e,t.outerLayer,t.innerLayer),t.amount):b.isIdentical(t.quantum)?new i.yU(w,t.amount):L.isIdentical(t.quantum)?new i.yU(F,t.amount):B.isIdentical(t.quantum)?new i.yU(M,t.amount):null}notationToExternal(t){for(const[e,s]of Object.entries(v))if(this.child.spinmatchv(t.family,s))return new i.yU(new i.VL(e,t.innerLayer,t.outerLayer),t.amount);return w.isIdentical(t.quantum)?new i.yU(b,t.amount):y.isIdentical(t.quantum)?new i.yU(b,-t.amount):F.isIdentical(t.quantum)?new i.yU(L,t.amount):R.isIdentical(t.quantum)?new i.yU(L,-t.amount):M.isIdentical(t.quantum)?new i.yU(B,t.amount):x.isIdentical(t.quantum)?new i.yU(B,-t.amount):null}};var z=[],U=[];function P(t){if(!z[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=0;z[t]=e}return z[t]}function S(t){if(!U[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=s;U[t]=e}return U[t]}function C(t,e){return t/function(t,e){if(t>e){const s=t;t=e,e=s}for(;t>0;){const s=e%t;e=t,t=s}return e}(t,e)*e}var k=class t{n;p;constructor(t){this.n=t.length,this.p=t}toString(){return`Perm[${this.p.join(" ")}]`}mul(e){const s=Array(this.n);for(let t=0;t<this.n;t++)s[t]=e.p[this.p[t]];return new t(s)}rmul(e){const s=Array(this.n);for(let t=0;t<this.n;t++)s[t]=this.p[e.p[t]];return new t(s)}inv(){const e=Array(this.n);for(let t=0;t<this.n;t++)e[this.p[t]]=t;return new t(e)}compareTo(t){for(let e=0;e<this.n;e++)if(this.p[e]!==t.p[e])return this.p[e]-t.p[e];return 0}toGap(){const t=[],e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const i=[];for(let t=this.p[s];!e[t];t=this.p[t])i.push(1+t),e[t]=!0;t.push(`(${i.reverse().join(",")})`)}return t.join("")}toMathematica(){const t=[],e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const i=[];for(let t=this.p[s];!e[t];t=this.p[t])i.push(1+t),e[t]=!0;t.push(`{${i.reverse().join(",")}}`)}return`Cycles[{${t.join(",")}}]`}order(){let t=1;const e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;let i=0;for(let t=s;!e[t];t=this.p[t])i++,e[t]=!0;t=C(t,i)}return t}},E=class{constructor(t,e){this.size=t,this.mod=e}reassemblySize(){return function(t){let e=BigInt(1);for(;t>1;)e*=BigInt(t),t--;return e}(this.size)*BigInt(this.mod)**BigInt(this.size)}},N=0;function O(t,e){const s=i.yU.fromString(e),o=t.notationToExternal(s);return null===o||s===o?e:o.toString()}var $=class t{constructor(t,e,s,i,o,n,r){this.orbitnames=t,this.orbitdefs=e,this.solved=s,this.movenames=i,this.moveops=o,this.isRotation=n,this.forcenames=r}toKTransformationData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKTransformationOrbitData();return e}toKPatternData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKPatternOrbitData();return e}static transformToKTransformationData(t,e){const s={};for(let i=0;i<t.length;i++)s[t[i]]=e.orbits[i].toKTransformationOrbitData();return s}describeSet(t,e,s){const i=this.orbitdefs[t].size,o=new Array(i);for(let n=0;n<i;n++)o[n]=[];for(let n=0;n<this.movenames.length;n++){if(this.isRotation[n])continue;let e=this.movenames[n];this.forcenames[n]||(e=O(s,e),"'"===e[e.length-1]&&(e=e.substring(0,e.length-1)));const r=this.moveops[n].orbits[t];for(let t=0;t<i;t++)r.perm[t]===t&&0===r.ori[t]||o[t].push(e)}for(let n=0;n<i;n++)e.push(`# ${n+1} ${o[n].join(" ")}`)}toKsolve(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;const s=[];s.push(`Name ${t}`),s.push("");for(let i=0;i<this.orbitnames.length;i++)s.push(`Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`),this.describeSet(i,s,e);s.push(""),s.push("Solved");for(let i=0;i<this.orbitnames.length;i++)this.solved.orbits[i].appendDefinition(s,this.orbitnames[i],!1,!1);s.push("End");for(let i=0;i<this.movenames.length;i++){s.push("");let t=this.movenames[i];this.forcenames[i]||(t=O(e,this.movenames[i]));let o=!1;"'"===t[t.length-1]&&(o=!0,t=t.substring(0,t.length-1)),s.push(`Move ${t}`);for(let e=0;e<this.orbitnames.length;e++)o?this.moveops[i].orbits[e].inv().appendDefinition(s,this.orbitnames[e],!0):this.moveops[i].orbits[e].appendDefinition(s,this.orbitnames[e],!0);s.push("End")}return s}toKPuzzleDefinition(t){const e=[],s={};for(let o=0;o<this.orbitnames.length;o++){e.push({orbitName:this.orbitnames[o],numPieces:this.orbitdefs[o].size,numOrientations:this.orbitdefs[o].mod});const t=this.solved.orbits[o].toKTransformationOrbitData();s[this.orbitnames[o]]={pieces:t.permutation,orientation:t.orientationDelta}}const i={};if(t)for(let o=0;o<this.movenames.length;o++)i[this.movenames[o]]=this.toKTransformationData(this.moveops[o]);return{name:"PG3D #"+ ++N,orbits:e,defaultPattern:s,moves:i}}optimize(){const e=[],s=[],i=[],o=[];for(let t=0;t<this.moveops.length;t++)o.push([]);for(let t=0;t<this.orbitdefs.length;t++){const n=this.orbitdefs[t].mod,r=this.orbitdefs[t].size,a=new j(r),h=new Array(this.orbitdefs[t].size);for(let t=0;t<r;t++)h[t]=!1;for(let e=0;e<this.moveops.length;e++)for(let s=0;s<r;s++)this.moveops[e].orbits[t].perm[s]===s&&0===this.moveops[e].orbits[t].ori[s]||(this.isRotation[e]||(h[s]=!0),a.union(s,this.moveops[e].orbits[t].perm[s]));let l=!0;if(n>1){l=!1;const e=new j(this.orbitdefs[t].size*n);for(let s=0;s<this.moveops.length;s++)for(let i=0;i<r;i++)if(this.moveops[s].orbits[t].perm[i]!==i||0!==this.moveops[s].orbits[t].ori[i])for(let o=0;o<n;o++)e.union(i*n+o,this.moveops[s].orbits[t].perm[i]*n+(o+this.moveops[s].orbits[t].ori[i])%n);for(let t=0;!l&&t<r;t++)for(let s=1;s<n;s++)e.find(t*n)===e.find(t*n+s)&&(l=!0);for(let s=0;!l&&s<r;s++)for(let e=0;e<s;e++)this.solved.orbits[t].perm[s]===this.solved.orbits[t].perm[e]&&(l=!0)}let c=-1,f=!1;for(let e=0;e<this.orbitdefs[t].size;e++)if(h[e]){const t=a.find(e);c<0?c=t:c!==t&&(f=!0)}for(let u=0;u<this.orbitdefs[t].size;u++){if(!h[u])continue;if(a.find(u)!==u)continue;const n=[],r=[];let c=0;for(let e=0;e<this.orbitdefs[t].size;e++)a.find(e)===u&&(n[c]=e,r[e]=c,c++);if(f?e.push(`${this.orbitnames[t]}_p${u}`):e.push(this.orbitnames[t]),l){s.push(new E(c,this.orbitdefs[t].mod)),i.push(this.solved.orbits[t].remapVS(n,c));for(let e=0;e<this.moveops.length;e++)o[e].push(this.moveops[e].orbits[t].remap(n,r,c))}else{s.push(new E(c,1)),i.push(this.solved.orbits[t].remapVS(n,c).killOri());for(let e=0;e<this.moveops.length;e++)o[e].push(this.moveops[e].orbits[t].remap(n,r,c).killOri())}}}return new t(e,s,new V(i),this.movenames,o.map(t=>new A(t)),this.isRotation,this.forcenames)}scramble(t){this.solved=this.solved.mul(this.getScrambleTransformation(t))}getScrambleTransformation(t){t<100&&(t=100);const e=[];for(let i=0;i<this.moveops.length;i++)e[i]=this.moveops[i];for(let i=0;i<e.length;i++){const t=Math.floor(Math.random()*e.length),s=e[i];e[i]=e[t],e[t]=s}t<e.length&&(t=e.length);for(let i=0;i<t;i++){const t=Math.floor(Math.random()*e.length),s=Math.floor(Math.random()*e.length),i=Math.floor(Math.random()*this.moveops.length);e[t]=e[t].mul(e[s]).mul(this.moveops[i]),Math.random()<.1&&(e[t]=e[t].mul(this.moveops[i]))}let s=e[0];for(let i=1;i<e.length;i++)s=s.mul(e[i]);return s}reassemblySize(){let t=BigInt(1);for(let e=0;e<this.orbitdefs.length;e++)t*=this.orbitdefs[e].reassemblySize();return t}},T=class t{constructor(t,e,s){this.perm=t,this.ori=e,this.orimod=s}static ktransformationCache=[];static e(e,s){return new t(S(e),P(e),s)}mul(e){const s=this.perm.length,i=new Array(s);if(1===this.orimod){for(let t=0;t<s;t++)i[t]=this.perm[e.perm[t]];return new t(i,this.ori,this.orimod)}{const o=new Array(s);for(let t=0;t<s;t++)i[t]=this.perm[e.perm[t]],o[t]=(this.ori[e.perm[t]]+e.ori[t])%this.orimod;return new t(i,o,this.orimod)}}inv(){const e=this.perm.length,s=new Array(e),i=new Array(e);for(let t=0;t<e;t++)s[this.perm[t]]=t,i[this.perm[t]]=(this.orimod-this.ori[t])%this.orimod;return new t(s,i,this.orimod)}equal(t){const e=this.perm.length;for(let s=0;s<e;s++)if(this.perm[s]!==t.perm[s]||this.ori[s]!==t.ori[s])return!1;return!0}killOri(){const t=this.perm.length;for(let e=0;e<t;e++)this.ori[e]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(1===t)return new k(this.perm);const e=this.perm.length,s=new Array(e*t);for(let i=0;i<e;i++)for(let e=0;e<t;e++)s[i*t+e]=t*this.perm[i]+(this.ori[i]+e)%t;return new k(s)}identicalPieces(){const t=[],e=this.perm.length,s=[];for(let i=0;i<e;i++){const o=this.perm[i];if(void 0===t[o]){const n=[i];t[o]=!0;for(let t=i+1;t<e;t++)this.perm[t]===o&&n.push(t);s.push(n)}}return s}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;if(this.perm===S(t)&&this.ori===P(t))return!0;for(let e=0;e<t;e++)if(this.perm[e]!==e||0!==this.ori[e])return!1;return!0}zeroOris(){const t=this.perm.length;if(this.ori===P(t))return!0;for(let e=0;e<t;e++)if(0!==this.ori[e])return!1;return!0}remap(e,s,i){const o=new Array(i),n=new Array(i);for(let t=0;t<i;t++)o[t]=s[this.perm[e[t]]],n[t]=this.ori[e[t]];return new t(o,n,this.orimod)}remapVS(e,s){const i=new Array(s),o=new Array(s);let n=0;const r=[];for(let t=0;t<s;t++){const s=this.perm[e[t]];void 0===r[s]&&(r[s]=n++),i[t]=r[s],o[t]=this.ori[e[t]]}return new t(i,o,this.orimod)}appendDefinition(t,e,s){if((!(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])||!this.isIdentity())&&(t.push(e),t.push(this.perm.map(t=>t+1).join(" ")),!this.zeroOris()))if(s){const e=new Array(this.ori.length);for(let t=0;t<e.length;t++)e[this.perm[t]]=this.ori[t];t.push(e.join(" "))}else t.push(this.ori.join(" "))}toKTransformationOrbitData(){const e=this.perm.length;return this.isIdentity()?(t.ktransformationCache[e]||(t.ktransformationCache[e]={permutation:S(e),orientationDelta:P(e)}),t.ktransformationCache[e]):{permutation:this.perm,orientationDelta:this.ori}}toKPatternOrbitData(){const t=this.perm.length;return{pieces:this.perm,orientation:this.ori,orientationMod:P(t)}}},I=class{constructor(t){this.orbits=t}internalMul(t){const e=[];for(let s=0;s<this.orbits.length;s++)e.push(this.orbits[s].mul(t.orbits[s]));return e}internalInv(){const t=[];for(const e of this.orbits)t.push(e.inv());return t}equal(t){for(let e=0;e<this.orbits.length;e++)if(!this.orbits[e].equal(t.orbits[e]))return!1;return!0}killOri(){for(const t of this.orbits)t.killOri();return this}toPerm(){const t=[];let e=0;for(const i of this.orbits){const s=i.toPerm();t.push(s),e+=s.n}const s=new Array(e);e=0;for(const i of t){for(let t=0;t<i.n;t++)s[e+t]=e+i.p[t];e+=i.n}return new k(s)}identicalPieces(){const t=[];let e=0;for(const s of this.orbits){const i=s.orimod,o=s.identicalPieces();for(let s=0;s<o.length;s++)t.push(o[s].map(t=>t*i+e));e+=i*s.perm.length}return t}order(){let t=1;for(const e of this.orbits)t=C(t,e.order());return t}},A=class t extends I{mul(e){return new t(this.internalMul(e))}mulScalar(t){if(0===t)return this.e();let e=this;for(t<0&&(e=e.inv(),t=-t);0===(1&t);)e=e.mul(e),t>>=1;if(1===t)return e;let s=e,i=this.e();for(;t>0;)1&t&&(i=i.mul(s)),t>1&&(s=s.mul(s)),t>>=1;return i}inv(){return new t(this.internalInv())}e(){return new t(this.orbits.map(t=>T.e(t.perm.length,t.orimod)))}},V=class t extends I{mul(e){return new t(this.internalMul(e))}},j=class{constructor(t){this.n=t,this.heads=new Array(t);for(let e=0;e<t;e++)this.heads[e]=e}heads;find(t){let e=this.heads[t];return this.heads[e]===e||(e=this.find(this.heads[e]),this.heads[t]=e),e}union(t,e){const s=this.find(t),i=this.find(e);s<i?this.heads[i]=s:s>i&&(this.heads[s]=i)}};var G={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333","40x40x40":"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547","curvy copter":"c e 0.83",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667",tetraminx:"t v 0.333333333333333","master pyraminx":"t v 0 v 1 v 2","master tetraminx":"t v 0 v 1","professor pyraminx":"t v -0.2 v 0.6 v 1.4 v 2.2","professor tetraminx":"t v -0.2 v 0.6 v 1.4","royal pyraminx":"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667 v 2.33333333333333","royal tetraminx":"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667","emperor pyraminx":"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286 v 2.42857142857143","emperor tetraminx":"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286","Jing pyraminx":"t f 0","master pyramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",teraminx:"d f 0.64 f 0.76 f 0.88",petaminx:"d f 0.64 f 0.73 f 0.82 f 0.91",examinx:"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",zetaminx:"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",yottaminx:"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",pentultimate:"d f 0","master pentultimate":"d f 0.1","elite pentultimate":"d f 0 f 0.145905",starminx:"d v 0.937962370425399","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","master FTO":"o f 0.5 f 0","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","Regular Astrominx":"i v 0.18759247376021","Regular Astrominx + Big Chop":"i v 0.18759247376021 e 0",Redicosahedron:"i v 0.794654472291766","Redicosahedron with centers":"i v 0.84",Icosaminx:"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.937962370425399"},K=1e-9;function q(t){let e=new _(0,0,0,0);for(let s=0;s<t.length;s++)e=e.sum(t[s]);return e.smul(1/t.length)}function H(t,e,s,i){const o=i[t].intersect3(i[e],i[s]);if(!o)return o;for(let n=0;n<i.length;n++)if(n!==t&&n!==e&&n!==s){const t=i[n].b*o.b+i[n].c*o.c+i[n].d*o.d;if(i[n].a>0&&t>i[n].a||i[n].a<0&&t<i[n].a)return!1}return o}var _=class t{constructor(t,e,s,i){this.a=t,this.b=e,this.c=s,this.d=i}mul(e){return new t(this.a*e.a-this.b*e.b-this.c*e.c-this.d*e.d,this.a*e.b+this.b*e.a+this.c*e.d-this.d*e.c,this.a*e.c-this.b*e.d+this.c*e.a+this.d*e.b,this.a*e.d+this.b*e.c-this.c*e.b+this.d*e.a)}toString(){return`Q[${this.a},${this.b},${this.c},${this.d}]`}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(e){return new t(0,this.c*e.d-this.d*e.c,this.d*e.b-this.b*e.d,this.b*e.c-this.c*e.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const e=Math.sqrt(this.dot(this));return new t(this.a/e,this.b/e,this.c/e,this.d/e)}makenormal(){return new t(0,this.b,this.c,this.d).normalize()}normalizeplane(){const e=Math.hypot(this.b,this.c,this.d);return new t(this.a/e,this.b/e,this.c/e,this.d/e)}smul(e){return new t(this.a*e,this.b*e,this.c*e,this.d*e)}sum(e){return new t(this.a+e.a,this.b+e.b,this.c+e.c,this.d+e.d)}sub(e){return new t(this.a-e.a,this.b-e.b,this.c-e.c,this.d-e.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new t(this.a,-this.b,-this.c,-this.d)}det3x3(t,e,s,i,o,n,r,a,h){return t*(o*h-n*a)+e*(n*r-i*h)+s*(i*a-o*r)}rotateplane(e){const s=e.mul(new t(0,this.b,this.c,this.d)).mul(e.invrot());return s.a=this.a,s}orthogonal(){const e=Math.abs(this.b),s=Math.abs(this.c),i=Math.abs(this.d);return e<s&&e<i?this.cross(new t(0,1,0,0)).normalize():s<e&&s<i?this.cross(new t(0,0,1,0)).normalize():this.cross(new t(0,0,0,1)).normalize()}pointrotation(e){const s=this.normalize();if(e=e.normalize(),s.sub(e).len()<K)return new t(1,0,0,0);let i=s.sum(e);i=i.len()<K?i.orthogonal():i.normalize();const o=s.cross(i);return o.a=s.dot(i),o}unproject(t){return this.sum(t.smul(-this.dot(t)/(this.len()*t.len())))}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){return t.map(t=>t.rotatepoint(this))}intersect3(e,s){const i=this.det3x3(this.b,this.c,this.d,e.b,e.c,e.d,s.b,s.c,s.d);return!(Math.abs(i)<K)&&new t(0,this.det3x3(this.a,this.c,this.d,e.a,e.c,e.d,s.a,s.c,s.d)/i,this.det3x3(this.b,this.a,this.d,e.b,e.a,e.d,s.b,s.a,s.d)/i,this.det3x3(this.b,this.c,this.a,e.b,e.c,e.a,s.b,s.c,s.a)/i)}side(t){return t>K?1:t<-K?-1:0}cutface(t){const e=this.a;let s=0,i=null;for(let o=0;o<t.length;o++)s|=1<<this.side(t[o].dot(this)-e)+1;if(5===(5&s)){i=[];const s=t.map(t=>this.side(t.dot(this)-e));for(let o=-1;o<=1;o+=2){const n=[];for(let i=0;i<t.length;i++){s[i]!==o&&0!==s[i]||n.push(t[i]);const r=(i+1)%t.length;if(s[i]+s[r]===0&&0!==s[i]){const s=t[i].dot(this)-e,o=s/(s-(t[r].dot(this)-e)),a=t[i].smul(1-o).sum(t[r].smul(o));n.push(a)}}i.push(n)}}return i}cutfaces(t){const e=[];for(let s=0;s<t.length;s++){const i=t[s],o=this.cutface(i);o?(e.push(o[0]),e.push(o[1])):e.push(i)}return e}faceside(t){const e=this.a;for(let s=0;s<t.length;s++){const i=this.side(t[s].dot(this)-e);if(0!==i)return i}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const e=this.normalize(),s=t.normalize();return e.dist(s)<K||e.dist(s.smul(-1))<K}makecut(e){return new t(e,this.b,this.c,this.d)}},J=1e-9;function Q(t,e){const s=[],i=[];for(let o=0;o<e.length;o++){const n=t.rotateplane(e[o]);let r=!1;for(let t=0;t<s.length;t++)if(n.dist(s[t])<J){r=!0;break}r||(s.push(n),i.push(e[o]))}return i}function W(t){const e=[];for(let s=1;s<t.length;s++)for(let i=s+1;i<t.length;i++){const o=H(0,s,i,t);if(o){let t=!1;for(let s=0;s<e.length;s++)if(o.dist(e[s])<J){t=!0;break}t||e.push(o)}}for(;;){let s=!1;for(let i=0;i<e.length;i++){const o=(i+1)%e.length;if(t[0].dot(e[i].cross(e[o]))<0){const t=e[i];e[i]=e[o],e[o]=t,s=!0}}if(!s)break}return e}var Z=class{mult;constructor(){this.mult=[]}multiply(t){for(let e=2;e*e<=t;e++)for(;t%e===0;)void 0!==this.mult[e]?this.mult[e]++:this.mult[e]=1,t/=e;t>1&&(void 0!==this.mult[t]?this.mult[t]++:this.mult[t]=1)}toString(){let t="";for(let e=0;e<this.mult.length;e++)void 0!==this.mult[e]&&(""!==t&&(t+="*"),t+=e,this.mult[e]>1&&(t+=`^${this.mult[e]}`));return t}};function X(t,e){const s=t[0].p.length,i=function(t){return new k(S(t))}(s);let o=[],n=[],r=[],a=[],h=[];function l(t,e,s){a[t].push(e),h[t].push(s);for(let i=0;i<o[t].length;i++)o[t][i]&&c(t,o[t][i].mul(e),s+r[t][i])}function c(t,e,s){const i=e.p[t];if(!o[t][i]){o[t][i]=e,n[t][i]=e.inv(),r[t][i]=s;for(let i=0;i<a[t].length;i++)c(t,e.mul(a[t][i]),s+h[t][i]);return}const f=e.mul(n[t][i]);(function(t){for(let e=t.p.length-1;e>=0;e--){const s=t.p[e];if(s!==e){if(!o[e][s])return!1;t=t.mul(n[e][s])}}return!0})(f)||l(t-1,f,s+r[t][i])}return function(){o=[],n=[],a=[],r=[],h=[];for(let t=0;t<s;t++)o.push([]),n.push([]),r.push([]),a.push([]),h.push([]),o[t][t]=i,n[t][t]=i,r[t][t]=0;let c=0,f=BigInt(1);for(let i=0;i<t.length;i++){l(s-1,t[i],1),f=BigInt(1);let n=0,h=0;const u=[],m=new Z;for(let t=0;t<s;t++){let e=0,i=0;for(let n=0;n<s;n++)o[t][n]&&(e++,i+=r[t][n],t!==n&&c++);n+=a[t].length,f*=BigInt(e),e>1&&m.multiply(e);const l=i/e;u.push(l),h+=l}e(`${i}: sz ${f} T ${n} sol ${h} none ${c} mults ${m.toString()}`)}return f}()}var Y=class t{coords;length;constructor(t){this.coords=new Array(3*t.length);for(let e=0;e<t.length;e++)this.coords[3*e]=t[e].b,this.coords[3*e+1]=t[e].c,this.coords[3*e+2]=t[e].d;this.length=t.length}get(t){return new _(0,this.coords[3*t],this.coords[3*t+1],this.coords[3*t+2])}centermass(){let t=0,e=0,s=0;for(let i=0;i<this.length;i++)t+=this.coords[3*i],e+=this.coords[3*i+1],s+=this.coords[3*i+2];return new _(0,t/this.length,e/this.length,s/this.length)}rotate(e){const s=[];for(let t=0;t<this.length;t++)s.push(this.get(t).rotatepoint(e));return new t(s)}rotateforward(){const e=[];for(let t=1;t<this.length;t++)e.push(this.get(t));return e.push(this.get(0)),new t(e)}},tt=class t{constructor(t,e,s){this.face=t,this.left=e,this.right=s}split(e){const s=e.cutface(this.face);return null!==s&&(void 0===this.left?(this.left=new t(s[0]),this.right=new t(s[1])):(this.left=this.left?.split(e),this.right=this.right?.split(e))),this}collect(t,e){return void 0===this.left?t.push(new Y(this.face)):e?(this.left?.collect(t,!1),this.right?.collect(t,!0)):(this.right?.collect(t,!1),this.left?.collect(t,!0)),t}};var et=1e-9;var st={4:{v:["DFR","DLF","DRL","FLR"],e:["FR","LF","DF","DL","RD","RL"],c:["DF","FD","RL","LR"]},6:{v:["URF","UBR","ULB","UFL","DFR","DRB","DBL","DLF"],e:["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],c:["UB","LU","FU","RU","BU","DF"]},8:{v:["UBBBRR","URFL","ULBLBB","DBRBBBL","DBLLF","DFRBR"],e:["UL","UBB","UR","BRD","BLD","FD","BRR","FR","FL","BLL","BLBB","BRBB"],c:["BBU","LU","RU","BRD","FD","BLD","DF","UBB"]},12:{v:["URF","UFL","ULBL","UBLBR","UBRR","DEBF","DBFI","DIA","DAC","DCE","LAI","ALF","FCA","CFR","REC","ERBR","BRBFE","BFBRBL","BLIBF","IBLL"],e:["UF","UR","UBR","UBL","UL","ER","EBR","EBF","ED","EC","IBF","IBL","IL","IA","ID","AC","CF","FA","BFBR","BRBL","BLBF","CD","AD","AL","FL","FR","CR","BFD","BRR","BLL"],c:["UF","FU","DBF","BFD","AD","CD","BRU","BLU","LA","RA","EBR","IBL"]},20:{v:["FLPQU","FUGER","FRCAL","HCREI","ISBDH","JSIEG","BSJMK","MQPOK","ONDBK","NOPLA","UQMJG","DNACH"],e:["FU","FL","FR","EG","ER","EI","SJ","SI","SB","KM","KB","KO","PQ","PO","PL","UG","JG","MQ","UQ","HC","HD","ND","NA","JM","CA","AL","CR","HI","DB","NO"],c:["FU","UF","GE","EG","JS","SJ","MK","KM","QP","PQ","LA","AL","RC","CR","IH","HI","BD","DB","ON","NO"]}};function it(t,e){for(let s=0;s<t.length;s++)if(t[s][0].dist(e)<et)return s;throw Error("Element not found")}function ot(){return G}function nt(t){return G[t]}var rt=["c","t","o","d","i"],at=["f","v","e"];function ht(t){const e=t.split(/ /).filter(Boolean);if(e.length%2===0)return null;const s=e[0];if("o"!==s&&"c"!==s&&"i"!==s&&"d"!==s&&"t"!==s)return null;const i=[];for(let o=1;o<e.length;o+=2){if("f"!==e[o]&&"v"!==e[o]&&"e"!==e[o])return null;i.push({cutType:e[o],distance:parseFloat(e[o+1])})}return{shape:s,cuts:i}}function lt(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=ht(t);if(null===s)throw Error("Could not parse the puzzle description");const i=new dt(s,Object.assign({},{allMoves:!0},e));return i.allstickers(),i.genperms(),i}function ct(t,e){return lt(G[t],e)}function ft(t,e,s){let i=!1;s-e[1]<e[0]&&(t=[t[2],t[3],t[0],t[1]],e=[s-e[1],s-e[0]],i=!0);let o=t[0],n="";if(0===e[0]&&e[1]===s)o=`${o}v`;else if(e[0]===e[1])e[1]>0&&(n=String(e[1]+1));else{if(0!==e[0])throw Error(`We only support slice and outer block moves right now. ${e}`);o=o.toLowerCase(),e[1]>1&&(n=String(e[1]+1))}return[n+o,i]}function ut(t,e){const s=[];let i=0;for(;i<t.length;){i>0&&i<t.length&&"_"===t[i]&&i++;let o="";for(const s of e)t.substr(i).startsWith(s[1])&&s[1].length>o.length&&(o=s[1]);if(""===o)throw Error(`Could not split ${t} into face names.`);s.push(o),i+=o.length}return s}function mt(t,e){return[t.b/e,-t.c/e,t.d/e]}function pt(t,e){const s=[],i=t.length;for(let o=0;o<i;o++){const n=mt(t.get(i-o-1),e);s[3*o]=n[0],s[3*o+1]=n[1],s[3*o+2]=n[2]}return s}var dt=class{constructor(t,e){this.puzzleDescription=t;this.options=new bt(e),this.options.verbosity>0&&console.log(this.header("# "));const{shape:s,cuts:i}=t;this.movePlanes=[],this.movePlanesFiltered=[],this.faces=[],this.cubies=[];let r=null;switch(s){case"c":r=function(){const t=Math.sqrt(.5);return[new _(t,t,0,0),new _(t,0,t,0)]}();break;case"o":r=function(){const t=Math.sqrt(.5);return[new _(.5,.5,.5,.5),new _(t,0,0,t)]}();break;case"i":r=function(){let t=1/6+Math.sqrt(5)/6,e=2/3+Math.sqrt(5)/3;const s=Math.sqrt(t*t+e*e);t/=s,e/=s;const i=2*Math.PI/6;return[new _(Math.cos(i),t*Math.sin(i),e*Math.sin(i),0),new _(Math.cos(i),-t*Math.sin(i),e*Math.sin(i),0)]}();break;case"t":r=[new _(.5,.5,.5,.5),new _(.5,.5,.5,-.5)];break;case"d":r=function(){const t=2*Math.PI/10;let e=.5+.3*Math.sqrt(5),s=.5+.1*Math.sqrt(5);const i=Math.sqrt(e*e+s*s);return e/=i,s/=i,[new _(Math.cos(t),e*Math.sin(t),s*Math.sin(t),0),new _(.5,.5,.5,.5)]}();break;default:throw Error(`Bad shape argument: ${s}`)}this.rotations=function(t){const e=[new _(1,0,0,0)];for(let s=0;s<e.length;s++)for(let i=0;i<t.length;i++){const o=t[i].mul(e[s]),n=o.smul(-1);let r=!1;for(let t=0;t<e.length;t++)if(o.dist(e[t])<J||n.dist(e[t])<J){r=!0;break}r||e.push(o)}return e}(r),this.options.verbosity&&console.log(`# Rotations: ${this.rotations.length}`);const a=r[0];this.basePlaneRotations=Q(a,this.rotations);const h=this.basePlaneRotations.map(t=>a.rotateplane(t));this.basePlanes=h,this.baseFaceCount=h.length;const l={4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","BR",""],["BR","D","","BB"],["BB","BR","U","BL"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]}[h.length];this.net=l,this.colors={4:{F:"#44ee00",D:"#f4f400",L:"#ff0000",R:"#2266ff"},6:{U:"#ffffff",F:"#44ee00",R:"#ff0000",D:"#f4f400",B:"#2266ff",L:"#ff8000"},8:{U:"#ffffff",F:"#44ee00",R:"#ff0000",D:"#f4f400",BB:"#2266ff",L:"#8800dd",BL:"#ff8000",BR:"#888888"},12:{U:"#ffffff",F:"#008800",R:"#ff0000",C:"#e8d0a0",A:"#3399ff",L:"#8800dd",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#f4f400",I:"#ff8000",D:"#888888"},20:{R:"#f4f400",C:"#d41f69",F:"#008800",E:"#5c5c5c",L:"#8800dd",U:"#ffffff",A:"#007a89",G:"#ff0000",I:"#7d3b11",S:"#b9a1ff",H:"#3399ff",J:"#5ec4b6",B:"#44ee00",K:"#e8d0a0",D:"#aaaaaa",M:"#ff66cc",O:"#292929",P:"#ff8000",N:"#980000",Q:"#0000ff"}}[h.length],this.options.verbosity>0&&console.log(`# Base planes: ${h.length}`);const c=W(h),f=new _(0,0,0,0);this.options.verbosity>0&&console.log(`# Face vertices: ${c.length}`);const u=h[0].makenormal(),m=c[0].sum(c[1]).makenormal(),p=c[0].makenormal(),d=new _(1,u.b,u.c,u.d);this.options.verbosity>0&&console.log(`# Boundary is ${d}`);const g=W(Q(d,this.rotations).map(t=>d.rotateplane(t)));this.edgeDistance=g[0].sum(g[1]).smul(.5).dist(f),this.vertexDistance=g[0].dist(f);const v=[],b=[];let w=!1,y=!1,L=!1;for(const o of i){let t=null,e=0;switch(o.cutType){case"f":t=u,e=1,w=!0;break;case"v":t=p,e=this.vertexDistance,L=!0;break;case"e":t=m,e=this.edgeDistance,y=!0;break;default:throw Error(`Bad cut argument: ${o.cutType}`)}v.push(t.makecut(o.distance)),b.push(o.distance<e)}this.options.addRotations&&(w||v.push(u.makecut(10)),L||v.push(p.makecut(10)),y||v.push(m.makecut(10))),this.baseFaces=[];for(const o of this.basePlaneRotations){const t=o.rotateface(g);this.baseFaces.push(new Y(t))}const F=[],R=[],B=[],M=[],x=g.length;function D(t,e,s){for(const i of t)if(i[0].dist(e)<et)return void i.push(s);t.push([e,s])}for(let o=0;o<this.basePlaneRotations.length;o++){const t=this.basePlaneRotations[o].rotateface(g);for(let e=0;e<t.length;e++){const s=(e+1)%t.length;D(M,t[e].sum(t[s]).smul(.5),o)}}const z=[];for(let o=0;o<this.basePlaneRotations.length;o++){const t=this.basePlaneRotations[o].rotateface(g),e=[];for(let s=0;s<t.length;s++){const i=(s+1)%t.length,n=M[it(M,t[s].sum(t[i]).smul(.5))];if(o===n[1])e.push(n[2]);else{if(o!==n[2])throw Error("Could not find edge");e.push(n[1])}}z.push(e)}const U={},P=[];P.push(l[0][0]),U[l[0][0]]=0,P[z[0][0]]=l[0][1],U[l[0][1]]=z[0][0];for(const o of l){const t=U[o[0]];if(void 0===t)throw Error("Bad edge description; first edge not connected");let e=-1;for(let s=0;s<z[t].length;s++){const i=P[z[t][s]];if(void 0!==i&&i===o[1]){e=s;break}}if(e<0)throw Error("First element of a net not known");for(let s=2;s<o.length;s++){if(""===o[s])continue;const i=z[t][(s+e-1)%x],n=P[i];if(void 0!==n&&n!==o[s])throw Error("Face mismatch in net");P[i]=o[s],U[o[s]]=i}}for(let o=0;o<this.basePlaneRotations.length;o++){const t=this.basePlaneRotations[o].rotateface(g),e=d.rotateplane(this.basePlaneRotations[o]),s=P[o];F.push([t,s]),R.push([e,s])}for(let o=0;o<this.basePlaneRotations.length;o++){const t=this.basePlaneRotations[o].rotateface(g),e=P[o];for(let s=0;s<t.length;s++){const i=(s+1)%t.length,o=t[s].sum(t[i]).smul(.5),n=(s+2)%t.length,r=t[i].sum(t[n]).smul(.5),a=it(M,o),h=it(M,r);D(B,t[i],[e,h,a])}}this.swizzler=new o(F.map(t=>t[1]));const S=this.swizzler.prefixFree?"":"_",C=st[this.baseFaceCount],k=[];for(let o=0;o<this.baseFaceCount;o++)k[1<<o]=o;{const t=C.v;for(const e of t){const t=this.swizzler.splitByFaceNames(e);let s=0;for(const e of t)s|=1<<e;k[s]=t[0]}}{const t=C.e;for(const e of t){const t=this.swizzler.splitByFaceNames(e);let s=0;for(const e of t)s|=1<<e;k[s]=t[0]}}{const t=C.c;for(const e of t){const t=this.swizzler.splitByFaceNames(e);k[1<<t[0]|1<<this.baseFaceCount]=t[1]}}for(let o=0;o<M.length;o++){if(3!==M[o].length)throw Error(`Bad length in edge names ${M[o]}`);const t=M[o][1],e=M[o][2];let s=P[t];const i=P[e];s=k[1<<t|1<<e]===t?s+S+i:i+S+s,M[o]=[M[o][0],s]}for(let o=0;o<B.length;o++){let t=0;if(B[o].length<4)throw Error("Bad length in vertex names");for(let n=1;n<B[o].length;n++)t|=1<<U[B[o][n][0]];const e=k[t];let s=-1;for(let n=1;n<B[o].length;n++)e===U[B[o][n][0]]&&(s=n);if(s<0)throw Error("Internal error; couldn't find face name when fixing corners");let i="";for(let n=1;n<B[o].length;n++){i=1===n?B[o][s][0]:i+S+B[o][s][0];for(let t=1;t<B[o].length;t++)if(B[o][s][1]===B[o][t][2]){s=t;break}}B[o]=[B[o][0],i]}this.markedFaceLookup=k,this.options.verbosity>1&&(console.log(`# Face names: ${F.map(t=>t[1]).join(" ")}`),console.log(`# Edge names: ${M.map(t=>t[1]).join(" ")}`),console.log(`# Vertex names: ${B.map(t=>t[1]).join(" ")}`));const E=[];for(const o of R)E.push([o[0].makenormal(),o[1],"f"]);for(const o of M)E.push([o[0].makenormal(),o[1],"e"]);for(const o of B)E.push([o[0].makenormal(),o[1],"v"]);this.faceNames=F,this.facePlanes=R,this.edgeNames=M,this.vertexNames=B,this.geometryNormals=E;const N=E.map(t=>t[1]);this.swizzler.setGripNames(N),this.options.verbosity>0&&console.log(`# Distances: face 1 edge ${this.edgeDistance} vertex ${this.vertexDistance}`);for(let o=0;o<v.length;o++)for(const t of this.rotations){const e=v[o].rotateplane(t);let s=!1;for(const t of this.movePlanes)if(e.sameplane(t)){s=!0;break}s||(this.movePlanes.push(e),b[o]&&this.movePlanesFiltered.push(e))}let O=new tt(g);const $=this.movePlanesFiltered.slice();let T=31;for(let o=0;o<$.length;o++){const t=o+Math.floor(($.length-o)*(T/65536));O=O.split($[t]),$[t]=$[o],T=(1657*T+101)%65536}const I=O.collect([],!0);this.faces=I,this.options.verbosity>0&&console.log(`# Faces is now ${I.length}`),this.stickersPerFace=I.length;const A=[],V=q(g);for(const o of this.rotations){const t=o.rotateface(g);V.dist(q(t))<et&&A.push(o)}const j=new Array(I.length),G=[];for(let o=0;o<I.length;o++){const t=I[o].centermass();G.push([V.dist(t),t,o])}G.sort((t,e)=>t[0]-e[0]);for(let o=0;o<I.length;o++){const t=G[o][2];if(!j[t]){j[t]=!0;for(const e of A){const s=I[t].rotate(e),i=s.centermass();for(let t=o+1;t<I.length&&!(G[t][0]-G[o][0]>et);t++){const e=G[t][2];if(!j[e]&&i.dist(G[t][1])<et){j[e]=!0,I[e]=s;break}}}}}this.shortestEdge=1e99;for(const o of I)for(let t=0;t<o.length;t++){const e=(t+1)%o.length,s=o.get(t).dist(o.get(e));s<this.shortestEdge&&(this.shortestEdge=s)}this.options.verbosity>0&&console.log(`# Short edge is ${this.shortestEdge}`),"c"!==s||!w||y||L||(this.addNotationMapper="NxNxNCubeMapper",this.setReidOrSpeffzOrder=!0),"c"!==s||!L||w||y||(this.addNotationMapper="SkewbMapper"),"t"!==s||!L&&!w||y||(this.addNotationMapper="PyraminxOrTetraminxMapper"),"o"===s&&w&&(this.notationMapper=new n(this.swizzler,new o(["F","D","L","BL","R","U","BR","B"])),y||L||(this.addNotationMapper="FTOMapper")),"d"===s&&w&&(this.addNotationMapper="MegaminxMapper",this.notationMapper=new n(this.swizzler,new o(["U","F","L","BL","BR","R","FR","FL","DL","B","DR","D"])))}rotations;basePlaneRotations;basePlanes;faceNames;facePlanes;edgeNames;vertexNames;geometryNormals;movePlanes;movePlanesFiltered;movePlaneSets;movePlaneNormals;movesetorders;movesetgeos;baseFaces;faces;faceCenterMass;baseFaceCount;stickersPerFace;shortestEdge;markedFaceLookup;cubies;vertexDistance;edgeDistance;faceToCubie;faceToCubieOrd;moveRotations;faceListHash;cubieSetNames;cubieOrbitSizes;cubieSetNums;cubieOrdNums;orbitOrientations;cubieValueMap;cubieSetCubies;cmovesBySlice=[];parsedMoveList;duplicatedFaces=[];duplicatedCubies=[];fixedCubie=-1;net=[];colors=[];swizzler;notationMapper=(()=>new h)();addNotationMapper="";setReidOrSpeffzOrder=!1;options;keyface(t){return this.keyface2(t.centermass())}keyface2(t){let e="";const s=String.fromCharCode;for(const i of this.movePlaneSets)if(i.length>0){const o=t.dot(i[0]);let n=0,r=1;for(;2*r<=i.length;)r*=2;for(;r>0;r>>=1)n+r<=i.length&&o>i[n+r-1].a&&(n+=r);if(n<47)e+=s(33+n);else if(n<2256)e=e+s(80+Math.floor(n/47)-1)+s(33+n%47);else{if(!(n<106079))throw Error("Too many slices for cubie encoding");e=e+s(80+Math.floor((n-47)/2209-1))+s(80+Math.floor((n-47)/47)%47)+s(33+n%47)}}return e}keyface3(t){const e=t.centermass(),s=[];for(const i of this.movePlaneSets)if(i.length>0){const t=e.dot(i[0]);let o=0,n=1;for(;2*n<=i.length;)n*=2;for(;n>0;n>>=1)o+n<=i.length&&t>i[o+n-1].a&&(o+=n);s.push(o)}return s}findface(t){const e=this.keyface2(t),s=this.faceListHash.get(e);if(1===s.length)return s[0];for(let i=0;i+1<s.length;i++){const s=this.faceListHash.get(e)[i];if(Math.abs(t.dist(this.faceCenterMass[s]))<et)return s}return s[s.length-1]}project2d(t,e,s){const i=this.faceNames[t][0],o=(e+1)%i.length,n=this.basePlanes[t];let r=i[o].sub(i[e]);const a=r.len();r=r.normalize();const h=r.cross(n).normalize();let l=s[1].sub(s[0]);const c=l.len()/a;l=l.normalize();const f=l.b,u=l.c,m=r.smul(f).sub(h.smul(u)).smul(c),p=h.smul(f).sum(r.smul(u)).smul(c),d=new _(0,s[0].b-m.dot(i[e]),s[0].c-p.dot(i[e]),0);return[m,p,d]}upperStringToBitSet(t){let e=0;for(let s=0;s<t.length;s++)e|=1<<t.charCodeAt(s)-65;return e}allstickers(){this.faces=function(t,e){const s=[];for(const i of t)for(const t of e)s.push(t.rotate(i));return s}(this.basePlaneRotations,this.faces),this.options.verbosity>0&&console.log(`# Total stickers is now ${this.faces.length}`),this.faceCenterMass=new Array(this.faces.length);for(let r=0;r<this.faces.length;r++)this.faceCenterMass[r]=this.faces[r].centermass();const t=[],e=[];for(const r of this.movePlanes){const s=r.makenormal();let i=!1;for(const t of e)s.sameplane(t.makenormal())&&(i=!0);i||(e.push(s),t.push([]))}for(const r of this.movePlanesFiltered){const s=r.makenormal();for(let i=0;i<e.length;i++)if(s.sameplane(e[i])){t[i].push(r);break}}for(let r=0;r<t.length;r++){const s=t[r].map(t=>t.normalizeplane()),i=e[r];for(let t=0;t<s.length;t++)s[t].makenormal().dist(i)>et&&(s[t]=s[t].smul(-1));s.sort((t,e)=>t.a-e.a),t[r]=s}this.movePlaneSets=t,this.movePlaneNormals=e;const s=t.map(t=>t.length);this.options.verbosity>0&&console.log(`# Move plane sets: ${s}`);const i=[];for(let r=0;r<t.length;r++)i.push([]);for(const r of this.rotations){if(Math.abs(Math.abs(r.a)-1)<et)continue;const s=r.makenormal();for(let o=0;o<t.length;o++)if(s.sameplane(e[o])){i[o].push(r);break}}this.moveRotations=i;for(let r=0;r<i.length;r++){const t=i[r],s=t[0].makenormal();for(let e=0;e<t.length;e++)s.dist(t[e].makenormal())>et&&(t[e]=t[e].smul(-1));t.sort((t,e)=>t.angle()-e.angle()),i[r][0].dot(e[r])<0&&t.reverse()}const o=i.map(t=>1+t.length);this.movesetorders=o;const n=[];let h="?";for(let P=0;P<t.length;P++){const s=e[P];let i=null,o=null;for(const t of this.geometryNormals){const e=s.dot(t[0]);Math.abs(e-1)<et?(o=[t[1],t[2]],h=t[2]):Math.abs(e+1)<et&&(i=[t[1],t[2]],h=t[2])}if(null===o||null===i)throw Error("Saw positive or negative sides as null");n.push([o[0],o[1],i[0],i[1],1+t[P].length]),"NxNxNCubeMapper"===this.addNotationMapper&&"f"===h&&(this.notationMapper=new l(1+t[P].length),this.addNotationMapper=""),"SkewbMapper"===this.addNotationMapper&&1===t[0].length&&(this.notationMapper=new D(this.swizzler),this.addNotationMapper=""),"PyraminxOrTetraminxMapper"===this.addNotationMapper&&(2===t[0].length&&.333333333333333===t[0][0].a&&1.66666666666667===t[0][1].a?(this.notationMapper=new d(this.swizzler),this.addNotationMapper=""):(this.notationMapper=new g(this.swizzler),this.addNotationMapper="")),"MegaminxMapper"===this.addNotationMapper&&"f"===h&&(1+t[P].length===3&&(this.notationMapper=new a(this.notationMapper)),this.addNotationMapper=""),"FTOMapper"===this.addNotationMapper&&"f"===h&&(1+t[P].length===3&&(this.notationMapper=new r(this.notationMapper,this.swizzler)),this.addNotationMapper="")}this.movesetgeos=n;const c=new Map,f=this.faces;for(let r=0;r<f.length;r++){const t=f[r],e=this.keyface(t);if(c.get(e)){const t=c.get(e);if(t.push(r),t.length===this.baseFaceCount){this.options.verbosity>0&&console.log("# Splitting core.");for(let s=0;s<t.length;s++){const i=`${e} ${s}`;c.set(i,[t[s]])}}}else c.set(e,[r])}this.faceListHash=c,this.options.verbosity>0&&console.log(`# Cubies: ${c.size}`);const u=[],m=[],p=[];for(const r of c.values())if(r.length!==this.baseFaceCount){if(r.length>1){const t=r.map(t=>f[t].centermass()),e=q(t);for(let n=0;r.length>2;n++){let s=!1;for(let i=0;i<r.length;i++){const o=(i+1)%r.length;if(e.dot(t[i].cross(t[o]))<0){const e=t[i];t[i]=t[o],t[o]=e;const n=r[i];r[i]=r[o],r[o]=n,s=!0}}if(!s)break;if(n>1e3)throw Error("Bad epsilon math; too close to border")}let s=0;for(const n of r)s|=1<<Math.floor(n/this.stickersPerFace);const i=this.markedFaceLookup[s];let o=-1;for(let n=0;n<r.length;n++)Math.floor(r[n]/this.stickersPerFace)===i&&(o=n);if(o<0)throw Error("Could not find marked face in list");if(0!==o){const t=r.slice();for(let e=0;e<r.length;e++)r[e]=t[(o+e)%r.length]}}for(let t=0;t<r.length;t++){const e=r[t];m[e]=u.length,p[e]=t}u.push(r)}this.cubies=u,this.faceToCubie=m,this.faceToCubieOrd=p;const v=["?","CENTERS","EDGES","CORNERS","C4RNER","C5RNER"],b=[],w=[0,0,0,0,0,0],y=[],L=[];let F=0;const R=[],B=[],M=[],x=[],z=t=>u[t].map(t=>this.getfaceindex(t)).join(" "),U=[];for(let r=0;r<u.length;r++){const t=u[r];if(0===t.length)continue;if(L[r])continue;const e={};let s=0;M.push(0),U.push([]);const o=t.length,n=w[o]++;let a=v[o];void 0!==a&&o!==this.baseFaceCount||(a="CORE"),a+=0===n?"":n+1,b[F]=a,y[F]=o;const h=[r];let l=0;for(L[r]=!0;l<h.length;){const o=h[l++],n=z(o);if((t.length>1||void 0===e[n])&&(e[n]=s++),x[o]=e[n],R[o]=F,U[F].push(o),B[o]=M[F]++,h.length<this.rotations.length){const t=this.faceCenterMass[u[o][0]];for(const e of i){const s=this.faceToCubie[this.findface(t.rotatepoint(e[0]))];L[s]||(h.push(s),L[s]=!0)}}}F++}if(this.setReidOrSpeffzOrder&&4<=this.stickersPerFace){const t=[["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],["UFR","URB","UBL","ULF","DRF","DFL","DLB","DBR"],["U","L","F","R","B","D"]],e=["U","L","F","R","B","D"],s=["UBL","URB","UFR","ULF","UBL","ULF","DFL","DLB","ULF","UFR","DRF","DFL","UFR","URB","DBR","DRF","URB","UBL","DLB","DBR","DFL","DRF","DBR","DLB"],i={};for(const h of t)for(let t=0;t<h.length;t++)i[this.upperStringToBitSet(h[t])]=t;const o={},n={},r=[],a=[-1,0,1,0,2,-1,1,-1,3,3,-1,-1,2,-1,-1,-1];if(this.stickersPerFace>9){for(const t of this.vertexNames)o[this.upperStringToBitSet(t[1])]=t[0];for(let t=0;t<6;t++)n[e[t]]=t;for(const t of s)r.push(o[this.upperStringToBitSet(t)])}for(const h of U)for(const t of h)if(3===u[t].length||this.stickersPerFace<=9){let e=0;for(const s of u[t])e|=1<<this.faceNames[this.getfaceindex(s)][1].charCodeAt(0)-65;B[t]=i[e]}else if(u[t].length<=2){const i=[];for(let e=0;e<u[t].length;e++){const o=u[t][e],h=n[this.faceNames[this.getfaceindex(o)][1]];let l=1e20;const c=this.faces[o].centermass();let f=0;for(let t=0;t<4;t++){const e=c.dist(r[4*h+t]);e+et<l?(l=e,f=1<<t):e<l+et&&(f|=1<<t)}if(f=a[f],f>=0){const t=4*h+f;i.push([t,s[t]])}}if(i.length>0)if(1===u[t].length)B[t]=i[0][0];else if(2===i.length&&i[0][1]===i[1][1]){let s=0;const o=e[i[0][0]>>2],n=e[i[1][0]>>2],r=i[0][1];for(;s<3&&(o===r.charAt(s)||n===r.charAt(s));)s++;if(3===s)throw Error("Internal error (2) in Speffz");if(s=(s+1)%3,o===r.charAt(s))B[t]=i[0][0];else{if(n!==r.charAt(s))throw console.log(o,n,r,s,i),Error("Internal error (3) in Speffz");B[t]=i[1][0]}}}}if(this.cubieSetNums=R,this.cubieOrdNums=B,this.cubieSetNames=b,this.cubieOrbitSizes=M,this.orbitOrientations=y,this.cubieValueMap=x,this.cubieSetCubies=U,null!==this.options.fixedPieceType){for(let t=0;t<u.length;t++)if("v"===this.options.fixedPieceType&&u[t].length>2||"e"===this.options.fixedPieceType&&2===u[t].length||"f"===this.options.fixedPieceType&&1===u[t].length){this.fixedCubie=t;break}if(this.fixedCubie<0)throw Error(`Could not find a cubie of type ${this.options.fixedPieceType} to fix.`)}this.options.verbosity>0&&console.log(`# Cubie orbit sizes ${M}`)}unswizzle(t){const e=this.notationMapper.notationToInternal(t);return null===e?null:e.modified({family:this.swizzler.unswizzle(e.family)})}stringToBlockMove(t){const e=t.match(/^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$/);if(null===e)throw Error(`Bad move passed ${t}`);const s=e[4];let o,n;if(void 0!==e[2]){if(void 0===e[3])throw Error("Missing second number in range");o=parseInt(e[2],10)}void 0!==e[3]&&(n=parseInt(e[3],10));let r="1",a=1;return void 0!==e[5]&&(r=e[5],"'"===r[0]&&(r=`-${r.substring(1)}`),a=parseInt(r,10)),new i.yU(new i.VL(s,n,o),a)}parseMove(t){const e=this.notationMapper.notationToInternal(t);if(null===e)throw Error(`Bad move ${t.family}`);let s,i=(t=e).family,o=!1;if(i.endsWith("v")&&i[0]<="Z"){if(void 0!==t.innerLayer||void 0!==t.outerLayer)throw Error("Cannot use a prefix with full cube rotations");i=i.slice(0,-1),o=!0}i.endsWith("w")&&i[0]<="Z"&&(i=i.slice(0,-1).toLowerCase());let n=-1;const r=this.swizzler.unswizzle(i);let a=!1;for(let f=0;f<this.movesetgeos.length;f++){const t=this.movesetgeos[f];r===t[0]&&(a=!0,s=t,n=f),r===t[2]&&(a=!1,s=t,n=f)}let h=1,l=1;if(i.toUpperCase()!==i&&(l=2),void 0===s)throw Error(`Bad grip in move ${t.family}`);void 0!==t.outerLayer&&(h=t.outerLayer),void 0!==t.innerLayer&&(void 0===t.outerLayer?(l=t.innerLayer,h=i<="Z"?l:1):l=t.innerLayer),h--,l--;const c=this.movePlaneSets;if(o&&(h=0,l=c[n].length),h<0||h>c[n].length||l<0||l>c[n].length)throw Error(`Bad slice spec ${h} ${l} vs ${c[n].length}`);if(0===h&&l===c[n].length&&!o)throw Error("! full puzzle rotations must be specified with v suffix.");return[void 0,n,h,l,a,t.amount]}parsemove(t){const e=this.parseMove(this.stringToBlockMove(t));return e[0]=t,e}genperms(){if(this.cmovesBySlice.length>0)return;const t=[];if(this.options.orientCenters)for(let e=0;e<this.cubies.length;e++)if(1===this.cubies[e].length){const t=this.cubies[e][0],s=this.getfaceindex(t),i=this.baseFaces[s].centermass();if(i.dist(this.faceCenterMass[t])<et){const o=1<<s|1<<this.baseFaceCount,n=this.markedFaceLookup[o],r=this.basePlanes[n].makenormal();let a=-1,h=-1;for(let e=0;e<this.faces[t].length;e++){const s=this.faces[t].get(e),o=r.dot(s.sub(i));o>a&&(a=o,h=e)}const l=(h+1)%this.faces[t].length;if(Math.abs(r.dot(this.faces[t].get(l).sub(i))-a)<et&&(h=l),0!==h){const e=[];for(let s=0;s<this.faces[t].length;s++)e.push(this.faces[t].get((s+h)%this.faces[t].length));this.faces[t]=new Y(e)}const c=this.baseFaces[s].length;for(let t=1;t<c;t++)this.cubies[e].push(this.cubies[e][t-1]);this.duplicatedFaces[t]=c,this.duplicatedCubies[e]=c,this.orbitOrientations[this.cubieSetNums[e]]=c}}for(let e=0;e<this.movePlaneSets.length;e++){const s=this.movePlaneSets[e],i=[],o=[s.length+1,0];let n=1;for(;2*n<=s.length;)n*=2;for(let t=0;t<this.faces.length;t++){let e=0;if(s.length>0){const i=this.faceCenterMass[t].dot(s[0]);for(let t=n;t>0;t>>=1)e+t<=s.length&&i>s[e+t-1].a&&(e+=t);e=s.length-e}for(i.push(e);o.length<=e;)o.push(0);o[e]++}const r=new Array(o.length);for(let t=0;t<o.length;t++)r[t]=[];const a=[];for(let t=0;t<this.faces.length;t++){if(i[t]<0)continue;const s=[this.faceToCubie[t],this.faceToCubieOrd[t]];let o=this.faceCenterMass[t];const n=o;let h=t;const l=i[h];for(;;){i[h]=-1;const t=o.rotatepoint(this.moveRotations[e][0]);if(t.dist(n)<et)break;h=this.findface(t),s.push(this.faceToCubie[h],this.faceToCubieOrd[h]),o=t}if(s.length>2&&this.options.orientCenters&&(1===this.cubies[s[0]].length||this.duplicatedCubies[s[0]]>1)&&this.faceCenterMass[t].dist(this.baseFaces[this.getfaceindex(t)].centermass())<et){let t=this.faces[this.cubies[s[0]][0]];for(let i=0;i<s.length;i+=2){const o=this.faces[this.cubies[s[i]][0]];let n=-1;for(let e=0;e<t.length;e++)if(o.get(e).dist(t.get(0))<et){n=e;break}if(n<0)throw Error("Couldn't find rotation of center faces; ignoring for now.");s[i+1]=n,t=t.rotate(this.moveRotations[e][0])}}if(2===s.length&&this.options.orientCenters){const i=this.faceCenterMass[t].dot(this.movePlaneNormals[e]);for(let t=1;t<this.movesetorders[e];t++)i>0?s.push(s[0],t):s.push(s[0],(this.movesetorders[e]-t)%this.movesetorders[e])}if(s.length>2&&!a[s[0]]){if(s.length!==2*this.movesetorders[e])throw Error("Bad length in perm gen");for(const t of s)r[l].push(t)}for(let t=0;t<s.length;t+=2)a[s[t]]=!0}for(let t=0;t<r.length;t++)r[t]=r[t].slice();t.push(r)}if(this.cmovesBySlice=t,this.options.moveList){const t=[];for(const e of this.options.moveList)t.push(this.parsemove(e));this.parsedMoveList=t}this.faceListHash.clear(),this.faceCenterMass=[]}getboundarygeometry(){return{baseplanes:this.basePlanes,facenames:this.faceNames,faceplanes:this.facePlanes,vertexnames:this.vertexNames,edgenames:this.edgeNames,geonormals:this.geometryNormals}}getmovesets(t){const e=this.movePlaneSets[t].length;let s=[];if(void 0!==this.parsedMoveList)for(const i of this.parsedMoveList)i[1]===t&&(i[4]?s.push([i[2],i[3]]):s.push([e-i[3],e-i[2]]),s.push(i[5]));else{const i=this.movesetgeos[t],o=i[1]!==i[3];if(this.options.vertexMoves&&o&&!this.options.allMoves){if(i[1]!==i[3])for(let t=0;t<e;t++)"v"!==i[1]?(this.options.outerBlockMoves?s.push([t+1,e]):s.push([t+1,t+1]),s.push(1)):(this.options.outerBlockMoves?s.push([0,t]):s.push([t,t]),s.push(1))}else for(let t=0;t<=e;t++)(this.options.allMoves||t+t!==e)&&(this.options.outerBlockMoves?t+t>e?s.push([t,e]):s.push([0,t]):s.push([t,t]),s.push(1))}if(this.fixedCubie>=0){const i=this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[t],o=[];for(let t=0;t<s.length;t+=2){let n=s[t];if(i>=n[0]&&i<=n[1])if(0===n[0])n=[n[1]+1,e];else{if(e!==n[1])throw Error("fixed cubie option would disconnect move");n=[0,n[0]-1]}let r=!1;for(let e=0;e<o.length;e+=2)if(o[e][0]===n[0]&&o[e][1]===n[1]&&o[e+1]===s[t+1]){r=!0;break}r||(o.push(n),o.push(s[t+1]))}s=o}return s}graybyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&(this.options.grayCenters||!this.options.includeCenterOrbits)||2===e&&(this.options.grayEdges||!this.options.includeEdgeOrbits)||e>2&&(this.options.grayCorners||!this.options.includeCornerOrbits)}skipbyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&!this.options.includeCenterOrbits||2===e&&!this.options.includeEdgeOrbits||e>2&&!this.options.includeCornerOrbits}skipcubie(t){return this.skipbyori(t)}header(t){return`${t+"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki."}\n${t}\n`}writegap(){const t=this.getOrbitsDef(!1),e=[],s=[];for(let o=0;o<t.moveops.length;o++){let i=t.movenames[o];t.forcenames[o]||(i=`M_${O(this.notationMapper,i)}`),i=`M_${i}`;let n=!1;"'"===i[i.length-1]&&(i=i.substring(0,i.length-1),n=!0),s.push(i),n?e.push(`${i}:=${t.moveops[o].toPerm().inv().toGap()};`):e.push(`${i}:=${t.moveops[o].toPerm().toGap()};`)}e.push("Gen:=["),e.push(s.join(",")),e.push("];");const i=t.solved.identicalPieces();return e.push(`ip:=[${i.map(t=>`[${t.map(t=>t+1).join(",")}]`).join(",")}];`),e.push("# Size(Group(Gen));"),e.push("# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));"),e.push(""),this.header("# ")+e.join("\n")}writemathematica(){const t=this.getOrbitsDef(!1),e=[],s=[];e.push(`(* ${this.header("").trim()} *)`);for(let i=0;i<t.moveops.length;i++){let o=`m${O(this.notationMapper,t.movenames[i])}`,n=!1;"'"===o[o.length-1]&&(o=o.substring(0,o.length-1),n=!0),s.push(o),n?e.push(`${o}=${t.moveops[i].toPerm().inv().toMathematica()};`):e.push(`${o}=${t.moveops[i].toPerm().toMathematica()};`)}return e.push(`gen={${s.join(",")}};`),e.join("\n")}writeksolve(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"PuzzleGeometryPuzzle";const e=this.getOrbitsDef(!1);return this.header("# ")+e.toKsolve(t,this.notationMapper).join("\n")}getKPuzzleDefinition(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const s=this.getOrbitsDef(t,e).toKPuzzleDefinition(e);if(s.experimentalPuzzleDescription=this.puzzleDescription,!s)throw Error("Missing definition!");return s}getMoveFromBits(t,e,s,i,o,n){const r=[],a=[],h=[];for(const f of this.cubieOrbitSizes)a.push(S(f)),h.push(P(f));for(let f=t[0];f<=t[1];f++){const t=i[f];for(let e=0;e<t.length;e+=2*n){const i=t.slice(e,e+2*n),o=this.cubieSetNums[i[0]];for(let t=0;t<i.length;t+=2)i[t]=this.cubieOrdNums[i[t]];let r=2,l=3;s&&(r=i.length-2,l=i.length-1),a[o]===S(this.cubieOrbitSizes[o])&&(a[o]=a[o].slice(),this.orbitOrientations[o]>1&&!this.options.fixedOrientation&&(h[o]=h[o].slice()));for(let t=0;t<i.length;t+=2)a[o][i[(t+r)%i.length]]=i[t],this.orbitOrientations[o]>1&&!this.options.fixedOrientation&&(h[o][i[t]]=(i[(t+l)%i.length]-i[(t+1)%i.length]+2*this.orbitOrientations[o])%this.orbitOrientations[o])}}let l=new T(S(24),P(24),1);for(let f=0;f<this.cubieSetNames.length;f++)if(!o||o[f])if(1===this.orbitOrientations[f]||this.options.fixedOrientation)a[f]===S(l.perm.length)?(a[f]!==l.perm&&(l=new T(a[f],h[f],1)),r.push(l)):r.push(new T(a[f],h[f],1));else{const t=new Array(h[f].length);for(let e=0;e<a[f].length;e++)t[e]=h[f][a[f][e]];r.push(new T(a[f],t,this.orbitOrientations[f]))}let c=new A(r);return 1!==e&&(c=c.mulScalar(e)),c}omitSet(t){for(const e of this.options.excludeOrbits)if(e===t)return!0;return!1}diffmvsets(t,e,s,i){for(let o=0;o<t.length;o+=2){let n=!1;for(let r=0;!n&&r<e.length;r+=2)i?t[o][0]+e[r][1]===s&&t[o][1]+e[r][0]===s&&t[o+1]===e[r+1]&&(n=!0):t[o][0]===e[r][0]&&t[o][1]===e[r][1]&&t[o+1]===e[r+1]&&(n=!0);if(!n)return!0}return!1}getOrbitsDef(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const s=[];if(t)for(let p=0;p<this.cubieSetNames.length;p++)s.push(1);const i=[],o=[],n=[],r=[];for(let p=0;p<this.movePlaneSets.length;p++){const t=this.getmovesets(p);n.push(t),this.options.addRotations?r.push(1):r.push(0)}const a=[];for(let p=0;p<this.movePlaneSets.length;p++){const t=this.movePlaneSets[p].length;let e=!1;const s=n[p];for(let i=0;i<s.length;i+=2)0===s[i][0]&&s[i][1]===t&&(e=!0);a[p]=e}if(this.options.addRotations&&(this.options.moveList||null!==this.options.fixedPieceType)){for(let t=0;t<this.moveRotations.length;t++)r[t]=0;for(let t=0;t<this.movePlaneSets.length;t++)if(a[t])r[t]=3;else for(let e=0;e<this.moveRotations.length;e++){let s=this.movePlaneNormals[t];for(let i=1;2*i<=this.movesetorders[e];i++){if(s=s.rotatepoint(this.moveRotations[e][0]),r[e]&i)continue;let o=-1,a=!1;for(let t=0;t<this.movePlaneNormals.length;t++){if(s.dist(this.movePlaneNormals[t])<et){o=t;break}if(s.dist(this.movePlaneNormals[t].smul(-1))<et){o=t,a=!0;break}}if(o<0)throw Error("Could not find rotation");const h=n[o];(h.length!==n[t].length||this.movePlaneSets[t].length!==this.movePlaneSets[o].length||this.diffmvsets(h,n[t],this.movePlaneSets[o].length,a))&&(r[e]|=i)}}for(let t=0;t<this.moveRotations.length;t++)if(0===r[t])r[t]=1;else if(1===r[t])this.movesetorders[t]>3?r[t]=2:r[t]=0;else{if(3!==r[t])throw Error("Impossible addrot val");r[t]=0}}for(let p=0;p<this.movePlaneSets.length;p++)0===r[p]||a[p]||(n[p].push([0,this.movePlaneSets[p].length]),n[p].push(r[p]));for(let p=0;p<this.movePlaneSets.length;p++){const t=n[p],e=this.movesetorders[p];for(let s=0;s<t.length;s+=2)for(let e=0;e<s;e+=2)if(t[s][0]===t[e][0]&&t[s][1]===t[e][1])throw Error("Redundant moves in moveset.");const i=[];for(let s=0;s<t.length;s+=2)for(let e=t[s][0];e<=t[s][1];e++)i[e]=1;const o=this.cmovesBySlice[p];for(let n=0;n<o.length;n++){if(1!==i[n])continue;const t=o[n];for(let i=0;i<t.length;i+=2*e){if(this.skipcubie(t[i]))continue;s[this.cubieSetNums[t[i]]]=1}}}for(let p=0;p<this.cubieSetNames.length;p++)s[p]&&(this.omitSet(this.cubieSetNames[p])?s[p]=0:(i.push(this.cubieSetNames[p]),o.push(new E(this.cubieOrbitSizes[p],this.options.fixedOrientation?1:this.orbitOrientations[p]))));const h=[];for(let p=0;p<this.cubieSetNames.length;p++){if(!s[p])continue;if(this.omitSet(this.cubieSetNames[p]))continue;const e=Array(this.cubieOrbitSizes[p]).fill(-1),i=[];for(let s=0;s<this.cubieOrbitSizes[p];s++){if(t)e[s]=s;else{const t=this.cubieSetCubies[p][s];e[this.cubieOrdNums[t]]=this.cubieValueMap[t]}i.push(0)}h.push(new T(e,i,this.options.fixedOrientation?1:this.orbitOrientations[p]))}const l=[],c=[],f=[],u=[];if(e)for(let p=0;p<this.movePlaneSets.length;p++){const t=this.movePlaneSets[p].length,e=n[p],i=this.movesetgeos[p];for(let o=0;o<e.length;o+=2){const n=e[o];let r,a=!1;if(void 0!==this.parsedMoveList)for(const e of this.parsedMoveList){if(e[1]!==p)continue;let s=[];s=e[4]?[e[2],e[3]]:[t-e[3],t-e[2]],s[0]===n[0]&&s[1]===n[1]&&(r=e[0],a=!e[4])}if(r)l.push(r),c.push(!0);else{const s=ft(i,n,t);a=s[1];const r=s[0];1===e[o+1]?l.push(r):l.push(r+e[o+1]),c.push(!1)}u.push(0===n[0]&&n[1]===t);const h=this.getMoveFromBits(n,e[o+1],a,this.cmovesBySlice[p],s,this.movesetorders[p]);f.push(h)}}let m=new $(i,o,new V(h),l,f,u,c);return this.options.optimizeOrbits&&(m=m.optimize()),0!==this.options.scrambleAmount&&m.scramble(this.options.scrambleAmount),m}getScramble(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const e=this.getOrbitsDef(!1);return e.toKTransformationData(e.getScrambleTransformation(t))}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map(t=>t.toPerm())}showcanon(t){!function(t,e){const s=t.moveops.length;if(s>30)throw new Error("Canon info too big for bitmask");const i=[],o=[];for(let r=0;r<s;r++){const e=t.moveops[r];i.push(e.order());let n=0;for(let i=0;i<s;i++){if(i===r)continue;const s=t.moveops[i];e.mul(s).equal(s.mul(e))&&(n|=1<<i)}o.push(n)}let n={0:1};for(let r=0;r<100;r++){let t=0;const s={};let a=0;for(const e in n){const r=+e,h=n[r];t+=h,a++;for(let t=0;t<i.length;t++)if(0===(r>>t&1)&&0===(r&o[t]&(1<<t)-1)){const e=r&o[t]|1<<t;void 0===s[e]&&(s[e]=0),s[e]+=(i[t]-1)*h}}e(`${r}: canonseq ${t} states ${a}`),n=s}}(this.getOrbitsDef(!1),t)}getsolved(){const t=[];for(let e=0;e<this.baseFaceCount;e++)for(let s=0;s<this.stickersPerFace;s++)t.push(e);return new k(t)}getOrientationRotation(t){const[e,[s,i,o]]=t[0],n=new _(0,s,-i,o),[r,[a,h,l]]=t[1],c=new _(0,a,-h,l);let f=null,u=null;const m=this.swizzler.unswizzle(e),p=this.swizzler.unswizzle(r);for(const g of this.geometryNormals)m===g[1]&&(f=g[0]),p===g[1]&&(u=g[0]);if(!f)throw Error(`Could not find feature ${e}`);if(!u)throw Error(`Could not find feature ${r}`);const d=f.pointrotation(n);return u.rotatepoint(d).unproject(n).pointrotation(c.unproject(n)).mul(d)}getInitial3DRotation(){const t=this.baseFaceCount;let e=null;if(this.options.puzzleOrientation?e=this.options.puzzleOrientation:this.options.puzzleOrientations&&(e=this.options.puzzleOrientations[t]),e||(e={4:[["FLR",[0,1,0]],["F",[0,0,1]]],6:[["U",[0,1,0]],["F",[0,0,1]]],8:[["U",[0,1,0]],["F",[0,0,1]]],12:[["U",[0,1,0]],["F",[0,0,1]]],20:[["GUQMJ",[0,1,0]],["F",[0,0,1]]]}[t]),!e)throw Error("No default orientation?");return this.getOrientationRotation(e)}generate2dmapping(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:800,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:500,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.92;function n(t,e){let s=t[1][0]-t[0][0],i=t[1][1]-t[0][1];const o=2*Math.PI/e,n=Math.cos(o),r=Math.sin(o);for(let a=2;a<e;a++){const e=s*n+i*r;i=i*n-s*r,s=e,t.push([t[a-1][0]+s,t[a-1][1]+i])}}t-=2*s,e-=2*s,this.genperms();const r=this.getboundarygeometry().facenames[0][0].length,a=this.net;if(null===a)throw Error("No net?");const h={};let l=0,c=0,f=1,u=0;h[a[0][0]]=[[1,0],[0,0]],n(h[a[0][0]],r);for(const M of a){const t=M[0];if(!h[t])throw Error("Bad edge description; first edge not connected.");for(let e=1;e<M.length;e++){const s=M[e];""===s||h[s]||(h[s]=[h[t][e%r],h[t][(e+r-1)%r]],n(h[s],r))}}for(const M in h){const t=h[M];for(const e of t)l=Math.min(l,e[0]),f=Math.max(f,e[0]),c=Math.min(c,e[1]),u=Math.max(u,e[1])}const m=Math.min(t/(f-l),e/(u-c)),p=.5*(t-m*(f+l)),d=.5*(e-m*(u+c)),g={},v=this.getboundarygeometry(),b={},w=[[m+p,d],[p,d]];b[a[0][0]]=w,n(b[a[0][0]],r),g[this.faceNames[0][1]]=this.project2d(0,0,[new _(0,w[0][0],w[0][1],0),new _(0,w[1][0],w[1][1],0)]);const y=[];y[0]=0;for(const M of a){const t=M[0];if(!b[t])throw Error("Bad edge description; first edge not connected.");let e=-1;for(let i=0;i<v.facenames.length;i++)if(t===v.facenames[i][1]){e=i;break}if(e<0)throw Error(`Could not find first face name ${t}`);const s=v.facenames[e][0];for(let i=1;i<M.length;i++){const o=M[i];if(""===o||b[o])continue;b[o]=[b[t][i%r],b[t][(i+r-1)%r]],n(b[o],r);const a=y[e],h=s[(a+i)%r].sum(s[(a+i+r-1)%r]).smul(.5),l=it(v.edgenames,h),c=ut(v.edgenames[l][1],this.faceNames),f=c[t===c[0]?1:0];let u=-1;for(let t=0;t<v.facenames.length;t++)if(f===v.facenames[t][1]){u=t;break}if(u<0)throw Error("Could not find second face name");const m=v.facenames[u][0];for(let e=0;e<m.length;e++){if(m[e].sum(m[(e+1)%r]).smul(.5).dist(h)<=et){const s=b[t][(i+r-1)%r],o=b[t][i%r];y[u]=e,g[f]=this.project2d(u,e,[new _(0,o[0],o[1],0),new _(0,s[0],s[1],0)]);break}}}}let L=0,F=0;const R=this.getInitial3DRotation();for(let M of this.faces){i&&(M=M.rotate(R));for(let t=0;t<M.length;t++)L=Math.max(L,Math.abs(M.get(t).b)),F=Math.max(F,Math.abs(M.get(t).c))}const B=Math.min(e/F/2,(t-s)/L/4);return(n,r)=>{if(i){r=r.rotatepoint(R);const i=.5*s+.25*t,o=this.basePlanes[n].rotateplane(R).d<0?1:-1;return[s+.5*t+o*(i-r.b*B),s+.5*e+r.c*B]}{const t=g[this.faceNames[n][1]];return[s+o*r.dot(t[0])+t[2].b,s+e-o*r.dot(t[1])-t[2].c]}}}generatesvg(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:800,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:500,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=this.generate2dmapping(t,e,s,i);function n(t,e,s){return`<polygon id="${t}" class="sticker" style="fill: ${s}" points="${e.map(t=>`${t[0]} ${t[1]}`).join(" ")}"/>\n`}const r=this.getsolved(),a=[],h=[];for(let c=0;c<this.baseFaceCount;c++)a[c]=this.colors[this.faceNames[c][1]];for(let c=0;c<this.faces.length;c++){const t=this.faces[c],e=Math.floor(c/this.stickersPerFace),s=[];for(let i=0;i<t.length;i++)s.push(o(e,t.get(i)));h.push(s)}const l=[];for(let c=0;c<this.baseFaceCount;c++){l.push("<g>"),l.push(`<title>${this.faceNames[c][1]}</title>\n`);for(let t=0;t<this.stickersPerFace;t++){const e=c*this.stickersPerFace+t,s=this.faceToCubie[e],i=this.faceToCubieOrd[e],o=this.cubieSetNums[s],f=this.cubieOrdNums[s],u=this.graybyori(s)?"#808080":a[r.p[e]];let m=`${this.cubieSetNames[o]}-l${f}-o${i}`;if(l.push(n(m,h[e],u)),this.duplicatedFaces[e])for(let t=1;t<this.duplicatedFaces[e];t++)m=`${this.cubieSetNames[o]}-l${f}-o${t}`,l.push(n(m,h[e],u))}l.push("</g>")}return`<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">\n<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\n${l.join("")}</svg>`}get3d(t){const e=[],s=this.getInitial3DRotation(),o=[],n=.52*this.baseFaces[0].get(0).len();for(let i=0;i<this.baseFaces.length;i++){const t=this.baseFaces[i].rotate(s),e=this.faceNames[i][1];o.push({coords:pt(t,n),name:e})}for(let i=0;i<this.faces.length;i++){const o=Math.floor(i/this.stickersPerFace),r=this.faceToCubie[i],a=this.faceToCubieOrd[i],h=this.cubieSetNums[r],l=this.cubieOrdNums[r];let c=this.graybyori(r)?t?.darkIgnoredOrbits?"#222222":"#808080":this.colors[this.faceNames[o][1]];t?.stickerColors&&(c=t.stickerColors[i]);const f=this.faces[i].rotate(s);e.push({coords:pt(f,n),color:c,orbit:this.cubieSetNames[h],ord:l,ori:a,face:o});let u=f;if(this.duplicatedFaces[i]){const t=u.length/this.duplicatedFaces[i];for(let s=1;s<this.duplicatedFaces[i];s++){for(let e=0;e<t;e++)u=u.rotateforward();e.push({coords:pt(u,n),color:c,orbit:this.cubieSetNames[h],ord:l,ori:s,face:o,isDup:!0})}}}const r=[];for(let l=0;l<this.movesetgeos.length;l++){const t=this.movesetgeos[l],e=this.movesetorders[l];for(const o of this.geometryNormals)t[0]===o[1]&&t[1]===o[2]&&(r.push({coordinates:mt(o[0].rotatepoint(s),1),quantumMove:new i.yU(t[0]),order:e}),r.push({coordinates:mt(o[0].rotatepoint(s).smul(-1),1),quantumMove:new i.yU(t[2]),order:e}))}const a=this.generate2dmapping(2880,2160,0,!1,1),h=(()=>{const t=s.invrot();return(e,s)=>{let i=new _(0,s[0]*n,-s[1]*n,s[2]*n);i=i.rotatepoint(t);const o=a(e,i);return o[0]/=2880,o[1]=1-o[1]/2160,o}})().bind(this);return{stickers:e,faces:o,axis:r,unswizzle:this.unswizzle.bind(this),notationMapper:this.notationMapper,textureMapper:{getuv:h}}}getGeoNormal(t){const e=this.getInitial3DRotation(),s=this.swizzler.unswizzle(t);for(const i of this.geometryNormals)if(s===i[1]){const t=mt(i[0].rotatepoint(e),1);return Math.abs(t[0])<et&&Math.abs(t[2])<et&&(t[0]=0,t[2]=1e-6),t}}getfaceindex(t){const e=this.stickersPerFace;return Math.floor(t/e)}textForTwizzleExplorer(){return`Faces ${this.basePlaneRotations.length}\nStickers per face ${this.stickersPerFace}\nShort edge ${this.shortestEdge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgeDistance}\nVertex distance ${this.vertexDistance}`}writeSchreierSims(t){const e=this.getOrbitsDef(!1).reassemblySize();t(`Reassembly size is ${e}`);t(`Ratio is ${e/X(this.getMovesAsPerms(),t)}`)}},gt=class{constructor(t,e){this.pg=t,this.orbitNames=e.orbitnames}orbitNames;lookupMove(t){const e=this.pg.parseMove(t);if(this.pg.parsedMoveList){let t=!1;for(const s of this.pg.parsedMoveList)s[1]===e[1]&&s[2]===e[2]&&s[3]===e[3]&&s[4]===e[4]&&(t=!0);if(!t)return null}let s=[e[2],e[3]];if(!e[4]){const t=this.pg.movePlaneSets[e[1]].length;s=[t-e[3],t-e[2]]}const i=this.pg.getMoveFromBits(s,e[5],!e[4],this.pg.cmovesBySlice[e[1]],void 0,this.pg.movesetorders[e[1]]);return $.transformToKTransformationData(this.orbitNames,i)}remapKPuzzleDefinition(t){return function(t,e){const s={...t,moves:{}};for(const[o,n]of Object.entries(t.moves)){let t=o,r="";["v","w"].includes(o.at(-1))&&(t=o.slice(0,-1),r=o.slice(-1));const a=e.notationToExternal(i.yU.fromString(t));if(!a)continue;const h=a+r;if(!h)throw new Error(`Missing external move name for: ${o.toString()}`);s.moves[h.toString()]=n}return s}(t,this.pg.notationMapper)}};function vt(t){let e=0;const s={};for(;e<t.length&&"-"===t[e][0];){const i=t[e++];if("--rotations"===i)s.addRotations=!0;else if("--allmoves"===i)s.allMoves=!0;else if("--outerblockmoves"===i)s.outerBlockMoves=!0;else if("--vertexmoves"===i)s.vertexMoves=!0;else if("--nocorners"===i)s.includeCornerOrbits=!1;else if("--noedges"===i)s.includeEdgeOrbits=!1;else if("--noorientation"===i)s.fixedOrientation=!0;else if("--nocenters"===i)s.includeCenterOrbits=!1;else if("--omit"===i)s.excludeOrbits=t[e].split(","),e++;else if("--moves"===i)s.moveList=t[e].split(","),e++;else if("--optimize"===i)s.optimizeOrbits=!0;else if("--scramble"===i)s.scrambleAmount=100;else if("--fixcorner"===i)s.fixedPieceType="v";else if("--fixedge"===i)s.fixedPieceType="e";else if("--fixcenter"===i)s.fixedPieceType="f";else if("--orientcenters"===i)s.orientCenters=!0;else{if("--puzzleorientation"!==i)throw new Error(`Bad option: ${i}`);s.puzzleOrientation=JSON.parse(t[e]),e++}}return{puzzleDescription:ht(t.slice(e).join(" ")),options:s}}var bt=class{verbosity=0;allMoves=!1;outerBlockMoves=!1;vertexMoves=!1;addRotations=!1;moveList=null;fixedOrientation=!1;fixedPieceType=null;orientCenters=!1;includeCornerOrbits=!0;includeCenterOrbits=!0;includeEdgeOrbits=!0;excludeOrbits=[];optimizeOrbits=!1;grayCorners=!1;grayCenters=!1;grayEdges=!1;puzzleOrientation=null;puzzleOrientations=null;scrambleAmount=0;constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object.assign(this,t)}}}}]);
//# sourceMappingURL=567.67758d9b.chunk.js.map