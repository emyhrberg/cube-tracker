{"version":3,"file":"static/js/567.67758d9b.chunk.js","mappings":"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CA,QACA,SACA,QACA,QAEFP,EAAG,CACD,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,OACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,OAEFvH,EAAG,CACD,KACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,KACA,MACA,QAGJ,GAAI,CACF8H,EAAG,CACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SAEFP,EAAG,CACD,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MAEFvH,EAAG,CACD,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QAwCN,SAAS0R,GAAY/W,EAAa8F,GAEhC,IAAK,IAAInI,EAAI,EAAGA,EAAIqC,EAAEnC,OAAQF,IAC5B,GAAIqC,EAAErC,GAAG,GAAGmT,KAAKhL,GAAK+Q,GACpB,OAAOlZ,EAGX,MAAMa,MAAM,oBACd,CAEO,SAASwY,KAId,OAAOvI,CACT,CAEO,SAASwI,GACdC,GAGA,OAAOzI,EAAUyI,EACnB,CAEO,IAAMC,GAAqB,CAAC,IAAK,IAAK,IAAK,IAAK,KAG1CC,GAAmB,CAAC,IAAK,IAAK,KASpC,SAASC,GACdlZ,GAGA,MAAM6B,EAAI7B,EAAEsY,MAAM,KAAKa,OAAOC,SAC9B,GAAIvX,EAAEnC,OAAS,IAAM,EACnB,OAAO,KAET,MAAM2Z,EAAQxX,EAAE,GAChB,GACY,MAAVwX,GACU,MAAVA,GACU,MAAVA,GACU,MAAVA,GACU,MAAVA,EAEA,OAAO,KAET,MAAMC,EAA+B,GACrC,IAAK,IAAI9Z,EAAI,EAAGA,EAAIqC,EAAEnC,OAAQF,GAAK,EAAG,CACpC,GAAa,MAATqC,EA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","sources":["../node_modules/cubing/src/cubing/puzzle-geometry/FaceNameSwizzler.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/Perm.ts","../node_modules/cubing/src/cubing/puzzle-geometry/PermOriSet.ts","../node_modules/cubing/src/cubing/puzzle-geometry/PGPuzzles.ts","../node_modules/cubing/src/cubing/puzzle-geometry/Quat.ts","../node_modules/cubing/src/cubing/puzzle-geometry/PlatonicGenerator.ts","../node_modules/cubing/src/cubing/puzzle-geometry/SchreierSims.ts","../node_modules/cubing/src/cubing/puzzle-geometry/PuzzleGeometry.ts","../node_modules/cubing/src/cubing/puzzle-geometry/colors.ts","../node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NotationMapper.ts","../node_modules/cubing/src/cubing/puzzle-geometry/Options.ts"],"sourcesContent":["// Manages a set of face names.  Detects whether they are prefix-free.\n// Implements greedy splitting into face names and comparisons between\n// concatenated face names and grip names.\n\nexport class FaceNameSwizzler {\n  public prefixFree: boolean = true;\n  public gripnames: string[] = [];\n  constructor(\n    public facenames: string[],\n    gripnames_arg?: string[],\n  ) {\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n\n  public setGripNames(names: string[]): void {\n    this.gripnames = names;\n  }\n\n  // split a string into face names and return a list of\n  // indices.\n  public splitByFaceNames(s: string): number[] {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (\n          s.substr(at).startsWith(this.facenames[i]) &&\n          (currentMatch < 0 ||\n            this.facenames[i].length > this.facenames[currentMatch].length)\n        ) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(`Could not split ${s} into face names.`);\n      }\n    }\n    return r;\n  }\n\n  // cons a grip from an array of numbers.\n  public joinByFaceIndices(list: number[]): string {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  public spinmatch(userinput: string, longname: string): boolean {\n    // are these the same rotationally?\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      // All elements of userinput need to be in the longname.\n      // There should be no duplicate elements in the userinput.\n      // if both have length 1 or length 2, the sets must be equal.\n      // if both have length 3 or more, then the first set must be\n      // a subset of the second.  Order doesn't matter.\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /* same as above, but permit both to have v's on the end. */\n  public spinmatchv(userinput: string, longname: string): boolean {\n    if (userinput.endsWith(\"v\") && longname.endsWith(\"v\")) {\n      return this.spinmatch(\n        userinput.slice(0, userinput.length - 1),\n        longname.slice(0, longname.length - 1),\n      );\n    } else {\n      return this.spinmatch(userinput, longname);\n    }\n  }\n\n  public unswizzle(s: string): string {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n}\n","// face renaming mapper.  Accepts two face name remappers.  We\n// work between the two.\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FaceRenamingMapper implements NotationMapper {\n  constructor(\n    public internalNames: FaceNameSwizzler,\n    public externalNames: FaceNameSwizzler,\n  ) {}\n\n  // TODO:  consider putting a cache in front of this\n  public convertString(\n    grip: string,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): string {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n\n  public convert(move: Move, a: FaceNameSwizzler, b: FaceNameSwizzler): Move {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(\n        new QuantumMove(ngrip, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n  }\n\n  public notationToInternal(move: Move): Move {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n\n  public notationToExternal(move: Move): Move {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FTONotationMapper implements NotationMapper {\n  constructor(\n    private child: NotationMapper,\n    private sw: FaceNameSwizzler,\n  ) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (\n      move.family === \"T\" &&\n      move.innerLayer === undefined &&\n      move.outerLayer === undefined\n    ) {\n      return new Move(\n        new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(\n        new QuantumMove(\"T\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","// Sits on top of a (possibly null) notation mapper, and\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\n// adds R++/R--/D++/D-- notation mapping.\nexport class MegaminxScramblingNotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer === undefined && move.outerLayer === undefined) {\n      if (Math.abs(move.amount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.amount);\n        } else if (move.family === \"D++\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.amount);\n        }\n\n        // TODO: Figure out if `cubing/alg` should parse `R++` to a family of `R++`.\n        if (move.family === \"R_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.amount);\n      }\n      if (move.family === \"x\" && Math.abs(move.amount) === 2) {\n        return new Move(\"ERv\", move.amount / 2);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (move.family === \"ERv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        move.amount * 2,\n      );\n    }\n    if (move.family === \"ILv\" && Math.abs(move.amount) === 1) {\n      return new Move(\n        new QuantumMove(\"x\", move.innerLayer, move.outerLayer),\n        -move.amount * 2,\n      );\n    }\n    if (move.family === \"Uv\") {\n      return new Move(\n        new QuantumMove(\"y\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    if (move.family === \"Dv\") {\n      return new Move(\"y\", -move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","import type { Move } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NullMapper implements NotationMapper {\n  public notationToInternal(move: Move): Move | null {\n    return move;\n  }\n\n  public notationToExternal(move: Move): Move | null {\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NxNxNCubeMapper implements NotationMapper {\n  constructor(public slices: number) {}\n\n  public notationToInternal(move: Move): Move {\n    const grip = move.family;\n    if (!(move.innerLayer || move.outerLayer)) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.amount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.amount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(\n            new QuantumMove(\"D\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"M\") {\n          move = new Move(\n            new QuantumMove(\"L\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"S\") {\n          move = new Move(\n            new QuantumMove(\"F\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(\n            new QuantumMove(\"D\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"m\") {\n          move = new Move(\n            new QuantumMove(\"L\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"s\") {\n          move = new Move(\n            new QuantumMove(\"F\", this.slices - 1, 2),\n            move.amount,\n          );\n        }\n      }\n    }\n    return move;\n  }\n\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  public notationToExternal(move: Move): Move {\n    const grip = move.family;\n    if (!(move.innerLayer || move.outerLayer)) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.amount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.amount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.amount);\n      } else if (grip === \"Lv\") {\n        return new Move(\"x\", -move.amount);\n      } else if (grip === \"Dv\") {\n        return new Move(\"y\", -move.amount);\n      } else if (grip === \"Bv\") {\n        return new Move(\"z\", -move.amount);\n      }\n    }\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst pyraminxFamilyMap: Record<string, string> = {\n  U: \"frl\",\n  L: \"fld\",\n  R: \"fdr\",\n  B: \"dlr\",\n  u: \"FRL\",\n  l: \"FLD\",\n  r: \"FDR\",\n  b: \"DLR\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n};\nconst tetraminxFamilyMap: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n  u: \"frl\",\n  l: \"fld\",\n  r: \"fdr\",\n  b: \"dlr\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n  d: \"d\",\n  f: \"f\",\n  bl: \"l\",\n  br: \"r\",\n};\n\nconst pyraminxFamilyMapWCA: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n};\n\nconst pyraminxExternalQuantumY = new QuantumMove(\"y\");\nconst pyraminxInternalQuantumY = new QuantumMove(\"Dv\");\n\nexport class PyraminxNotationMapper implements NotationMapper {\n  protected wcaHack: boolean = false;\n  map: Record<string, string> = pyraminxFamilyMap;\n\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      const newFamilyWCA = pyraminxFamilyMapWCA[move.family];\n      if (newFamilyWCA) {\n        return new Move(\n          new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    const newFamily = this.map[move.family];\n\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxInternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {\n        if (this.child.spinmatch(move.family, internal)) {\n          return new Move(\n            new QuantumMove(external, move.innerLayer, move.outerLayer),\n            move.amount,\n          );\n        }\n      }\n    }\n    for (const [external, internal] of Object.entries(this.map)) {\n      if (this.child.spinmatch(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxExternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport class TetraminxNotationMapper extends PyraminxNotationMapper {\n  protected override wcaHack = true;\n\n  constructor(child: FaceNameSwizzler) {\n    super(child);\n    this.map = tetraminxFamilyMap;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst skewbFamilyMap: Record<string, string> = {\n  U: \"UBL\",\n  UL: \"ULF\",\n  F: \"UFR\",\n  UR: \"URB\",\n  B: \"DBL\",\n  D: \"DFR\",\n  L: \"DLF\",\n  R: \"DRB\",\n  Uv: \"UBLv\",\n  ULv: \"ULFv\",\n  Fv: \"UFRv\",\n  URv: \"URBv\",\n  Bv: \"DBLv\",\n  Dv: \"DFRv\",\n  Lv: \"DLFv\",\n  Rv: \"DRBv\",\n};\n\n// TODO: combine using a similar table.\nconst skewbExternalQuantumX = new QuantumMove(\"x\");\nconst skewbInternalQuantumX = new QuantumMove(\"Rv\");\nconst skewbInternalQuantumXPrime = new QuantumMove(\"Lv\");\nconst skewbExternalQuantumY = new QuantumMove(\"y\");\nconst skewbInternalQuantumY = new QuantumMove(\"Uv\");\nconst skewbInternalQuantumYPrime = new QuantumMove(\"Dv\");\nconst skewbExternalQuantumZ = new QuantumMove(\"z\");\nconst skewbInternalQuantumZ = new QuantumMove(\"Fv\");\nconst skewbInternalQuantumZPrime = new QuantumMove(\"Bv\");\n\nexport class SkewbNotationMapper implements NotationMapper {\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    const newFamily = skewbFamilyMap[move.family];\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.outerLayer, move.innerLayer),\n        move.amount,\n      );\n    }\n    if (skewbExternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumX, move.amount);\n    }\n    if (skewbExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumY, move.amount);\n    }\n    if (skewbExternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumZ, move.amount);\n    }\n    return null;\n    /*\n       *   (1) We are not including x/y/z in Skewb; they aren't WCA notation and\n       *   it's unclear anyone needs them for reconstructions.\n       *\n    } else if (move.family === \"x\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Rv\", move.amount);\n    } else if (move.family === \"y\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Uv\", move.amount);\n    } else if (move.family === \"z\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Fv\", move.amount);\n       */\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    for (const [external, internal] of Object.entries(skewbFamilyMap)) {\n      if (this.child.spinmatchv(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (skewbInternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, move.amount);\n    }\n    if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, -move.amount);\n    }\n    if (skewbInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, move.amount);\n    }\n    if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, -move.amount);\n    }\n    if (skewbInternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, move.amount);\n    }\n    if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, -move.amount);\n    }\n    return null;\n    /*\n       *   See (1) above.\n       *\n    if (move.family === \"Rv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"x\", move.amount);\n    } else if (move.family === \"Uv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"y\", move.amount);\n    } else if (move.family === \"Fv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"z\", move.amount);\n       */\n    // } else {\n    //   return null;\n    // }\n  }\n}\n","const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): bigint {\n  let r = BigInt(1);\n  while (a > 1) {\n    r *= BigInt(a);\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return `Perm[${this.p.join(\" \")}]`;\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc: string[] = [];\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc: number[] = [];\n      for (let j = this.p[i]; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(`(${incyc.reverse().join(\",\")})`);\n    }\n    return cyc.join(\"\");\n  }\n\n  public toMathematica(): string {\n    const cyc: string[] = [];\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc: number[] = [];\n      for (let j = this.p[i]; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(`{${incyc.reverse().join(\",\")}}`);\n    }\n    return `Cycles[{${cyc.join(\",\")}}]`;\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","import { Move } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\"; // TODO\nimport type {\n  KPatternData,\n  KPatternOrbitData,\n  KPuzzleOrbitDefinition,\n  KTransformationOrbitData,\n} from \"../kpuzzle/KPuzzleDefinition\";\nimport { NullMapper } from \"./notation-mapping\";\nimport type { NotationMapper } from \"./notation-mapping/NotationMapper\";\n/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ import {\n  factorial,\n  iota,\n  lcm,\n  Perm,\n  zeros,\n} from \"./Perm\";\nexport class PGOrbitDef {\n  constructor(\n    public size: number,\n    public mod: number,\n  ) {}\n  public reassemblySize(): bigint {\n    return factorial(this.size) * BigInt(this.mod) ** BigInt(this.size);\n  }\n}\n\nlet lastGlobalDefinitionCounter = 0;\n\nexport function externalName(\n  mapper: NotationMapper,\n  moveString: string,\n): string {\n  const mv = Move.fromString(moveString);\n  const mv2 = mapper.notationToExternal(mv);\n  if (mv2 === null || mv === mv2) {\n    return moveString;\n  }\n  return mv2.toString();\n}\n\nexport class PGOrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    private orbitdefs: PGOrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: PGTransform[],\n    public isRotation: boolean[],\n    public forcenames: boolean[],\n  ) {}\n\n  public toKTransformationData(t: PGTransform): KTransformationData {\n    const ktransformationData: KTransformationData = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      ktransformationData[this.orbitnames[i]] =\n        t.orbits[i].toKTransformationOrbitData();\n    }\n    return ktransformationData;\n  }\n\n  public toKPatternData(t: PGTransform): KPatternData {\n    const kpatternData: KPatternData = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      kpatternData[this.orbitnames[i]] = t.orbits[i].toKPatternOrbitData();\n    }\n    return kpatternData;\n  }\n\n  // TODO: remove this\n  public static transformToKTransformationData(\n    orbitnames: string[],\n    t: PGTransform,\n  ): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKTransformationOrbitData();\n    }\n    return mp;\n  }\n\n  private describeSet(s: number, r: string[], mapper: NotationMapper): void {\n    const n = this.orbitdefs[s].size;\n    const m = new Array(n);\n    for (let i = 0; i < n; i++) {\n      m[i] = [];\n    }\n    for (let i = 0; i < this.movenames.length; i++) {\n      if (this.isRotation[i]) {\n        continue;\n      }\n      let mvname = this.movenames[i];\n      if (!this.forcenames[i]) {\n        mvname = externalName(mapper, mvname);\n        if (mvname[mvname.length - 1] === \"'\") {\n          mvname = mvname.substring(0, mvname.length - 1);\n        }\n      }\n      const pd = this.moveops[i].orbits[s];\n      for (let j = 0; j < n; j++) {\n        if (pd.perm[j] !== j || pd.ori[j] !== 0) {\n          m[j].push(mvname);\n        }\n      }\n    }\n    for (let j = 0; j < n; j++) {\n      r.push(`# ${j + 1} ${m[j].join(\" \")}`);\n    }\n  }\n\n  public toKsolve(\n    name: string,\n    mapper: NotationMapper = new NullMapper(),\n  ): string[] {\n    const result = [];\n    result.push(`Name ${name}`);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        `Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`,\n      );\n      this.describeSet(i, result, mapper);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      this.solved.orbits[i].appendDefinition(\n        result,\n        this.orbitnames[i],\n        false,\n        false,\n      );\n    }\n    result.push(\"End\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"\");\n      let name = this.movenames[i];\n      if (!this.forcenames[i]) {\n        name = externalName(mapper, this.movenames[i]);\n      }\n      let doinv = false;\n      if (name[name.length - 1] === \"'\") {\n        doinv = true;\n        name = name.substring(0, name.length - 1);\n      }\n      result.push(`Move ${name}`);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (doinv) {\n          this.moveops[i].orbits[j]\n            .inv()\n            .appendDefinition(result, this.orbitnames[j], true);\n        } else {\n          this.moveops[i].orbits[j].appendDefinition(\n            result,\n            this.orbitnames[j],\n            true,\n          );\n        }\n      }\n      result.push(\"End\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n\n  // TODO: return type.\n  public toKPuzzleDefinition(includemoves: boolean): KPuzzleDefinition {\n    const orbits: KPuzzleOrbitDefinition[] = [];\n    const defaultPatternData: KPatternData = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits.push({\n        orbitName: this.orbitnames[i],\n        numPieces: this.orbitdefs[i].size,\n        numOrientations: this.orbitdefs[i].mod,\n      });\n      const defaultPatternFrom =\n        this.solved.orbits[i].toKTransformationOrbitData();\n      defaultPatternData[this.orbitnames[i]] = {\n        pieces: defaultPatternFrom.permutation,\n        orientation: defaultPatternFrom.orientationDelta,\n      };\n    }\n    const moves: { [moveName: string]: any } = {};\n    if (includemoves) {\n      for (let i = 0; i < this.movenames.length; i++) {\n        moves[this.movenames[i]] = this.toKTransformationData(this.moveops[i]);\n      }\n    }\n    return {\n      name: `PG3D #${++lastGlobalDefinitionCounter}`,\n      orbits,\n      defaultPattern: defaultPatternData,\n      moves,\n    };\n  }\n\n  public optimize(): PGOrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: PGOrbitDef[] = [];\n    const newsolved: PGOrbit[] = [];\n    const newmoveops: PGOrbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      // don't consider rotations when optimizing, for what to keep\n      // but *do* consider rotations for unions.\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (\n            this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0\n          ) {\n            if (!this.isRotation[j]) {\n              changed[k] = true;\n            }\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om +\n                    ((o + this.moveops[j].orbits[i].ori[k]) % om),\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (\n              this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]\n            ) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(`${this.orbitnames[i]}_p${j}`);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new PGOrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri(),\n            );\n          }\n        }\n      }\n    }\n    return new PGOrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new PGTransform(_)),\n      this.isRotation,\n      this.forcenames,\n    );\n  }\n\n  // replace the solved state with a new scrambled state.\n  public scramble(n: number): void {\n    this.solved = this.solved.mul(this.getScrambleTransformation(n));\n  }\n\n  // generate a new \"random\" position based on an entropy pool\n  // this should be significantly faster and more random than just\n  // doing a large number of random moves, especially on big puzzles.\n  public getScrambleTransformation(n: number): PGTransform {\n    // don't let n be too tiny\n    if (n < 100) {\n      n = 100;\n    }\n    const pool: PGTransform[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    return s;\n  }\n\n  public reassemblySize(): bigint {\n    let n = BigInt(1);\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\n\nexport class PGOrbit {\n  private static ktransformationCache: KTransformationOrbitData[] = [];\n\n  public static e(n: number, mod: number): PGOrbit {\n    return new PGOrbit(iota(n), zeros(n), mod);\n  }\n\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number,\n  ) {}\n\n  public mul(b: PGOrbit): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new PGOrbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array<number>(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new PGOrbit(newPerm, newOri, this.orimod);\n    }\n  }\n\n  public inv(): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public equal(b: PGOrbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + ((this.ori[i] + j) % o);\n      }\n    }\n    return new Perm(newPerm);\n  }\n\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n\n  public order(): number {\n    // can be made more efficient\n    return this.toPerm().order();\n  }\n\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private zeroOris(): boolean {\n    const n = this.perm.length;\n    if (this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public remap(no: number[], on: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public remapVS(no: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public appendDefinition(\n    result: string[],\n    name: string,\n    useVS: boolean,\n    concise: boolean = true,\n  ): void {\n    if (concise && this.isIdentity()) {\n      return;\n    }\n    result.push(name);\n    result.push(this.perm.map((_: number) => _ + 1).join(\" \"));\n    if (!this.zeroOris()) {\n      if (useVS) {\n        const newori = new Array<number>(this.ori.length);\n        for (let i = 0; i < newori.length; i++) {\n          newori[this.perm[i]] = this.ori[i];\n        }\n        result.push(newori.join(\" \"));\n      } else {\n        result.push(this.ori.join(\" \"));\n      }\n    }\n  }\n\n  public toKTransformationOrbitData(): KTransformationOrbitData {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!PGOrbit.ktransformationCache[n]) {\n        PGOrbit.ktransformationCache[n] = {\n          permutation: iota(n),\n          orientationDelta: zeros(n),\n        };\n      }\n      return PGOrbit.ktransformationCache[n];\n    } else {\n      return { permutation: this.perm, orientationDelta: this.ori };\n    }\n  }\n\n  public toKPatternOrbitData(): KPatternOrbitData {\n    const n = this.perm.length;\n    return {\n      pieces: this.perm,\n      orientation: this.ori,\n      orientationMod: zeros(n),\n    };\n  }\n}\n\nexport class PGTransformBase {\n  constructor(public orbits: PGOrbit[]) {}\n  public internalMul(b: PGTransformBase): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n\n  protected internalInv(): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (const orbit of this.orbits) {\n      newOrbits.push(orbit.inv());\n    }\n    return newOrbits;\n  }\n\n  public equal(b: PGTransformBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  protected killOri(): this {\n    for (const orbit of this.orbits) {\n      orbit.killOri();\n    }\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const perms: Perm[] = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const p = orbit.toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (const p of perms) {\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const o = orbit.orimod;\n      const s = orbit.identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * orbit.perm.length;\n    }\n    return r;\n  }\n\n  public order(): number {\n    let r = 1;\n    for (const orbit of this.orbits) {\n      r = lcm(r, orbit.order());\n    }\n    return r;\n  }\n}\nexport class PGTransform extends PGTransformBase {\n  public mul(b: PGTransform): PGTransform {\n    return new PGTransform(this.internalMul(b));\n  }\n\n  public mulScalar(n: number): PGTransform {\n    if (n === 0) {\n      return this.e();\n    }\n    let t: PGTransform = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n\n  public inv(): PGTransform {\n    return new PGTransform(this.internalInv());\n  }\n\n  public e(): PGTransform {\n    return new PGTransform(\n      this.orbits.map((_: PGOrbit) => PGOrbit.e(_.perm.length, _.orimod)),\n    );\n  }\n}\nexport class VisibleState extends PGTransformBase {\n  public mul(b: PGTransform): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  private heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (\n          ((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0\n        ) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(`${d}: canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"0: canonseq 1\");\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || (commutes[mv] & (1 << st) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(`${d}\": canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n","export type PuzzleDescriptionString = string;\n\nexport const PGPuzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\":\n    \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\":\n    \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\":\n    \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\":\n    \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\":\n    \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\":\n    \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  skewb: \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  helicopter: \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  dino: \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  pyramorphix: \"t e 0\",\n  mastermorphix: \"t e 0.346184634065199\",\n  pyraminx: \"t v 0.333333333333333 v 1.66666666666667\",\n  tetraminx: \"t v 0.333333333333333\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"master tetraminx\": \"t v 0 v 1\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"professor tetraminx\": \"t v -0.2 v 0.6 v 1.4\",\n  \"royal pyraminx\":\n    \"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667 v 2.33333333333333\",\n  \"royal tetraminx\":\n    \"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667\",\n  \"emperor pyraminx\":\n    \"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286 v 2.42857142857143\",\n  \"emperor tetraminx\":\n    \"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  megaminx: \"d f 0.7\",\n  gigaminx: \"d f 0.64 f 0.82\",\n  teraminx: \"d f 0.64 f 0.76 f 0.88\",\n  petaminx: \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  examinx: \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  zetaminx: \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  yottaminx: \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  pentultimate: \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  \"elite pentultimate\": \"d f 0 f 0.145905\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  starminx: \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  chopasaurus: \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  FTO: \"o f 0.333333333333333\",\n  \"master FTO\": \"o f 0.5 f 0\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  octastar: \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  icosamate: \"i v 0\",\n  \"Regular Astrominx\": \"i v 0.18759247376021\",\n  \"Regular Astrominx + Big Chop\": \"i v 0.18759247376021 e 0\",\n  Redicosahedron: \"i v 0.794654472291766\",\n  \"Redicosahedron with centers\": \"i v 0.84\",\n  Icosaminx: \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\",\n};\n\nexport const legacyPuzzleNameMapping: Partial<Record<string, string>> = {\n  \"icosahedron 2\": \"Regular Astrominx\",\n  \"icosahedron 3\": \"Regular Astrominx + Big Chop\",\n  \"icosahedron static faces\": \"Redicosahedron with centers\",\n  \"icosahedron moving faces\": \"Icosaminx\",\n};\n\nexport type PuzzleName = keyof typeof PGPuzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return `Q[${this.a},${this.b},${this.c},${this.d}]`;\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Cuts a face by this plane, or returns null if there\n   * is no intersection.\n   * @param face The face to cut.\n   */\n  public cutface(face: Quat[]): Quat[][] | null {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << (this.side(face[i].dot(this) - d) + 1);\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      // saw both sides\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = (2 * Math.PI) / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5),\n  ];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = (2 * Math.PI) / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  ];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps || negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face: Quat[] = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (;;) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","import { identity, type Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += `^${this.mult[i]}`;\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): bigint {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): bigint {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = BigInt(1);\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = BigInt(1);\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= BigInt(cnt);\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\n        `${i}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`,\n      );\n    }\n    return sz;\n  }\n  return getsgs();\n}\n","import { Move, QuantumMove } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\";\nimport { defaultPlatonicColorSchemes } from \"./colors\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport {\n  FaceRenamingMapper,\n  FTONotationMapper,\n  MegaminxScramblingNotationMapper,\n  type NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n  PyraminxNotationMapper,\n  SkewbNotationMapper,\n  TetraminxNotationMapper,\n} from \"./notation-mapping\";\nimport { remapKPuzzleDefinition } from \"./notation-mapping/NotationMapper\";\nimport {\n  type BaseFaceCount,\n  type FaceBasedOrientationDescription,\n  type FaceBasedOrientationDescriptionLookup,\n  PuzzleGeometryFullOptions,\n  type PuzzleGeometryOptions,\n} from \"./Options\";\nimport { iota, Perm, zeros } from \"./Perm\";\nimport {\n  externalName,\n  PGOrbit,\n  PGOrbitDef,\n  PGOrbitsDef,\n  PGTransform,\n  showcanon,\n  VisibleState,\n} from \"./PermOriSet\";\nimport {\n  PGPuzzles,\n  type PuzzleDescriptionString,\n  type PuzzleName,\n} from \"./PGPuzzles\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { centermassface, Quat } from \"./Quat\";\nimport { schreierSims } from \"./SchreierSims\";\n\nexport interface TextureMapper {\n  getuv(fn: number, threed: number[]): number[];\n}\n\nexport interface StickerDatSticker {\n  coords: number[];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n  face: number;\n  isDup?: boolean;\n}\n\nexport interface StickerDatFace {\n  coords: number[];\n  name: string;\n}\n\nexport type StickerDatAxis = {\n  coordinates: number[];\n  quantumMove: Move;\n  order: number;\n};\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: Move): Move | null;\n  notationMapper: NotationMapper;\n  textureMapper: TextureMapper;\n}\n\n// you can fill these in to help with timing if you want\nfunction tstart(s: string): string {\n  return s;\n}\n\nfunction tend(_: string): void {}\n\nclass Face {\n  private coords: number[];\n  public length: number;\n  constructor(q: Quat[]) {\n    this.coords = new Array(q.length * 3);\n    for (let i = 0; i < q.length; i++) {\n      this.coords[3 * i] = q[i].b;\n      this.coords[3 * i + 1] = q[i].c;\n      this.coords[3 * i + 2] = q[i].d;\n    }\n    this.length = q.length;\n  }\n\n  get(off: number): Quat {\n    return new Quat(\n      0,\n      this.coords[3 * off],\n      this.coords[3 * off + 1],\n      this.coords[3 * off + 2],\n    );\n  }\n\n  centermass(): Quat {\n    let sx = 0;\n    let sy = 0;\n    let sz = 0;\n    for (let i = 0; i < this.length; i++) {\n      sx += this.coords[3 * i];\n      sy += this.coords[3 * i + 1];\n      sz += this.coords[3 * i + 2];\n    }\n    return new Quat(0, sx / this.length, sy / this.length, sz / this.length);\n  }\n\n  rotate(q: Quat): Face {\n    const a = [];\n    for (let i = 0; i < this.length; i++) {\n      a.push(this.get(i).rotatepoint(q));\n    }\n    return new Face(a);\n  }\n\n  rotateforward(): Face {\n    const a = [];\n    for (let i = 1; i < this.length; i++) {\n      a.push(this.get(i));\n    }\n    a.push(this.get(0));\n    return new Face(a);\n  }\n}\n\nexport class FaceTree {\n  constructor(\n    private face: Quat[],\n    private left?: FaceTree,\n    private right?: FaceTree,\n  ) {}\n\n  public split(q: Quat): FaceTree {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === undefined) {\n        this.left = new FaceTree(t[0]);\n        this.right = new FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n\n  public collect(arr: Face[], leftfirst: boolean): Face[] {\n    if (this.left === undefined) {\n      arr.push(new Face(this.face));\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n}\n\nexport function expandfaces(rots: Quat[], faces: Face[]): Face[] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (const rot of rots) {\n    for (const face of faces) {\n      nfaces.push(face.rotate(rot));\n    }\n  }\n  return nfaces;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\n// Orientation conventions are specified here.  For each of the five platonic\n// solids, by face count, we have three lists of \"cubie names\" consisting of\n// a concatenation of face names.  For vertex (corner) and edge cubies, the\n// first face in the concatenated name is the one that will be marked.\n// For center orientations, the first face specifies which center we are\n// referring to, and the second face specifies the direction of the mark for\n// that face.\n\nconst orientationDefaults = {\n  4: {\n    v: [\"DFR\", \"DLF\", \"DRL\", \"FLR\"],\n    e: [\"FR\", \"LF\", \"DF\", \"DL\", \"RD\", \"RL\"],\n    c: [\"DF\", \"FD\", \"RL\", \"LR\"],\n  },\n  6: {\n    v: [\"URF\", \"UBR\", \"ULB\", \"UFL\", \"DFR\", \"DRB\", \"DBL\", \"DLF\"],\n    e: [\"UF\", \"UR\", \"UB\", \"UL\", \"DF\", \"DR\", \"DB\", \"DL\", \"FR\", \"FL\", \"BR\", \"BL\"],\n    c: [\"UB\", \"LU\", \"FU\", \"RU\", \"BU\", \"DF\"],\n  },\n  8: {\n    v: [\"UBBBRR\", \"URFL\", \"ULBLBB\", \"DBRBBBL\", \"DBLLF\", \"DFRBR\"],\n    e: [\n      \"UL\",\n      \"UBB\",\n      \"UR\",\n      \"BRD\",\n      \"BLD\",\n      \"FD\",\n      \"BRR\",\n      \"FR\",\n      \"FL\",\n      \"BLL\",\n      \"BLBB\",\n      \"BRBB\",\n    ],\n    c: [\"BBU\", \"LU\", \"RU\", \"BRD\", \"FD\", \"BLD\", \"DF\", \"UBB\"],\n  },\n  12: {\n    v: [\n      \"URF\",\n      \"UFL\",\n      \"ULBL\",\n      \"UBLBR\",\n      \"UBRR\",\n      \"DEBF\",\n      \"DBFI\",\n      \"DIA\",\n      \"DAC\",\n      \"DCE\",\n      \"LAI\",\n      \"ALF\",\n      \"FCA\",\n      \"CFR\",\n      \"REC\",\n      \"ERBR\",\n      \"BRBFE\",\n      \"BFBRBL\",\n      \"BLIBF\",\n      \"IBLL\",\n    ],\n    e: [\n      \"UF\",\n      \"UR\",\n      \"UBR\",\n      \"UBL\",\n      \"UL\",\n      \"ER\",\n      \"EBR\",\n      \"EBF\",\n      \"ED\",\n      \"EC\",\n      \"IBF\",\n      \"IBL\",\n      \"IL\",\n      \"IA\",\n      \"ID\",\n      \"AC\",\n      \"CF\",\n      \"FA\",\n      \"BFBR\",\n      \"BRBL\",\n      \"BLBF\",\n      \"CD\",\n      \"AD\",\n      \"AL\",\n      \"FL\",\n      \"FR\",\n      \"CR\",\n      \"BFD\",\n      \"BRR\",\n      \"BLL\",\n    ],\n    c: [\n      \"UF\",\n      \"FU\",\n      \"DBF\",\n      \"BFD\",\n      \"AD\",\n      \"CD\",\n      \"BRU\",\n      \"BLU\",\n      \"LA\",\n      \"RA\",\n      \"EBR\",\n      \"IBL\",\n    ],\n  },\n  20: {\n    v: [\n      \"FLPQU\",\n      \"FUGER\",\n      \"FRCAL\",\n      \"HCREI\",\n      \"ISBDH\",\n      \"JSIEG\",\n      \"BSJMK\",\n      \"MQPOK\",\n      \"ONDBK\",\n      \"NOPLA\",\n      \"UQMJG\",\n      \"DNACH\",\n    ],\n    e: [\n      \"FU\",\n      \"FL\",\n      \"FR\",\n      \"EG\",\n      \"ER\",\n      \"EI\",\n      \"SJ\",\n      \"SI\",\n      \"SB\",\n      \"KM\",\n      \"KB\",\n      \"KO\",\n      \"PQ\",\n      \"PO\",\n      \"PL\",\n      \"UG\",\n      \"JG\",\n      \"MQ\",\n      \"UQ\",\n      \"HC\",\n      \"HD\",\n      \"ND\",\n      \"NA\",\n      \"JM\",\n      \"CA\",\n      \"AL\",\n      \"CR\",\n      \"HI\",\n      \"DB\",\n      \"NO\",\n    ],\n    c: [\n      \"FU\",\n      \"UF\",\n      \"GE\",\n      \"EG\",\n      \"JS\",\n      \"SJ\",\n      \"MK\",\n      \"KM\",\n      \"QP\",\n      \"PQ\",\n      \"LA\",\n      \"AL\",\n      \"RC\",\n      \"CR\",\n      \"IH\",\n      \"HI\",\n      \"BD\",\n      \"DB\",\n      \"ON\",\n      \"NO\",\n    ],\n  },\n};\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): FaceBasedOrientationDescriptionLookup {\n  return {\n    4: [\n      [\"FLR\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLR towards viewer\n    6: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // URF towards viewer\n    8: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLUR towards viewer\n    12: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n    20: [\n      [\"GUQMJ\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n  };\n}\n\nfunction findelement(a: Quat[][], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw Error(\"Element not found\");\n}\n\nexport function getPG3DNamedPuzzles(): {\n  [s: string]: PuzzleDescriptionString;\n} {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles;\n}\n\nexport function getPuzzleDescriptionString(\n  puzzleName: PuzzleName,\n): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles[puzzleName];\n}\n\nexport const PUZZLE_BASE_SHAPES = [\"c\", \"t\", \"o\", \"d\", \"i\"] as const;\nexport type PuzzleBaseShape = (typeof PUZZLE_BASE_SHAPES)[number];\n\nexport const PUZZLE_CUT_TYPES = [\"f\", \"v\", \"e\"] as const;\nexport type PuzzleCutType = (typeof PUZZLE_CUT_TYPES)[number];\n\nexport type PuzzleCutDescription = { cutType: PuzzleCutType; distance: number };\nexport type PuzzleDescription = {\n  shape: PuzzleBaseShape;\n  cuts: PuzzleCutDescription[];\n};\n\nexport function parsePuzzleDescription(\n  s: PuzzleDescriptionString,\n): PuzzleDescription | null {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return null;\n  }\n  const shape = a[0];\n  if (\n    shape !== \"o\" &&\n    shape !== \"c\" &&\n    shape !== \"i\" &&\n    shape !== \"d\" &&\n    shape !== \"t\"\n  ) {\n    return null;\n  }\n  const cuts: PuzzleCutDescription[] = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return null;\n    }\n    cuts.push({\n      cutType: a[i] as PuzzleCutType,\n      distance: parseFloat(a[i + 1]),\n    });\n  }\n  return { shape, cuts };\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: PuzzleGeometryOptions = {},\n): PuzzleGeometry {\n  const parsed = parsePuzzleDescription(desc);\n  if (parsed === null) {\n    throw Error(\"Could not parse the puzzle description\");\n  }\n  const pg = new PuzzleGeometry(\n    parsed,\n    Object.assign({}, { allMoves: true } as PuzzleGeometryOptions, options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options?: PuzzleGeometryOptions,\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\n\nfunction getmovename(\n  geo: any,\n  bits: number[],\n  slices: number,\n): [string, boolean] {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0] as string;\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = `${movenameFamily}v`;\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw Error(\n      `We only support slice and outer block moves right now. ${bits}`,\n    );\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: [Quat[], string][]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (const facename of facenames) {\n      if (\n        s.substr(at).startsWith(facename[1]) &&\n        facename[1].length > currentMatch.length\n      ) {\n        currentMatch = facename[1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw Error(`Could not split ${s} into face names.`);\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Face, maxdist: number): number[] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    const pt = toCoords(q.get(n - i - 1), maxdist);\n    r[3 * i] = pt[0];\n    r[3 * i + 1] = pt[1];\n    r[3 * i + 2] = pt[2];\n  }\n  return r;\n}\n\ntype MoveSetGeo = [string, string, string, string, number];\n\n/** @category PuzzleGeometry */\nexport class PuzzleGeometry {\n  private rotations: Quat[]; // all members of the rotation group\n  public basePlaneRotations: Quat[]; // unique rotations of the baseplane\n  private basePlanes: Quat[]; // planes, corresponding to faces\n  private faceNames: [Quat[], string][]; // face names\n  private facePlanes: [Quat, string][]; // face planes\n  private edgeNames: [Quat, string][]; // edge names\n  private vertexNames: [Quat, string][]; // vertexnames\n  private geometryNormals: [Quat, string, string][]; // all geometric directions, with names and types\n  private movePlanes: Quat[]; // the planes that split moves\n  private movePlanesFiltered: Quat[]; // the planes that split moves, filtered\n  public movePlaneSets?: Quat[][]; // the move planes, in parallel sets\n  private movePlaneNormals?: Quat[]; // one move plane\n  public movesetorders?: number[]; // the order of rotations for each move set\n  public movesetgeos?: MoveSetGeo[]; // geometric feature information for move sets\n  private baseFaces: Face[]; // polytope faces before cuts\n  private faces: Face[]; // all the stickers\n  private faceCenterMass?: Quat[]; // center of mass of all faces\n  private baseFaceCount: BaseFaceCount; // number of base faces\n  public stickersPerFace: number; // number of stickers per face\n  public shortestEdge: number;\n  private markedFaceLookup: number[]; // given a bitmap of faces, identify the marked one\n  public cubies: number[][]; // the cubies\n  private vertexDistance: number; // vertex distance\n  private edgeDistance: number; // edge distance\n  private faceToCubie?: number[]; // map a face to a cubie index\n  private faceToCubieOrd?: number[]; // map a face to a cubie ord\n  private moveRotations?: Quat[][]; // move rotations\n  private faceListHash?: Map<string, number[]>; // face list by key\n  private cubieSetNames?: string[]; // cubie set names\n  private cubieOrbitSizes?: number[]; // the size of each orbit\n  private cubieSetNums?: number[];\n  private cubieOrdNums?: number[];\n  private orbitOrientations?: number[]; // the orientation size of each orbit\n  private cubieValueMap?: number[]; // the map for identical cubies\n  private cubieSetCubies?: number[][]; // cubies in each cubie set\n  public cmovesBySlice: number[][][] = []; // cmoves as perms by slice\n  public parsedMoveList?: [\n    string | undefined,\n    number,\n    number,\n    number,\n    boolean,\n    number,\n  ][]; // parsed move list\n\n  private duplicatedFaces: number[] = []; // which faces are duplicated\n  private duplicatedCubies: number[] = []; // which cubies are duplicated\n  private fixedCubie: number = -1; // fixed cubie, if any\n  private net: string[][] = [];\n  private colors: any = [];\n  private swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  private addNotationMapper: string = \"\";\n  private setReidOrSpeffzOrder: boolean = false;\n\n  private options: PuzzleGeometryFullOptions;\n\n  constructor(\n    public puzzleDescription: PuzzleDescription,\n    options: PuzzleGeometryOptions,\n  ) {\n    const t1 = tstart(\"genperms\");\n    this.options = new PuzzleGeometryFullOptions(options);\n    if (this.options.verbosity > 0) {\n      console.log(this.header(\"# \"));\n    }\n\n    const { shape, cuts } = puzzleDescription;\n\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    this.movePlanes = [];\n    this.movePlanesFiltered = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\": {\n        g = cube();\n        break;\n      }\n      case \"o\": {\n        g = octahedron();\n        break;\n      }\n      case \"i\": {\n        g = icosahedron();\n        break;\n      }\n      case \"t\": {\n        g = tetrahedron();\n        break;\n      }\n      case \"d\": {\n        g = dodecahedron();\n        break;\n      }\n      default:\n        throw Error(`Bad shape argument: ${shape}`);\n    }\n    this.rotations = closure(g);\n    if (this.options.verbosity) {\n      console.log(`# Rotations: ${this.rotations.length}`);\n    }\n    const baseplane = g[0];\n    this.basePlaneRotations = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.basePlaneRotations.map((_) =>\n      baseplane.rotateplane(_),\n    );\n    this.basePlanes = baseplanes;\n    this.baseFaceCount = baseplanes.length as BaseFaceCount;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultPlatonicColorSchemes()[baseplanes.length];\n    if (this.options.verbosity > 0) {\n      console.log(`# Base planes: ${baseplanes.length}`);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.options.verbosity > 0) {\n      console.log(`# Face vertices: ${baseface.length}`);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.options.verbosity > 0) {\n      console.log(`# Boundary is ${boundary}`);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    const firstface = getface(planes);\n    this.edgeDistance = firstface[0].sum(firstface[1]).smul(0.5).dist(zero);\n    this.vertexDistance = firstface[0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (const cut of cuts) {\n      let normal = null;\n      let distance = 0;\n      switch (cut.cutType) {\n        case \"f\": {\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        }\n        case \"v\": {\n          normal = vertexnormal;\n          distance = this.vertexDistance;\n          sawvertex = true;\n          break;\n        }\n        case \"e\": {\n          normal = edgenormal;\n          distance = this.edgeDistance;\n          sawedge = true;\n          break;\n        }\n        default:\n          throw Error(`Bad cut argument: ${cut.cutType}`);\n      }\n      cutplanes.push(normal.makecut(cut.distance));\n      intersects.push(cut.distance < distance);\n    }\n    if (this.options.addRotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.baseFaces = [];\n    for (const baseplanerot of this.basePlaneRotations) {\n      const face = baseplanerot.rotateface(firstface);\n      this.baseFaces.push(new Face(face));\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n! where\n    //   n planes meet at a vertex.  We set names by choosing the marked face\n    //   first, and going counterclockwise around.\n    //\n    const facenames: [Quat[], string][] = [];\n    const faceplanes: [Quat, string][] = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = firstface.length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (const el of a) {\n        if (el[0].dist(p) < eps) {\n          el.push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.basePlaneRotations.length; i++) {\n      const face = this.basePlaneRotations[i].rotateface(firstface);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.basePlaneRotations.length; i++) {\n      const face = this.basePlaneRotations[i].rotateface(firstface);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: string[] = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (const neti of net) {\n      const f0 = neti[0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === neti[1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < neti.length; j++) {\n        if (neti[j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== neti[j]) {\n          throw Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = neti[j];\n        facenametoindex[neti[j]] = of;\n      }\n    }\n    for (let i = 0; i < this.basePlaneRotations.length; i++) {\n      const face = this.basePlaneRotations[i].rotateface(firstface);\n      const faceplane = boundary.rotateplane(this.basePlaneRotations[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.basePlaneRotations.length; i++) {\n      const face = this.basePlaneRotations[i].rotateface(firstface);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    const oridata = orientationDefaults[this.baseFaceCount];\n    const markedface = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      markedface[1 << i] = i;\n    }\n    // FIXME  eliminate the duplications below\n    {\n      const oriprefs = oridata[\"v\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"e\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        let bits = 0;\n        for (const i of fn) {\n          bits |= 1 << i;\n        }\n        markedface[bits] = fn[0];\n      }\n    }\n    {\n      const oriprefs = oridata[\"c\"];\n      for (const name of oriprefs) {\n        const fn = this.swizzler.splitByFaceNames(name);\n        const bits = (1 << fn[0]) | (1 << this.baseFaceCount);\n        markedface[bits] = fn[1];\n      }\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw Error(`Bad length in edge names ${edgenames[i]}`);\n      }\n      const f1 = edgenames[i][1];\n      const f2 = edgenames[i][2];\n      let c1 = faceindextoname[f1];\n      const c2 = faceindextoname[f2];\n      const bits = (1 << f1) | (1 << f2);\n      if (markedface[bits] === f1) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; counterclockwise rotations; proper orientation.\n    for (let i = 0; i < vertexnames.length; i++) {\n      let bits = 0;\n      if (vertexnames[i].length < 4) {\n        throw Error(\"Bad length in vertex names\");\n      }\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        bits |= 1 << facenametoindex[vertexnames[i][j][0]];\n      }\n      const fi = markedface[bits];\n      let st = -1;\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (fi === facenametoindex[vertexnames[i][j][0]]) {\n          st = j;\n        }\n      }\n      if (st < 0) {\n        throw Error(\n          \"Internal error; couldn't find face name when fixing corners\",\n        );\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    this.markedFaceLookup = markedface;\n    if (this.options.verbosity > 1) {\n      console.log(`# Face names: ${facenames.map((_) => _[1]).join(\" \")}`);\n      // TODO\n      console.log(`# Edge names: ${edgenames.map((_) => _[1]).join(\" \")}`);\n      // TODO\n      console.log(`# Vertex names: ${vertexnames.map((_) => _[1]).join(\" \")}`);\n    }\n    const geonormals: [Quat, string, string][] = [];\n    for (const faceplane of faceplanes) {\n      geonormals.push([faceplane[0].makenormal(), faceplane[1], \"f\"]);\n    }\n    for (const edgename of edgenames) {\n      geonormals.push([edgename[0].makenormal(), edgename[1], \"e\"]);\n    }\n    for (const vertexname of vertexnames) {\n      geonormals.push([vertexname[0].makenormal(), vertexname[1], \"v\"]);\n    }\n    this.faceNames = facenames;\n    this.facePlanes = faceplanes;\n    this.edgeNames = edgenames;\n    this.vertexNames = vertexnames;\n    this.geometryNormals = geonormals;\n    const geonormalnames = geonormals.map((_) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.options.verbosity > 0) {\n      console.log(\n        `# Distances: face ${1} edge ${this.edgeDistance} vertex ${\n          this.vertexDistance\n        }`,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (const rotation of this.rotations) {\n        const q = cutplanes[c].rotateplane(rotation);\n        let wasseen = false;\n        for (const moveplane of this.movePlanes) {\n          if (q.sameplane(moveplane)) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.movePlanes.push(q);\n          if (intersects[c]) {\n            this.movePlanesFiltered.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(firstface);\n    const tar = this.movePlanesFiltered.slice();\n    // we want to use Math.random() here but we can't, because when\n    // we call multiple times we'll get different orbits/layouts.\n    // to resolve this, we use a very simple linear congruential\n    // generator.  for our purposes, the numbers don't need to be\n    // very random.\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536.0));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    const faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.options.verbosity > 0) {\n      console.log(`# Faces is now ${faces.length}`);\n    }\n    this.stickersPerFace = faces.length;\n    // the faces when rotated don't preserve the vertex order at this\n    // point.  to improve 3d rendering speed, we would like to preserve\n    // vertex order on rotation.  First, let's see what rotations preserve\n    // the base face; these are the ones we want to work with.\n    const simplerot: Quat[] = [];\n    const cm = centermassface(firstface);\n    for (const rotation of this.rotations) {\n      const f = rotation.rotateface(firstface);\n      if (cm.dist(centermassface(f)) < eps) {\n        simplerot.push(rotation);\n      }\n    }\n    const finished = new Array<boolean>(faces.length);\n    const sortme: [number, Quat, number][] = [];\n    for (let i = 0; i < faces.length; i++) {\n      const cm2 = faces[i].centermass();\n      sortme.push([cm.dist(cm2), cm2, i]);\n    }\n    sortme.sort((a, b) => a[0] - b[0]);\n    for (let ii = 0; ii < faces.length; ii++) {\n      const i = sortme[ii][2];\n      if (!finished[i]) {\n        finished[i] = true;\n        for (const rot of simplerot) {\n          const f2 = faces[i].rotate(rot);\n          const cm = f2.centermass();\n          for (let kk = ii + 1; kk < faces.length; kk++) {\n            if (sortme[kk][0] - sortme[ii][0] > eps) {\n              break;\n            }\n            const k = sortme[kk][2];\n            if (!finished[k] && cm.dist(sortme[kk][1]) < eps) {\n              finished[k] = true;\n              faces[k] = f2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    this.shortestEdge = 1e99;\n    for (const face of faces) {\n      for (let j = 0; j < face.length; j++) {\n        const k = (j + 1) % face.length;\n        const t = face.get(j).dist(face.get(k));\n        if (t < this.shortestEdge) {\n          this.shortestEdge = t;\n        }\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(`# Short edge is ${this.shortestEdge}`);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      // try to set Reid order of the cubies within an orbit\n      this.setReidOrSpeffzOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxOrTetraminxMapper\";\n    }\n    if (shape === \"o\" && sawface) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n      if (!(sawedge || sawvertex)) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n    tend(t1);\n  }\n\n  private keyface(face: Face): string {\n    return this.keyface2(face.centermass());\n  }\n\n  private keyface2(cm: Quat): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    const sfcc = String.fromCharCode;\n    for (const moveplaneset of this.movePlaneSets! /* TODO */) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        if (t < 47) {\n          s = s + sfcc(33 + t);\n        } else if (t < 47 + 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor(t / 47) - 1) + sfcc(33 + (t % 47));\n        } else if (t < 47 + 47 * 47 + 47 * 47 * 47) {\n          s =\n            s +\n            sfcc(33 + 47 + Math.floor((t - 47) / (47 * 47) - 1)) +\n            sfcc(33 + 47 + (Math.floor((t - 47) / 47) % 47)) +\n            sfcc(33 + (t % 47));\n        } else {\n          throw Error(\"Too many slices for cubie encoding\");\n        }\n      }\n    }\n    return s;\n  }\n\n  // same as above, but instead of returning an encoded string, return\n  // an array with offsets.\n  private keyface3(face: Face): number[] {\n    const cm = face.centermass();\n    // take a face and figure out the sides of each move plane\n    const r = [];\n    for (const moveplaneset of this.movePlaneSets! /* TODO*/) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        r.push(t);\n      }\n    }\n    return r;\n  }\n\n  private findface(cm: Quat): number {\n    const key = this.keyface2(cm);\n    const arr = this.faceListHash!.get(key)!; // TODO: refactor to avoid non-null-assertion\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.faceListHash!.get(key)![i]; // TODO: refactor to avoid non-null-assertion\n      // TODO: refactor to avoid non-null-assertion\n      if (Math.abs(cm.dist(this.faceCenterMass![face2])) < eps) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n\n  private project2d(\n    facen: number,\n    edgen: number,\n    targvec: Quat[],\n  ): [Quat, Quat, Quat] {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.faceNames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.basePlanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  // Given an string of uppercase letters, make a bitmask\n  // indicating what letters are in it.  Cheap swizzling\n  // for internal use.\n  private upperStringToBitSet(geo: string): number {\n    let r = 0;\n    for (let i = 0; i < geo.length; i++) {\n      r |= 1 << (geo.charCodeAt(i) - 65);\n    }\n    return r;\n  }\n\n  public allstickers(): void {\n    const t1 = tstart(\"allstickers\");\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.basePlaneRotations, this.faces);\n    if (this.options.verbosity > 0) {\n      console.log(`# Total stickers is now ${this.faces.length}`);\n    }\n    this.faceCenterMass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.faceCenterMass[i] = this.faces[i].centermass();\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (const q of this.movePlanes) {\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (const moveplanenormal of moveplanenormals) {\n        if (qnormal.sameplane(moveplanenormal.makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (const q of this.movePlanesFiltered) {\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.movePlaneSets = moveplanesets;\n    this.movePlaneNormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.options.verbosity > 0) {\n      console.log(`# Move plane sets: ${sizes}`);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (const q of this.rotations) {\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moveRotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos: MoveSetGeo[] = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (const geonormal of this.geometryNormals) {\n        const d = p0.dot(geonormal[0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (\n        this.addNotationMapper === \"SkewbMapper\" &&\n        moveplanesets[0].length === 1\n      ) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"PyraminxOrTetraminxMapper\") {\n        if (\n          moveplanesets[0].length === 2 &&\n          moveplanesets[0][0].a === 0.333333333333333 &&\n          moveplanesets[0][1].a === 1.66666666666667\n        ) {\n          this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        } else {\n          this.notationMapper = new TetraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        }\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(\n            this.notationMapper,\n            this.swizzler,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const facelisthash = new Map();\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!facelisthash.get(s)) {\n        facelisthash.set(s, [i]);\n      } else {\n        const arr = facelisthash.get(s)!;\n        arr.push(i);\n        //  If we find a core cubie, split it up into multiple cubies,\n        //  because ksolve doesn't handle orientations that are not\n        //  cyclic, and the rotation group of the core is not cyclic.\n        if (arr.length === this.baseFaceCount) {\n          if (this.options.verbosity > 0) {\n            console.log(\"# Splitting core.\");\n          }\n          for (let suff = 0; suff < arr.length; suff++) {\n            const s2 = `${s} ${suff}`;\n            facelisthash.set(s2, [arr[suff]]);\n          }\n        }\n      }\n    }\n    this.faceListHash = facelisthash;\n    if (this.options.verbosity > 0) {\n      console.log(`# Cubies: ${facelisthash.size}`);\n    }\n    const cubies: number[][] = [];\n    const facetocubie = [];\n    const facetoord = [];\n    for (const facelist of facelisthash.values()) {\n      if (facelist.length === this.baseFaceCount) {\n        // this is the original \"cubie\" of a split core; we ignore it.\n        continue;\n      }\n      //  Sort the faces around each corner so they are counterclockwise.  Only\n      //  relevant for cubies that actually are corners (three or more\n      //  faces).  In general cubies might have many faces; for icosohedrons\n      //  there are five faces on the corner cubies.\n      if (facelist.length > 1) {\n        const cm = facelist.map((_: number) => faces[_].centermass());\n        const cmall = centermassface(cm);\n        for (let looplimit = 0; facelist.length > 2; looplimit++) {\n          let changed = false;\n          for (let i = 0; i < facelist.length; i++) {\n            const j = (i + 1) % facelist.length;\n            // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n            if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n              const u = cm[i];\n              cm[i] = cm[j];\n              cm[j] = u;\n              const v = facelist[i];\n              facelist[i] = facelist[j];\n              facelist[j] = v;\n              changed = true;\n            }\n          }\n          if (!changed) {\n            break;\n          }\n          if (looplimit > 1000) {\n            throw Error(\"Bad epsilon math; too close to border\");\n          }\n        }\n        // set the orientations by finding the marked face and putting it first.\n        let bits = 0;\n        for (const f of facelist) {\n          bits |= 1 << Math.floor(f / this.stickersPerFace);\n        }\n        const markedface = this.markedFaceLookup[bits]!;\n        let mini = -1;\n        for (let i = 0; i < facelist.length; i++) {\n          if (Math.floor(facelist[i] / this.stickersPerFace) === markedface) {\n            mini = i;\n          }\n        }\n        if (mini < 0) {\n          throw Error(\"Could not find marked face in list\");\n        }\n        if (mini !== 0) {\n          const ofacelist = facelist.slice();\n          for (let i = 0; i < facelist.length; i++) {\n            facelist[i] = ofacelist[(mini + i) % facelist.length];\n          }\n        }\n      }\n      for (let j = 0; j < facelist.length; j++) {\n        const k = facelist[j];\n        facetocubie[k] = cubies.length;\n        facetoord[k] = j;\n      }\n      cubies.push(facelist);\n    }\n    this.cubies = cubies;\n    this.faceToCubie = facetocubie;\n    this.faceToCubieOrd = facetoord;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum].map((_) => this.getfaceindex(_)).join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      if (seen[i]) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.baseFaceCount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        if (queue.length < this.rotations.length) {\n          const cm: Quat = this.faceCenterMass![cubies[cind][0]]; // TODO: refactor to avoid non-null-assertion\n          for (const moverotation of moverotations) {\n            const tq =\n              this.faceToCubie[this.findface(cm.rotatepoint(moverotation[0]))];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (this.setReidOrSpeffzOrder && 4 <= this.stickersPerFace) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\",\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"],\n      ];\n      const spefffaceorder = [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"];\n      // These are the corners around each face in clockwise order.\n      // Each corner should give the face letters in counterclockwise\n      // order.  And they should always start with U or D.\n      const speffcornerorder = [\n        \"UBL\",\n        \"URB\",\n        \"UFR\",\n        \"ULF\",\n        \"UBL\",\n        \"ULF\",\n        \"DFL\",\n        \"DLB\",\n        \"ULF\",\n        \"UFR\",\n        \"DRF\",\n        \"DFL\",\n        \"UFR\",\n        \"URB\",\n        \"DBR\",\n        \"DRF\",\n        \"URB\",\n        \"UBL\",\n        \"DLB\",\n        \"DBR\",\n        \"DFL\",\n        \"DRF\",\n        \"DBR\",\n        \"DLB\",\n      ];\n      const reidmap: { [key: number]: number } = {};\n      for (const cubie of reidorder) {\n        for (let j = 0; j < cubie.length; j++) {\n          reidmap[this.upperStringToBitSet(cubie[j])] = j;\n        }\n      }\n      const cornerloc: { [key: number]: Quat } = {};\n      const spefffacelookup: { [key: string]: number } = {};\n      const speffcornerlocs: Quat[] = [];\n      const speffuncorner = [\n        -1, 0, 1, 0, 2, -1, 1, -1, 3, 3, -1, -1, 2, -1, -1, -1,\n      ];\n      if (this.stickersPerFace > 9) {\n        for (const vertex of this.vertexNames) {\n          cornerloc[this.upperStringToBitSet(vertex[1])] = vertex[0];\n        }\n        for (let i = 0; i < 6; i++) {\n          spefffacelookup[spefffaceorder[i]] = i;\n        }\n        for (const co of speffcornerorder) {\n          speffcornerlocs.push(cornerloc[this.upperStringToBitSet(co)]);\n        }\n      }\n      for (const cubieset of cubiesetcubies) {\n        for (const cubienum of cubieset) {\n          // corners are always Reid.  For 333, edges and centers are also\n          // Reid.\n          if (cubies[cubienum].length === 3 || this.stickersPerFace <= 9) {\n            let mask = 0;\n            for (const cubie of cubies[cubienum]) {\n              mask |=\n                1 <<\n                (this.faceNames[this.getfaceindex(cubie)][1].charCodeAt(0) -\n                  65);\n            }\n            cubieordnums[cubienum] = reidmap[mask];\n            // for larger cubes, centers and edges are Speffz.\n          } else {\n            if (cubies[cubienum].length <= 2) {\n              const ordset: [number, string][] = [];\n              for (let k = 0; k < cubies[cubienum].length; k++) {\n                const sticker = cubies[cubienum][k];\n                const facekey =\n                  spefffacelookup[\n                    this.faceNames[this.getfaceindex(sticker)][1]\n                  ];\n                let bestdist = 1e20;\n                const cubieloc = this.faces[sticker].centermass();\n                let bestmask = 0;\n                for (let i = 0; i < 4; i++) {\n                  const t = cubieloc.dist(speffcornerlocs[4 * facekey + i]);\n                  if (t + eps < bestdist) {\n                    bestdist = t;\n                    bestmask = 1 << i;\n                  } else if (t < bestdist + eps) {\n                    bestmask |= 1 << i;\n                  }\n                }\n                bestmask = speffuncorner[bestmask];\n                if (bestmask >= 0) {\n                  const speffind = 4 * facekey + bestmask;\n                  ordset.push([speffind, speffcornerorder[speffind]]);\n                }\n              }\n              if (ordset.length > 0) {\n                if (cubies[cubienum].length === 1) {\n                  cubieordnums[cubienum] = ordset[0][0];\n                } else if (\n                  ordset.length === 2 &&\n                  ordset[0][1] === ordset[1][1]\n                ) {\n                  // we have an edge, which has two faces (given by the\n                  // ordset[*][0] values divided by 4), as well as a single\n                  // corner, for which face names are given in counterclockwise\n                  // order.  The relevant speffz face (thus indicating which\n                  // of the two indices should be used) is the first one\n                  // rotationally counterclockwise.\n                  let k = 0;\n                  const f0c = spefffaceorder[ordset[0][0] >> 2];\n                  const f1c = spefffaceorder[ordset[1][0] >> 2];\n                  const corn = ordset[0][1];\n                  while (\n                    k < 3 &&\n                    (f0c === corn.charAt(k) || f1c === corn.charAt(k))\n                  ) {\n                    k++;\n                  }\n                  if (k === 3) {\n                    throw Error(\"Internal error (2) in Speffz\");\n                  }\n                  k = (k + 1) % 3;\n                  if (f0c === corn.charAt(k)) {\n                    cubieordnums[cubienum] = ordset[0][0];\n                  } else if (f1c === corn.charAt(k)) {\n                    cubieordnums[cubienum] = ordset[1][0];\n                  } else {\n                    console.log(f0c, f1c, corn, k, ordset);\n                    throw Error(\"Internal error (3) in Speffz\");\n                  }\n                }\n              }\n            }\n            // TODO:  make this work for edges too.\n          }\n        }\n      }\n    }\n    //console.log(this.vertexnames);\n    this.cubieSetNums = cubiesetnums;\n    this.cubieOrdNums = cubieordnums;\n    this.cubieSetNames = cubiesetnames;\n    this.cubieOrbitSizes = cubieords;\n    this.orbitOrientations = orbitoris;\n    this.cubieValueMap = cubievaluemap;\n    this.cubieSetCubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.options.fixedPieceType !== null) {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.options.fixedPieceType === \"v\" && cubies[i].length > 2) ||\n          (this.options.fixedPieceType === \"e\" && cubies[i].length === 2) ||\n          (this.options.fixedPieceType === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw Error(\n          `Could not find a cubie of type ${this.options.fixedPieceType} to fix.`,\n        );\n      }\n    }\n    // show the orbits\n    if (this.options.verbosity > 0) {\n      console.log(`# Cubie orbit sizes ${cubieords}`);\n    }\n    tend(t1);\n  }\n\n  public unswizzle(mv: Move): Move | null {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return null;\n    }\n    return newmv.modified({ family: this.swizzler.unswizzle(newmv.family) });\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  private stringToBlockMove(mv: string): Move {\n    // parse a move from the command line\n    const re = /^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$/;\n    const p = mv.match(re);\n    if (p === null) {\n      throw Error(`Bad move passed ${mv}`);\n    }\n    const grip = p[4];\n    let loslice: number | undefined;\n    let hislice: number | undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = `-${amountstr.substring(1)}`;\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n\n  public parseMove(\n    move: Move,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const bm = this.notationMapper.notationToInternal(move); // pluggable notation\n    if (bm === null) {\n      throw Error(`Bad move ${move.family}`);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== undefined || move.outerLayer !== undefined) {\n        throw Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo: MoveSetGeo | undefined;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    // TODO: refactor to avoid non-null-assertion\n    for (let i = 0; i < this.movesetgeos!.length; i++) {\n      const g = this.movesetgeos![i]; // TODO: refactor to avoid non-null-assertion\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw Error(`Bad grip in move ${move.family}`);\n    }\n    if (move.outerLayer !== undefined) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== undefined) {\n      if (move.outerLayer === undefined) {\n        hislice = move.innerLayer;\n        // big assumption here!  if outerlayer not specified, but inner\n        // layer is (like 2U), we use the case of the family (upper vs\n        // lower) to decide if it should be a slice turn or a wide turn.\n        if (grip <= \"Z\") {\n          // uppercase; slice move\n          loslice = hislice;\n        } else {\n          // lowercase; wide move\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    const movePlaneSets = this.movePlaneSets!; // TODO: refactor to avoid non-null-assertion\n    if (fullrotation) {\n      loslice = 0;\n      hislice = movePlaneSets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > movePlaneSets[msi].length ||\n      hislice < 0 ||\n      hislice > movePlaneSets[msi].length\n    ) {\n      throw Error(\n        `Bad slice spec ${loslice} ${hislice} vs ${movePlaneSets[msi].length}`,\n      );\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === movePlaneSets[msi].length &&\n      !fullrotation\n    ) {\n      throw Error(\"! full puzzle rotations must be specified with v suffix.\");\n    }\n    return [undefined, msi, loslice, hislice, firstgrip, move.amount];\n  }\n\n  private parsemove(\n    mv: string,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    const t1 = tstart(\"genperms\");\n    // generate permutations for moves\n    if (this.cmovesBySlice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    //\n    //  We also rotate the vertices of the face to enforce the orientation\n    //  preferences for the oriented center stickers.\n    if (this.options.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.cubies[k][0];\n          const i = this.getfaceindex(kk);\n          const center = this.baseFaces[i].centermass();\n          // TODO: refactor to avoid non-null-assertion\n          if (center.dist(this.faceCenterMass![kk]) < eps) {\n            const bits = (1 << i) | (1 << this.baseFaceCount);\n            const towards = this.markedFaceLookup[bits];\n            const normal = this.basePlanes[towards].makenormal();\n            let hiv = -1;\n            let hii = -1;\n            for (let ii = 0; ii < this.faces[kk].length; ii++) {\n              const pt = this.faces[kk].get(ii);\n              const t = normal.dot(pt.sub(center));\n              if (t > hiv) {\n                hiv = t;\n                hii = ii;\n              }\n            }\n            // if two pts have the same distance, prefer the second\n            const hii2 = (hii + 1) % this.faces[kk].length;\n            if (\n              Math.abs(normal.dot(this.faces[kk].get(hii2).sub(center)) - hiv) <\n              eps\n            ) {\n              hii = hii2;\n            }\n            // remake the face to preserve orientations\n            if (hii !== 0) {\n              const qs = [];\n              for (let ii = 0; ii < this.faces[kk].length; ii++) {\n                qs.push(this.faces[kk].get((ii + hii) % this.faces[kk].length));\n              }\n              this.faces[kk] = new Face(qs);\n            }\n            const o = this.baseFaces[i].length;\n            for (let m = 1; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][m - 1]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitOrientations![this.cubieSetNums![k]] = o; // TODO: refactor to avoid non-null-assertion\n          }\n        }\n      }\n    }\n    // TODO: refactor to avoid non-null-assertion\n    for (let k = 0; k < this.movePlaneSets!.length; k++) {\n      const moveplaneset = this.movePlaneSets![k]; // TODO: refactor to avoid non-null-assertion\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.faceCenterMass![i].dot(moveplaneset[0]); // TODO: refactor to avoid non-null-assertion\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (\n              t + b <= moveplaneset.length &&\n              dv > moveplaneset[t + b - 1].a\n            ) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = [this.faceToCubie![i], this.faceToCubieOrd![i]]; // TODO: refactor to avoid non-null-assertion\n        let cm = this.faceCenterMass![i]; // TODO: refactor to avoid non-null-assertion\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (;;) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moveRotations![k][0]); // TODO: refactor to avoid non-null-assertion\n          if (cm2.dist(ocm) < eps) {\n            break;\n          }\n          fi2 = this.findface(cm2);\n          b.push(this.faceToCubie![fi2], this.faceToCubieOrd![fi2]); // TODO: refactor to avoid non-null-assertion\n          cm = cm2;\n        }\n        // If an oriented center is moving, we need to figure out\n        // the appropriate new orientation.  Normally we use the cubie\n        // sticker identity to locate, but this doesn't work here.\n        // Instead we need to redo the geometry of the sticker itself\n        // rotating and figure out how that maps to the destination\n        // sticker.\n        //\n        // We only need to do this for central center stickers: those\n        // where the face vertex goes through the center.  The others\n        // don't actually need orientation because they can only be\n        // in one orientation by physical constraints.  (You can't spin\n        // a point or cross sticker on the 5x5x5, for example.)\n        //\n        // This also simplifies things because it means the actual\n        // remapping has the same order as the moves themselves.\n        //\n        // The center may or may not have been duplicated at this point.\n        //\n        // The move moving the center might not be the same modulo as the\n        // center itself.\n        if (\n          b.length > 2 &&\n          this.options.orientCenters &&\n          (this.cubies[b[0]].length === 1 || this.duplicatedCubies[b[0]] > 1)\n        ) {\n          // is this a real center cubie, around an axis?\n          if (\n            // TODO: refactor to avoid non-null-assertion\n            this.faceCenterMass![i].dist(\n              this.baseFaces[this.getfaceindex(i)].centermass(),\n            ) < eps\n          ) {\n            // how does remapping of the face/point set map to the original?\n            let face1 = this.faces[this.cubies[b[0]][0]];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.faces[this.cubies[b[ii]][0]];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0.get(jj).dist(face1.get(0)) < eps) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw Error(\n                  \"Couldn't find rotation of center faces; ignoring for now.\",\n                );\n              } else {\n                b[ii + 1] = o;\n                face1 = face1.rotate(this.moveRotations![k][0]); // TODO: refactor to avoid non-null-assertion\n              }\n            }\n          }\n        }\n        // b.length === 2 means a sticker is spinning in place.\n        // in this case we add duplicate stickers\n        // so that we can make it animate properly in a 3D world.\n        if (b.length === 2 && this.options.orientCenters) {\n          const dir = this.faceCenterMass![i].dot(this.movePlaneNormals![k]); // TODO: refactor to avoid non-null-assertion\n          // TODO: refactor to avoid non-null-assertion\n          for (let ii = 1; ii < this.movesetorders![k]; ii++) {\n            if (dir > 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(\n                b[0],\n                (this.movesetorders![k] - ii) % this.movesetorders![k], // TODO: refactor to avoid non-null-assertion\n              );\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          // TODO: refactor to avoid non-null-assertion\n          if (b.length !== 2 * this.movesetorders![k]) {\n            throw Error(\"Bad length in perm gen\");\n          }\n          for (const v of b) {\n            axiscmoves[sc].push(v);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      for (let kk = 0; kk < axiscmoves.length; kk++) {\n        axiscmoves[kk] = axiscmoves[kk].slice();\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesBySlice = cmovesbyslice;\n    if (this.options.moveList) {\n      const parsedmovelist: [\n        string | undefined,\n        number,\n        number,\n        number,\n        boolean,\n        number,\n      ][] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (const moveString of this.options.moveList) {\n        parsedmovelist.push(this.parsemove(moveString));\n      }\n      this.parsedMoveList = parsedmovelist;\n    }\n    this.faceListHash!.clear(); // TODO: refactor to avoid non-null-assertion\n    this.faceCenterMass = [];\n    tend(t1);\n  }\n\n  private getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.basePlanes,\n      facenames: this.faceNames,\n      faceplanes: this.facePlanes,\n      vertexnames: this.vertexNames,\n      edgenames: this.edgeNames,\n      geonormals: this.geometryNormals,\n    };\n  }\n\n  private getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.movePlaneSets![k].length; // TODO: refactor to avoid non-null-assertion\n    let r: any[] = [];\n    if (this.parsedMoveList !== undefined) {\n      for (const parsedmove of this.parsedMoveList) {\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else {\n      const msg = this.movesetgeos![k]; // TODO: refactor to avoid non-null-assertion\n      const isTetrahedron = msg[1] !== msg[3];\n      if (this.options.vertexMoves && isTetrahedron && !this.options.allMoves) {\n        if (msg[1] !== msg[3]) {\n          for (let i = 0; i < slices; i++) {\n            if (msg[1] !== \"v\") {\n              if (this.options.outerBlockMoves) {\n                r.push([i + 1, slices]);\n              } else {\n                r.push([i + 1, i + 1]);\n              }\n              r.push(1);\n            } else {\n              if (this.options.outerBlockMoves) {\n                r.push([0, i]);\n              } else {\n                r.push([i, i]);\n              }\n              r.push(1);\n            }\n          }\n        }\n      } else {\n        for (let i = 0; i <= slices; i++) {\n          if (!this.options.allMoves && i + i === slices) {\n            continue;\n          }\n          if (this.options.outerBlockMoves) {\n            if (i + i > slices) {\n              r.push([i, slices]);\n            } else {\n              r.push([0, i]);\n            }\n          } else {\n            r.push([i, i]);\n          }\n          r.push(1);\n        }\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (\n            newr[j][0] === o[0] &&\n            newr[j][1] === o[1] &&\n            newr[j + 1] === r[i + 1]\n          ) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    // TODO\n    return r;\n  }\n\n  private graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 &&\n        (this.options.grayCenters || !this.options.includeCenterOrbits)) ||\n      (ori === 2 &&\n        (this.options.grayEdges || !this.options.includeEdgeOrbits)) ||\n      (ori > 2 &&\n        (this.options.grayCorners || !this.options.includeCornerOrbits))\n    );\n  }\n\n  private skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.options.includeCenterOrbits) ||\n      (ori === 2 && !this.options.includeEdgeOrbits) ||\n      (ori > 2 && !this.options.includeCornerOrbits)\n    );\n  }\n\n  private skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  private header(comment: string): string {\n    return `${comment + copyright}\\n${comment}\\n`;\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = os.movenames[i];\n      if (!os.forcenames[i]) {\n        movename = `M_${externalName(this.notationMapper, movename)}`;\n      }\n      movename = `M_${movename}`;\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      if (doinv) {\n        r.push(`${movename}:=${os.moveops[i].toPerm().inv().toGap()};`);\n      } else {\n        r.push(`${movename}:=${os.moveops[i].toPerm().toGap()};`);\n      }\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      `ip:=[${ip\n        .map((_) => `[${_.map((__) => __ + 1).join(\",\")}]`)\n        .join(\",\")}];`,\n    );\n    r.push(\"# Size(Group(Gen));\");\n    r.push(\"# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writemathematica(): string {\n    // write out a set of generators in mathematica syntax\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    r.push(`(* ${this.header(\"\").trim()} *)`);\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = `m${externalName(this.notationMapper, os.movenames[i])}`;\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      mvs.push(movename);\n      if (doinv) {\n        r.push(`${movename}=${os.moveops[i].toPerm().inv().toMathematica()};`);\n      } else {\n        r.push(`${movename}=${os.moveops[i].toPerm().toMathematica()};`);\n      }\n    }\n    r.push(`gen={${mvs.join(\",\")}};`);\n    return r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\"): string {\n    const od = this.getOrbitsDef(false);\n    return (\n      this.header(\"# \") + od.toKsolve(name, this.notationMapper).join(\"\\n\")\n    );\n  }\n\n  public getKPuzzleDefinition(\n    fortwisty: boolean = true,\n    includemoves: boolean = true,\n  ): KPuzzleDefinition {\n    const od = this.getOrbitsDef(fortwisty, includemoves);\n    const internalDefinition = od.toKPuzzleDefinition(includemoves);\n    (internalDefinition as any).experimentalPuzzleDescription =\n      this.puzzleDescription;\n    if (!internalDefinition) {\n      throw Error(\"Missing definition!\");\n    }\n    return internalDefinition;\n  }\n\n  public getMoveFromBits(\n    moverange: number[],\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): PGTransform {\n    const moveorbits: PGOrbit[] = [];\n    const perms = [];\n    const oris = [];\n    // TODO: refactor to avoid non-null-assertion\n    for (const len of this.cubieOrbitSizes!) {\n      perms.push(iota(len));\n      oris.push(zeros(len));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubieSetNums![mperm[0]]; // TODO: refactor to avoid non-null-assertion\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieOrdNums![mperm[ii]]; // TODO: refactor to avoid non-null-assertion\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieOrbitSizes![setnum])) {\n          // TODO: refactor to avoid non-null-assertion\n          perms[setnum] = perms[setnum].slice();\n          if (\n            this.orbitOrientations![setnum] > 1 && // TODO: refactor to avoid non-null-assertion\n            !this.options.fixedOrientation\n          ) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (\n            this.orbitOrientations![setnum] > 1 && // TODO: refactor to avoid non-null-assertion\n            !this.options.fixedOrientation\n          ) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitOrientations![setnum]) % // TODO: refactor to avoid non-null-assertion\n              this.orbitOrientations![setnum]; // TODO: refactor to avoid non-null-assertion\n          }\n        }\n      }\n    }\n    let lastId = new PGOrbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubieSetNames!.length; ii++) {\n      // TODO: refactor to avoid non-null-assertion\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitOrientations![ii] === 1 || this.options.fixedOrientation) {\n        // TODO: refactor to avoid non-null-assertion\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new PGOrbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(\n          new PGOrbit(perms[ii], no, this.orbitOrientations![ii]),\n        ); // TODO: refactor to avoid non-null-assertion\n      }\n    }\n    let mv = new PGTransform(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  private omitSet(name: string): boolean {\n    for (const excludedSet of this.options.excludeOrbits) {\n      if (excludedSet === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private diffmvsets(a: any[], b: any[], slices: number, neg: boolean) {\n    for (let i = 0; i < a.length; i += 2) {\n      let found = false;\n      for (let j = 0; !found && j < b.length; j += 2) {\n        if (neg) {\n          if (\n            a[i][0] + b[j][1] === slices &&\n            a[i][1] + b[j][0] === slices &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        } else {\n          if (\n            a[i][0] === b[j][0] &&\n            a[i][1] === b[j][1] &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // TODO: This is only public for testing; can we make it private again?\n  public getOrbitsDef(\n    fortwisty: boolean,\n    includemoves: boolean = true,\n  ): PGOrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    if (fortwisty) {\n      // TODO: refactor to avoid non-null-assertion\n      for (let i = 0; i < this.cubieSetNames!.length; i++) {\n        setmoves.push(1);\n      }\n    }\n    const setnames: string[] = [];\n    const setdefs: PGOrbitDef[] = [];\n    // if both a movelist and rotations are needed, don't add rotations\n    // that do not preserve the movelist.\n    const mps = [];\n    const addrot = [];\n    // TODO: refactor to avoid non-null-assertion\n    for (let k = 0; k < this.movePlaneSets!.length; k++) {\n      const moveset = this.getmovesets(k);\n      mps.push(moveset);\n      if (this.options.addRotations) {\n        addrot.push(1);\n      } else {\n        addrot.push(0);\n      }\n    }\n    const hasrotation = [];\n    // TODO: refactor to avoid non-null-assertion\n    for (let k = 0; k < this.movePlaneSets!.length; k++) {\n      const slices = this.movePlaneSets![k].length; // TODO: refactor to avoid non-null-assertion\n      // if the move set includes a rotation around this axis, don't add any more\n      let sawone = false;\n      const moveset = mps[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        if (moveset[i][0] === 0 && moveset[i][1] === slices) {\n          sawone = true;\n        }\n      }\n      hasrotation[k] = sawone;\n    }\n    if (\n      this.options.addRotations &&\n      (this.options.moveList || this.options.fixedPieceType !== null)\n    ) {\n      for (let i = 0; i < this.moveRotations!.length; i++) {\n        // TODO: refactor to avoid non-null-assertion\n        addrot[i] = 0;\n      }\n      for (let k = 0; k < this.movePlaneSets!.length; k++) {\n        // TODO: refactor to avoid non-null-assertion\n        // if the move set includes a rotation around this axis, don't add any more\n        if (hasrotation[k]) {\n          addrot[k] = 3;\n          continue;\n        }\n        // does a rotation around k preserve the move set?\n        for (let i = 0; i < this.moveRotations!.length; i++) {\n          // TODO\n          let nn = this.movePlaneNormals![k]; // TODO\n          for (let ii = 1; ii * 2 <= this.movesetorders![i]; ii++) {\n            // TODO\n            nn = nn.rotatepoint(this.moveRotations![i][0]); // TODO\n            if (addrot[i] & ii) {\n              continue;\n            }\n            let found = -1;\n            let neg = false;\n            for (let j = 0; j < this.movePlaneNormals!.length; j++) {\n              // TODO\n              if (nn.dist(this.movePlaneNormals![j]) < eps) {\n                // TODO\n                found = j;\n                break;\n              } else if (nn.dist(this.movePlaneNormals![j].smul(-1)) < eps) {\n                // TODO\n                found = j;\n                neg = true;\n                break;\n              }\n            }\n            if (found < 0) {\n              throw Error(\"Could not find rotation\");\n            }\n            const cmp = mps[found];\n            if (\n              cmp.length !== mps[k].length ||\n              this.movePlaneSets![k].length !== // TODO\n                this.movePlaneSets![found].length || // TODO\n              this.diffmvsets(\n                cmp,\n                mps[k],\n                this.movePlaneSets![found].length, // TODO\n                neg,\n              )\n            ) {\n              addrot[i] |= ii;\n            }\n          }\n        }\n      }\n      for (let i = 0; i < this.moveRotations!.length; i++) {\n        // TODO: refactor to avoid non-null-assertion\n        if (addrot[i] === 0) {\n          addrot[i] = 1;\n        } else if (addrot[i] === 1) {\n          if (this.movesetorders![i] > 3) {\n            // TODO: refactor to avoid non-null-assertion\n            addrot[i] = 2;\n          } else {\n            addrot[i] = 0;\n          }\n        } else if (addrot[i] === 3) {\n          addrot[i] = 0;\n        } else {\n          throw Error(\"Impossible addrot val\");\n        }\n      }\n    }\n    for (let k = 0; k < this.movePlaneSets!.length; k++) {\n      // TODO: refactor to avoid non-null-assertion\n      if (addrot[k] !== 0 && !hasrotation[k]) {\n        mps[k].push([0, this.movePlaneSets![k].length]); // TODO: refactor to avoid non-null-assertion\n        mps[k].push(addrot[k]);\n      }\n    }\n    for (let k = 0; k < this.movePlaneSets!.length; k++) {\n      // TODO: refactor to avoid non-null-assertion\n      const moveset = mps[k];\n      const movesetorder = this.movesetorders![k]; // TODO: refactor to avoid non-null-assertion\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (\n            moveset[i][0] === moveset[j][0] &&\n            moveset[i][1] === moveset[j][1]\n          ) {\n            throw Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesBySlice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubieSetNums![slicecmoves[j]]; // TODO: refactor to avoid non-null-assertion\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubieSetNames!.length; i++) {\n      // TODO: refactor to avoid non-null-assertion\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubieSetNames![i])) {\n        // TODO: refactor to avoid non-null-assertion\n        setmoves[i] = 0;\n        continue;\n      }\n      setnames.push(this.cubieSetNames![i]); // TODO: refactor to avoid non-null-assertion\n      setdefs.push(\n        new PGOrbitDef(\n          this.cubieOrbitSizes![i], // TODO: refactor to avoid non-null-assertion\n          this.options.fixedOrientation ? 1 : this.orbitOrientations![i], // TODO: refactor to avoid non-null-assertion\n        ),\n      );\n    }\n    const solved: PGOrbit[] = [];\n    for (let i = 0; i < this.cubieSetNames!.length; i++) {\n      // TODO: refactor to avoid non-null-assertion\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubieSetNames![i])) {\n        // TODO: refactor to avoid non-null-assertion\n        continue;\n      }\n      const p = Array(this.cubieOrbitSizes![i]).fill(-1);\n      const o = [];\n      for (let j = 0; j < this.cubieOrbitSizes![i]; j++) {\n        // TODO: refactor to avoid non-null-assertion\n        if (fortwisty) {\n          p[j] = j;\n        } else {\n          const cubie = this.cubieSetCubies![i][j]; // TODO: refactor to avoid non-null-assertion\n          p[this.cubieOrdNums![cubie]] = this.cubieValueMap![cubie]; // TODO: refactor to avoid non-null-assertion\n        }\n        o.push(0);\n      }\n      solved.push(\n        new PGOrbit(\n          p,\n          o,\n          this.options.fixedOrientation ? 1 : this.orbitOrientations![i], // TODO: refactor to avoid non-null-assertion\n        ),\n      );\n    }\n    const movenames: string[] = [];\n    const forcenames: boolean[] = [];\n    const moves: PGTransform[] = [];\n    const isrots: boolean[] = [];\n    if (includemoves) {\n      for (let k = 0; k < this.movePlaneSets!.length; k++) {\n        // TODO: refactor to avoid non-null-assertion\n        const moveplaneset = this.movePlaneSets![k]; // TODO: refactor to avoid non-null-assertion\n        const slices = moveplaneset.length;\n        const moveset = mps[k];\n        const movesetgeo = this.movesetgeos![k]; // TODO: refactor to avoid non-null-assertion\n        for (let i = 0; i < moveset.length; i += 2) {\n          const movebits = moveset[i];\n          // did these movebits come from a specified move?\n          // if they did, we need to use that name.\n          let nameoverride: string | undefined;\n          let inverted = false;\n          if (this.parsedMoveList !== undefined) {\n            for (const parsedmove of this.parsedMoveList) {\n              if (parsedmove[1] !== k) {\n                continue;\n              }\n              let r = [];\n              if (parsedmove[4]) {\n                r = [parsedmove[2], parsedmove[3]];\n              } else {\n                r = [slices - parsedmove[3], slices - parsedmove[2]];\n              }\n              if (r[0] === movebits[0] && r[1] === movebits[1]) {\n                nameoverride = parsedmove[0];\n                inverted = !parsedmove[4];\n              }\n            }\n          }\n          if (nameoverride) {\n            movenames.push(nameoverride);\n            forcenames.push(true);\n          } else {\n            const mna = getmovename(movesetgeo, movebits, slices);\n            inverted = mna[1];\n            const movename = mna[0];\n            if (moveset[i + 1] === 1) {\n              movenames.push(movename);\n            } else {\n              movenames.push(movename + moveset[i + 1]);\n            }\n            forcenames.push(false);\n          }\n          isrots.push(movebits[0] === 0 && movebits[1] === slices);\n          const mv = this.getMoveFromBits(\n            movebits,\n            moveset[i + 1],\n            inverted,\n            this.cmovesBySlice[k],\n            setmoves,\n            this.movesetorders![k], // TODO: refactor to avoid non-null-assertion\n          );\n          moves.push(mv);\n        }\n      }\n    }\n    let r = new PGOrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n      isrots,\n      forcenames,\n    );\n    if (this.options.optimizeOrbits) {\n      r = r.optimize();\n    }\n    if (this.options.scrambleAmount !== 0) {\n      r.scramble(this.options.scrambleAmount);\n    }\n    return r;\n  }\n\n  public getScramble(n: number = 0): KTransformationData {\n    const od = this.getOrbitsDef(false);\n    return od.toKTransformationData(od.getScrambleTransformation(n));\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      for (let j = 0; j < this.stickersPerFace; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  private getOrientationRotation(desiredRotation: any[]): Quat {\n    const [feature1name, [x1, y1, z1]] = desiredRotation[0];\n    const direction1 = new Quat(0, x1, -y1, z1);\n\n    const [feature2name, [x2, y2, z2]] = desiredRotation[1];\n    const direction2 = new Quat(0, x2, -y2, z2);\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geometryNormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw Error(`Could not find feature ${feature1name}`);\n    }\n    if (!feature2) {\n      throw Error(`Could not find feature ${feature2name}`);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  private getInitial3DRotation(): Quat {\n    const basefacecount = this.baseFaceCount;\n    let orientationDescription: FaceBasedOrientationDescription | null = null;\n    if (this.options.puzzleOrientation) {\n      orientationDescription = this.options.puzzleOrientation;\n    } else if (this.options.puzzleOrientations) {\n      orientationDescription = this.options.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!orientationDescription) {\n      orientationDescription = defaultOrientations()[basefacecount];\n    }\n    if (!orientationDescription) {\n      throw Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(orientationDescription);\n  }\n\n  private generate2dmapping(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n    twodshrink: number = 0.92,\n  ): (fn: number, q: Quat) => number[] {\n    // generate a mapping to use for 2D for textures, svg\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges[f0]) {\n        throw Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (const esi of es) {\n        minx = Math.min(minx, esi[0]);\n        maxx = Math.max(maxx, esi[0]);\n        miny = Math.min(miny, esi[1]);\n        maxy = Math.max(maxy, esi[1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: Record<string, Quat[]> = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.faceNames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges2[f0]) {\n        throw Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw Error(`Could not find first face name ${f0}`);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.faceNames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let face of this.faces) {\n      if (threed) {\n        face = face.rotate(rot);\n      }\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face.get(j).b));\n        hiy = Math.max(hiy, Math.abs(face.get(j).c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        q = q.rotatepoint(rot);\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.basePlanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.faceNames[fn][1]];\n        return [\n          trim + twodshrink * q.dot(g[0]) + g[2].b,\n          trim + h - twodshrink * q.dot(g[1]) - g[2].c,\n        ];\n      }\n    };\n    return mappt2d;\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    const mappt2d = this.generate2dmapping(w, h, trim, threed);\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return `<polygon id=\"${id}\" class=\"sticker\" style=\"fill: ${color}\" points=\"${pts\n        .map((p) => `${p[0]} ${p[1]}`)\n        .join(\" \")}\"/>\\n`;\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      colormap[i] = this.colors[this.faceNames[i][1]];\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersPerFace);\n      const fg = [];\n      for (let j = 0; j < face.length; j++) {\n        fg.push(mappt2d(facenum, face.get(j)));\n      }\n      facegeo.push(fg);\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.baseFaceCount; j++) {\n      svg.push(\"<g>\");\n      svg.push(`<title>${this.faceNames[j][1]}</title>\\n`);\n      for (let ii = 0; ii < this.stickersPerFace; ii++) {\n        const i = j * this.stickersPerFace + ii;\n        const cubie = this.faceToCubie![i]; // TODO: refactor to avoid non-null-assertion\n        const cubieori = this.faceToCubieOrd![i]; // TODO: refactor to avoid non-null-assertion\n        const cubiesetnum = this.cubieSetNums![cubie]; // TODO: refactor to avoid non-null-assertion\n        const cubieord = this.cubieOrdNums![cubie]; // TODO: refactor to avoid non-null-assertion\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id = `${this.cubieSetNames![cubiesetnum]}-l${cubieord}-o${cubieori}`; // TODO: refactor to avoid non-null-assertion\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = `${this.cubieSetNames![cubiesetnum]}-l${cubieord}-o${jj}`; // TODO: refactor to avoid non-null-assertion\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const html = `<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n<style type=\"text/css\"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\\n${svg.join(\n      \"\",\n    )}</svg>`;\n    return html;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(options?: {\n    stickerColors?: string[];\n    darkIgnoredOrbits?: boolean;\n  }): StickerDat {\n    const stickers = [];\n    const rot = this.getInitial3DRotation();\n    const faces = [];\n    const maxdist: number = 0.52 * this.baseFaces[0].get(0).len();\n    for (let i = 0; i < this.baseFaces.length; i++) {\n      const coords = this.baseFaces[i].rotate(rot);\n      const name = this.faceNames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersPerFace);\n      const cubie = this.faceToCubie![i]; // TODO: refactor to avoid non-null-assertion\n      const cubieori = this.faceToCubieOrd![i]; // TODO: refactor to avoid non-null-assertion\n      const cubiesetnum = this.cubieSetNums![cubie]; // TODO: refactor to avoid non-null-assertion\n      const cubieord = this.cubieOrdNums![cubie]; // TODO: refactor to avoid non-null-assertion\n      let color = this.graybyori(cubie)\n        ? options?.darkIgnoredOrbits\n          ? \"#222222\"\n          : \"#808080\"\n        : this.colors[this.faceNames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      const coords = this.faces[i].rotate(rot);\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubieSetNames![cubiesetnum], // TODO: refactor to avoid non-null-assertion\n        ord: cubieord,\n        ori: cubieori,\n        face: facenum,\n      });\n      let fcoords = coords;\n      if (this.duplicatedFaces[i]) {\n        const rotdist = fcoords.length / this.duplicatedFaces[i];\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          for (let k = 0; k < rotdist; k++) {\n            fcoords = fcoords.rotateforward();\n          }\n          stickers.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubieSetNames![cubiesetnum], // TODO: refactor to avoid non-null-assertion\n            ord: cubieord,\n            ori: jj,\n            face: facenum,\n            isDup: true,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    // TODO: refactor to avoid non-null-assertion\n    for (let i = 0; i < this.movesetgeos!.length; i++) {\n      const msg = this.movesetgeos![i]; // TODO: refactor to avoid non-null-assertion\n      const order = this.movesetorders![i]; // TODO: refactor to avoid non-null-assertion\n      for (const gn of this.geometryNormals) {\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot), 1),\n            quantumMove: new Move(msg[0]),\n            order,\n          });\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            quantumMove: new Move(msg[2]),\n            order,\n          });\n        }\n      }\n    }\n    const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1.0);\n    const g = (() => {\n      const irot = rot.invrot();\n      return (facenum: number, coords: number[]): number[] => {\n        let q = new Quat(\n          0,\n          coords[0] * maxdist,\n          -coords[1] * maxdist,\n          coords[2] * maxdist,\n        );\n        q = q.rotatepoint(irot);\n        const x = twodmapper(facenum, q);\n        x[0] /= 2880;\n        x[1] = 1 - x[1] / 2160;\n        return x;\n      };\n    })().bind(this);\n    return {\n      stickers,\n      faces,\n      axis: grips,\n      unswizzle: this.unswizzle.bind(this),\n      notationMapper: this.notationMapper,\n      textureMapper: { getuv: g },\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (const gn of this.geometryNormals) {\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersPerFace;\n    return Math.floor(facenum / divid);\n  }\n\n  public textForTwizzleExplorer(): string {\n    return `Faces ${this.basePlaneRotations.length}\nStickers per face ${this.stickersPerFace}\nShort edge ${this.shortestEdge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgeDistance}\nVertex distance ${this.vertexDistance}`;\n  }\n\n  writeSchreierSims(tw: (s: string) => void) {\n    const os = this.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    tw(`Reassembly size is ${as}`);\n    const ss = schreierSims(this.getMovesAsPerms(), tw);\n    const r = as / ss;\n    tw(`Ratio is ${r}`);\n  }\n}\n\nexport class PGNotation {\n  private orbitNames: string[];\n  constructor(\n    private pg: PuzzleGeometry,\n    od: PGOrbitsDef,\n  ) {\n    this.orbitNames = od.orbitnames;\n  }\n\n  public lookupMove(move: Move): KTransformationData | null {\n    const mv = this.pg.parseMove(move);\n    // if a move list subset is defined, don't return moves outside the subset.\n    if (this.pg.parsedMoveList) {\n      let found = false;\n      for (const parsedmove of this.pg.parsedMoveList) {\n        if (\n          parsedmove[1] === mv[1] &&\n          parsedmove[2] === mv[2] &&\n          parsedmove[3] === mv[3] &&\n          parsedmove[4] === mv[4]\n        ) {\n          found = true;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      // TODO: refactor to avoid non-null-assertion\n      const slices = this.pg.movePlaneSets![mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesBySlice[mv[1]],\n      undefined,\n      this.pg.movesetorders![mv[1]], // TODO: refactor to avoid non-null-assertion\n    );\n    const r = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);\n    return r;\n  }\n\n  remapKPuzzleDefinition(\n    kpuzzleDefinition: KPuzzleDefinition,\n  ): KPuzzleDefinition {\n    return remapKPuzzleDefinition(kpuzzleDefinition, this.pg.notationMapper);\n  }\n}\n","export enum PGColors {\n  White = \"#ffffff\",\n  Orange = \"#ff8000\",\n  Green = \"#44ee00\",\n  Red = \"#ff0000\",\n  Blue = \"#2266ff\",\n  Yellow = \"#f4f400\",\n\n  LightGray = \"#aaaaaa\",\n  MediumGray = \"#888888\",\n  DarkGray = \"#5c5c5c\",\n\n  Purple = \"#8800dd\",\n  Cream = \"#e8d0a0\",\n  Pink = \"#ff66cc\",\n\n  BoldBlue = \"#0000ff\",\n  Aqua = \"#3399ff\",\n  DarkGreen = \"#008800\",\n  Lime = \"#99ff00\",\n  Teal = \"#007a89\",\n  Brown = \"#7d3b11\",\n  Lavender = \"#b9a1ff\",\n  SeaGreen = \"#5ec4b6\",\n  harcoal = \"#292929\",\n  Burgundy = \"#980000\",\n  Cerise = \"#d41f69\",\n}\n\n// TODO: change this back to a const JSON definition.\nexport function defaultPlatonicColorSchemes(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: {\n      F: PGColors.Green,\n      D: PGColors.Yellow,\n      L: PGColors.Red,\n      R: PGColors.Blue,\n    },\n    6: {\n      U: PGColors.White,\n      F: PGColors.Green,\n      R: PGColors.Red,\n      D: PGColors.Yellow,\n      B: PGColors.Blue,\n      L: PGColors.Orange,\n    },\n    8: {\n      U: PGColors.White,\n      F: PGColors.Green,\n      R: PGColors.Red,\n      D: PGColors.Yellow,\n      BB: PGColors.Blue,\n      L: PGColors.Purple,\n      BL: PGColors.Orange,\n      BR: PGColors.MediumGray,\n    },\n    12: {\n      U: PGColors.White,\n      F: PGColors.DarkGreen,\n      R: PGColors.Red,\n      C: PGColors.Cream,\n      A: PGColors.Aqua,\n      L: PGColors.Purple,\n      E: PGColors.Pink,\n      BF: PGColors.Lime,\n      BR: PGColors.BoldBlue,\n      BL: PGColors.Yellow,\n      I: PGColors.Orange,\n      D: PGColors.MediumGray,\n    },\n    20: {\n      R: PGColors.Yellow,\n      C: PGColors.Cerise,\n      F: PGColors.DarkGreen,\n      E: PGColors.DarkGray,\n      L: PGColors.Purple,\n      U: PGColors.White,\n      A: PGColors.Teal,\n      G: PGColors.Red,\n      I: PGColors.Brown,\n      S: PGColors.Lavender,\n      H: PGColors.Aqua,\n      J: PGColors.SeaGreen,\n      B: PGColors.Green,\n      K: PGColors.Cream,\n      D: PGColors.LightGray,\n      M: PGColors.Pink,\n      O: PGColors.harcoal,\n      P: PGColors.Orange,\n      N: PGColors.Burgundy,\n      Q: PGColors.BoldBlue,\n    },\n  };\n}\n","import { Move } from \"../../alg\";\nimport type { KPuzzleDefinition } from \"../../kpuzzle\";\n\nexport interface NotationMapper {\n  notationToInternal(move: Move): Move | null;\n  notationToExternal(move: Move): Move | null;\n}\n\nexport function remapKPuzzleDefinition(\n  internalDefinition: KPuzzleDefinition,\n  notationMapper: NotationMapper,\n): KPuzzleDefinition {\n  const externalDefinition: KPuzzleDefinition = {\n    ...internalDefinition,\n    moves: {},\n  };\n  for (const [internalMoveName, transformationData] of Object.entries(\n    internalDefinition.moves,\n  )) {\n    let prefix = internalMoveName;\n    let suffix = \"\";\n    if ([\"v\", \"w\"].includes(internalMoveName.at(-1)!)) {\n      prefix = internalMoveName.slice(0, -1);\n      suffix = internalMoveName.slice(-1);\n    }\n    const externalPrefix = notationMapper.notationToExternal(\n      Move.fromString(prefix),\n    );\n    if (!externalPrefix) {\n      continue;\n    }\n    const externalMoveName = externalPrefix + suffix;\n    if (!externalMoveName) {\n      throw new Error(\n        `Missing external move name for: ${internalMoveName.toString()}`,\n      );\n    }\n    externalDefinition.moves[externalMoveName.toString()] = transformationData;\n  }\n  return externalDefinition;\n}\n","import {\n  type PuzzleDescription,\n  parsePuzzleDescription,\n} from \"./PuzzleGeometry\";\n\nexport function parseOptions(argv: string[]): {\n  puzzleDescription: PuzzleDescription | null;\n  options: PuzzleGeometryOptions;\n} {\n  let argp = 0;\n  const options: PuzzleGeometryOptions = {};\n  while (argp < argv.length && argv[argp][0] === \"-\") {\n    const option = argv[argp++];\n    if (option === \"--rotations\") {\n      options.addRotations = true;\n    } else if (option === \"--allmoves\") {\n      options.allMoves = true;\n    } else if (option === \"--outerblockmoves\") {\n      options.outerBlockMoves = true;\n    } else if (option === \"--vertexmoves\") {\n      options.vertexMoves = true;\n    } else if (option === \"--nocorners\") {\n      options.includeCornerOrbits = false;\n    } else if (option === \"--noedges\") {\n      options.includeEdgeOrbits = false;\n    } else if (option === \"--noorientation\") {\n      options.fixedOrientation = true;\n    } else if (option === \"--nocenters\") {\n      options.includeCenterOrbits = false;\n    } else if (option === \"--omit\") {\n      options.excludeOrbits = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--moves\") {\n      options.moveList = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--optimize\") {\n      options.optimizeOrbits = true;\n    } else if (option === \"--scramble\") {\n      options.scrambleAmount = 100;\n    } else if (option === \"--fixcorner\") {\n      options.fixedPieceType = \"v\";\n    } else if (option === \"--fixedge\") {\n      options.fixedPieceType = \"e\";\n    } else if (option === \"--fixcenter\") {\n      options.fixedPieceType = \"f\";\n    } else if (option === \"--orientcenters\") {\n      options.orientCenters = true;\n    } else if (option === \"--puzzleorientation\") {\n      options.puzzleOrientation = JSON.parse(argv[argp]); // TODO: Validate input.\n      argp++;\n    } else {\n      throw new Error(`Bad option: ${option}`);\n    }\n  }\n  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(\" \"));\n  return { puzzleDescription, options };\n}\n\ntype FaceName = string;\ntype OrientationDirection = [number, number, number];\nexport type FaceBasedOrientationDescription = [\n  [FaceName, OrientationDirection],\n  [FaceName, OrientationDirection],\n];\nexport type BaseFaceCount = 4 | 6 | 8 | 12 | 20;\nexport type FaceBasedOrientationDescriptionLookup = Record<\n  BaseFaceCount,\n  FaceBasedOrientationDescription\n>;\n\nexport class PuzzleGeometryFullOptions {\n  verbosity: number = 0; // verbosity (console.log)\n\n  allMoves: boolean = false; // generate all slice moves in ksolve\n  outerBlockMoves: boolean = false; // generate outer block moves\n  vertexMoves: boolean = false; // generate vertex moves\n  addRotations: boolean = false; // add symmetry information to ksolve output\n  moveList: string[] | null = null; // move list to generate\n\n  fixedOrientation: boolean = false; // eliminate any orientations\n  fixedPieceType: null | \"e\" | \"v\" | \"f\" = null; // fix a piece?\n  orientCenters: boolean = false; // orient centers?\n\n  // TODO: Group these into a single object?\n  includeCornerOrbits: boolean = true; // include corner orbits\n  includeCenterOrbits: boolean = true; // include center orbits\n  includeEdgeOrbits: boolean = true; // include edge orbits\n  // Overrides the previous options.\n  excludeOrbits: string[] = []; // exclude these orbits\n  optimizeOrbits: boolean = false; // optimize PermOri\n\n  grayCorners: boolean = false; // make corner sets gray\n  grayCenters: boolean = false; // make center sets gray\n  grayEdges: boolean = false; // make edge sets gray\n\n  puzzleOrientation: FaceBasedOrientationDescription | null = null; // single puzzle orientation from options\n  puzzleOrientations: FaceBasedOrientationDescriptionLookup | null = null; // puzzle orientation override object from options // TODO: is this needed?\n\n  scrambleAmount: number = 0; // scramble?\n\n  constructor(options: PuzzleGeometryOptions = {}) {\n    Object.assign(this, options);\n  }\n}\n\nexport type PuzzleGeometryOptions = Partial<PuzzleGeometryFullOptions>;\n"],"names":["FaceNameSwizzler","constructor","facenames","gripnames_arg","this","gripnames","i","prefixFree","length","j","startsWith","setGripNames","names","splitByFaceNames","s","r","at","currentMatch","substr","Error","push","joinByFaceIndices","list","sep","join","spinmatch","userinput","longname","e1","e2","found","spinmatchv","endsWith","slice","unswizzle","upperCaseGrip","toUpperCase","g","FaceRenamingMapper","internalNames","externalNames","convertString","grip","a","b","suffix","upper","isLowerCase","toLowerCase","convert","move","family","ngrip","Move","QuantumMove","innerLayer","outerLayer","amount","notationToInternal","notationToExternal","FTONotationMapper","child","sw","fam","substring","MegaminxScramblingNotationMapper","Math","abs","NullMapper","NxNxNCubeMapper","slices","pyraminxFamilyMap","U","L","R","B","u","l","Uv","Lv","Rv","Bv","D","F","BL","BR","tetraminxFamilyMap","d","f","bl","br","pyraminxFamilyMapWCA","pyraminxExternalQuantumY","pyraminxInternalQuantumY","PyraminxNotationMapper","wcaHack","map","newFamilyWCA","newFamily","isIdentical","quantum","external","internal","Object","entries","TetraminxNotationMapper","super","skewbFamilyMap","UL","UR","ULv","Fv","URv","Dv","skewbExternalQuantumX","skewbInternalQuantumX","skewbInternalQuantumXPrime","skewbExternalQuantumY","skewbInternalQuantumY","skewbInternalQuantumYPrime","skewbExternalQuantumZ","skewbInternalQuantumZ","skewbInternalQuantumZPrime","SkewbNotationMapper","zeroCache","iotaCache","zeros","n","c","Array","iota","lcm","t","m","gcd","Perm","_Perm","p","toString","mul","p2","rmul","inv","compareTo","toGap","cyc","seen","incyc","reverse","toMathematica","order","cs","PGOrbitDef","size","mod","reassemblySize","BigInt","factorial","lastGlobalDefinitionCounter","externalName","mapper","moveString","mv","fromString","mv2","PGOrbitsDef","_PGOrbitsDef","orbitnames","orbitdefs","solved","movenames","moveops","isRotation","forcenames","toKTransformationData","ktransformationData","orbits","toKTransformationOrbitData","toKPatternData","kpatternData","toKPatternOrbitData","transformToKTransformationData","mp","describeSet","mvname","pd","perm","ori","toKsolve","name","arguments","undefined","result","appendDefinition","name2","doinv","toKPuzzleDefinition","includemoves","defaultPatternData","orbitName","numPieces","numOrientations","defaultPatternFrom","pieces","permutation","orientation","orientationDelta","moves","defaultPattern","optimize","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","DisjointUnion","changed","k","union","keepori","duo","o","find","nontriv","multiple","h","no","on","nv","remapVS","remap","killOri","VisibleState","_","PGTransform","scramble","getScrambleTransformation","pool","floor","random","ri","rj","rm","PGOrbit","_PGOrbit","orimod","e","newPerm","newOri","equal","toPerm","identicalPieces","done","v","isIdentity","zeroOris","nextNew","reassign","ov","useVS","newori","ktransformationCache","orientationMod","PGTransformBase","internalMul","newOrbits","internalInv","orbit","perms","_PGTransform","mulScalar","_VisibleState","heads","ah","bh","PGPuzzles","skewb","helicopter","dino","pyramorphix","mastermorphix","pyraminx","tetraminx","megaminx","gigaminx","teraminx","petaminx","examinx","zetaminx","yottaminx","pentultimate","starminx","chopasaurus","FTO","octastar","icosamate","Redicosahedron","Icosaminx","eps","centermassface","face","Quat","sum","smul","solvethreeplanes","p1","p3","planes","intersect3","dt","_Quat","q","dist","hypot","len","cross","dot","normalize","sqrt","makenormal","normalizeplane","sub","angle","acos","invrot","det3x3","a00","a01","a02","a10","a11","a12","a20","a21","a22","rotateplane","orthogonal","ab","ac","ad","pointrotation","unproject","rotatepoint","rotateface","det","side","x","cutface","inout","nface","kk","vk","r2","pt","cutfaces","faces","nfaces","faceside","sameplane","makecut","eps2","uniqueplanes","planerot","wasseen","getface","FactoredNumber","mult","multiply","schreierSims","disp","identity","sgs","sgsi","sgslen","Tk","Tklen","knutha","knuthb","resolve","none","sz","tks","sollen","avgs","mults","cnt","lensum","avg","getsgs","Face","_Face","coords","get","off","centermass","sx","sy","rotate","rotateforward","FaceTree","_FaceTree","left","right","split","collect","arr","leftfirst","eps3","orientationDefaults","findelement","getPG3DNamedPuzzles","getPuzzleDescriptionString","puzzleName","PUZZLE_BASE_SHAPES","PUZZLE_CUT_TYPES","parsePuzzleDescription","filter","Boolean","shape","cuts","cutType","distance","parseFloat","getPuzzleGeometryByDesc","desc","options","parsed","pg","PuzzleGeometry","assign","allMoves","allstickers","genperms","getPuzzleGeometryByName","getmovename","geo","bits","inverted","movenameFamily","movenamePrefix","String","facename","toCoords","maxdist","toFaceCoords","puzzleDescription","PuzzleGeometryFullOptions","verbosity","console","log","header","movePlanes","movePlanesFiltered","cubies","s5","cube","octahedron","dx","dy","dd","ang","PI","cos","sin","icosahedron","d36","dodecahedron","rotations","ns","negns","closure","baseplane","basePlaneRotations","baseplanes","basePlanes","baseFaceCount","net","colors","BB","C","A","E","BF","I","G","S","H","J","K","M","O","P","N","Q","baseface","zero","facenormal","edgenormal","vertexnormal","boundary","firstface","edgeDistance","vertexDistance","cutplanes","intersects","sawface","sawedge","sawvertex","cut","normal","addRotations","baseFaces","baseplanerot","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","el","jj","otherfaces","facelist","facenametoindex","faceindextoname","neti","fi","ii","fn2","of","faceplane","midpoint","jjj","midpoint2","swizzler","oridata","markedface","oriprefs","fn","f1","f2","c1","c2","st","markedFaceLookup","geonormals","edgename","vertexname","faceNames","facePlanes","edgeNames","vertexNames","geometryNormals","geonormalnames","rotation","moveplane","ft","tar","rval","stickersPerFace","simplerot","cm","finished","sortme","cm2","sort","rot","shortestEdge","addNotationMapper","setReidOrSpeffzOrder","notationMapper","movePlaneSets","movePlaneNormals","movesetorders","movesetgeos","faceCenterMass","faceToCubie","faceToCubieOrd","moveRotations","faceListHash","cubieSetNames","cubieOrbitSizes","cubieSetNums","cubieOrdNums","orbitOrientations","cubieValueMap","cubieSetCubies","cmovesBySlice","parsedMoveList","duplicatedFaces","duplicatedCubies","fixedCubie","keyface","keyface2","sfcc","fromCharCode","moveplaneset","dv","keyface3","findface","key","face2","project2d","facen","edgen","targvec","edgen2","plane","x0","olen","y0","delta","cosr","sinr","x1","y1","upperStringToBitSet","charCodeAt","rots","expandfaces","moveplanesets","moveplanenormals","qnormal","moveplanenormal","goodnormal","sizes","moverotations","sizes2","gtype","p0","neg","pos","geonormal","facelisthash","Map","suff","s2","set","facetocubie","facetoord","values","cmall","looplimit","mini","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","getcolorkey","cubienum","getfaceindex","cubiesetcubies","cubie","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","moverotation","tq","reidorder","spefffaceorder","speffcornerorder","reidmap","cornerloc","spefffacelookup","speffcornerlocs","speffuncorner","vertex","co","cubieset","mask","ordset","sticker","facekey","bestdist","cubieloc","bestmask","speffind","f0c","f1c","corn","charAt","fixedPieceType","newmv","modified","stringToBlockMove","match","loslice","hislice","parseInt","amountstr","parseMove","bm","fullrotation","msi","geoname","firstgrip","parsemove","cmovesbyslice","orientCenters","center","towards","hiv","hii","hii2","qs","slicenum","slicecnts","bhi","axiscmoves","sc","cubiedone","ocm","fi2","face1","face0","dir","moveList","parsedmovelist","clear","getboundarygeometry","getmovesets","parsedmove","msg","isTetrahedron","vertexMoves","outerBlockMoves","dep","newr","graybyori","grayCenters","includeCenterOrbits","grayEdges","includeEdgeOrbits","grayCorners","includeCornerOrbits","skipbyori","skipcubie","comment","writegap","os","getOrbitsDef","mvs","movename","ip","__","writemathematica","trim","writeksolve","od","getKPuzzleDefinition","fortwisty","internalDefinition","experimentalPuzzleDescription","getMoveFromBits","moverange","setmoves","movesetorder","moveorbits","oris","slicecmoves","mperm","setnum","inc","oinc","fixedOrientation","lastId","omitSet","excludedSet","excludeOrbits","diffmvsets","setnames","setdefs","mps","addrot","moveset","hasrotation","sawone","nn","cmp","allbits","fill","isrots","movesetgeo","movebits","nameoverride","mna","optimizeOrbits","scrambleAmount","getScramble","getMovesAsPerms","showcanon","orders","commutes","permA","permB","curlev","nextlev","uniq","sti","nst","getsolved","getOrientationRotation","desiredRotation","feature1name","z1","direction1","feature2name","x2","y2","z2","direction2","feature1","feature2","feature1geoname","feature2geoname","gn","r1","getInitial3DRotation","basefacecount","orientationDescription","puzzleOrientation","puzzleOrientations","generate2dmapping","w","threed","twodshrink","extendedges","cosa","sina","ndx","polyn","edges","minx","miny","maxx","maxy","f0","es","esi","min","max","xoff","yoff","geos","bg","edges2","initv","connectat","gfi","thisface","caf0","epi","gf1","gf1i","otherface","hix","hiy","sc2","mappt2d","xoff2","xmul","generatesvg","drawedges","id","pts","color","colormap","facegeo","facenum","fg","svg","cubieori","cubieord","get3d","stickers","darkIgnoredOrbits","stickerColors","ord","fcoords","rotdist","isDup","grips","coordinates","quantumMove","twodmapper","irot","bind","axis","textureMapper","getuv","getGeoNormal","divid","textForTwizzleExplorer","writeSchreierSims","tw","as","PGNotation","orbitNames","lookupMove","pgmv","remapKPuzzleDefinition","kpuzzleDefinition","externalDefinition","internalMoveName","transformationData","prefix","includes","externalPrefix","externalMoveName","parseOptions","argv","argp","option","JSON","parse"],"sourceRoot":""}