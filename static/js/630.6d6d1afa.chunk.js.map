{"version":3,"file":"static/js/630.6d6d1afa.chunk.js","mappings":"iRAGO,SAASA,EACdC,GAIA,MAAO,CAFQA,EAAQC,YAAqB,QAAEC,OAAO,GACtCF,EAAQC,YAAqB,QAAEE,YAAY,GAE5D,CAEA,IAAMC,EAA4C,IAAIC,MAAM,GACzDC,KAAK,GACLC,IAAI,IACI,IAAIF,MAAW,IAGpBG,GAA2C,EAC1C,SAASC,EACdC,GAEA,IAAKF,EAGH,CACE,MAAMG,EAAe,CACnB,GACA,IACA,KACA,KACA,KACA,OACA,QACA,SACAJ,IAAKK,GAAMC,EAAAA,GAAIC,WAAWF,IACtBG,EAAS,IAAIF,EAAAA,GAAI,SACvB,IAAK,MAAMG,KAAQL,EAAO,CACxB,IAAIM,EAAiBP,EAAeQ,oBAAoBF,GACxD,IAAK,IAAIG,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAOC,EAAQC,GAAUtB,EACvBkB,EAAeK,cAMjB,GAJAlB,EAAiCgB,GAAQC,GAAU,IAAIR,EAAAA,GAAI,IACtDG,EAAKO,gBACR,IAAIC,EAAAA,GAAST,EAAQI,KACpBM,SACO,IAANN,EAEF,MAEFF,EAAiBA,EAAeS,SAASX,EAC3C,CACF,CACF,CAEF,OAAOX,CACT,CAEO,SAASuB,EAA4B3B,GAC1C,MAAOoB,EAAQC,GAAUtB,EAA4BC,GAC/C4B,EAAiBnB,EAA8BT,EAAQ6B,SAAST,GACpEC,GAEF,OAAOrB,EAAQ0B,SAASE,EAC1B,CAIO,SAASE,EACd9B,EACA+B,GAQA,OAHIA,EAAQC,0BACVhC,EAAU2B,EAA4B3B,IAEjCA,EAAQiC,YAAYjC,EAAQ6B,QAAQK,iBAC7C,C","sources":["../node_modules/cubing/src/cubing/puzzles/implementations/dynamic/big-cubes/big-puzzle-orientation.ts"],"sourcesContent":["import { Alg, Grouping } from \"../../../../alg\";\nimport type { KPattern, KPuzzle } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientationBigCubeIdx(\n  pattern: KPattern,\n): [number, number] {\n  const idxUFR = pattern.patternData[\"CORNERS\"].pieces[0];\n  const oriUFR = pattern.patternData[\"CORNERS\"].orientation[0];\n  return [idxUFR, oriUFR];\n}\n\nconst puzzleOrientationBigCubeCacheRaw: Alg[][] = new Array(8)\n  .fill(0)\n  .map(() => {\n    return new Array<Alg>(3);\n  });\n\nconst puzzleOrientationBigCubeCacheInitialized = false;\nexport function puzzleOrientationBigCubeCache(\n  bigCubeKPuzzle: KPuzzle, // TODO\n): Alg[][] {\n  if (!puzzleOrientationBigCubeCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\n        \"\",\n        \"y\",\n        \"y2\",\n        \"y'\",\n        \"x2\",\n        \"x2 y\",\n        \"x2 y2\",\n        \"x2 y'\",\n      ].map((s) => Alg.fromString(s));\n      const UFRAlg = new Alg(\"Rv Uv\");\n      for (const uAlg of uAlgs) {\n        let transformation = bigCubeKPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          const [idxUFR, oriUFR] = puzzleOrientationBigCubeIdx(\n            transformation.toKPattern(),\n          );\n          puzzleOrientationBigCubeCacheRaw[idxUFR][oriUFR] = new Alg([\n            ...uAlg.childAlgNodes(),\n            new Grouping(UFRAlg, i), // TODO: make this more efficient\n          ]).invert();\n          if (i === 3) {\n            // Avoid an unnecessary transformation calculation.\n            break;\n          }\n          transformation = transformation.applyAlg(UFRAlg);\n        }\n      }\n    }\n  }\n  return puzzleOrientationBigCubeCacheRaw;\n}\n\nexport function normalizeBigCubeOrientation(pattern: KPattern): KPattern {\n  const [idxUFR, oriUFR] = puzzleOrientationBigCubeIdx(pattern);\n  const orientationAlg = puzzleOrientationBigCubeCache(pattern.kpuzzle)[idxUFR][\n    oriUFR\n  ];\n  return pattern.applyAlg(orientationAlg);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIsBigCubeSolved(\n  pattern: KPattern,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean; // Unused for 4×4×4\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    pattern = normalizeBigCubeOrientation(pattern);\n  }\n  return pattern.isIdentical(pattern.kpuzzle.defaultPattern());\n}\n"],"names":["puzzleOrientationBigCubeIdx","pattern","patternData","pieces","orientation","puzzleOrientationBigCubeCacheRaw","Array","fill","map","puzzleOrientationBigCubeCacheInitialized","puzzleOrientationBigCubeCache","bigCubeKPuzzle","uAlgs","s","Alg","fromString","UFRAlg","uAlg","transformation","algToTransformation","i","idxUFR","oriUFR","toKPattern","childAlgNodes","Grouping","invert","applyAlg","normalizeBigCubeOrientation","orientationAlg","kpuzzle","experimentalIsBigCubeSolved","options","ignorePuzzleOrientation","isIdentical","defaultPattern"],"sourceRoot":""}