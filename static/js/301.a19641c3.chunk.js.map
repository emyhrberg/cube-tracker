{"version":3,"file":"static/js/301.a19641c3.chunk.js","mappings":"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,IAAIA,EAAI,EAAGA,EAAI,EAAGA,IACrBqM,EAAO,GAAGlM,KACR6L,EACEH,EAAgBlL,EAAQ2F,YAAqB,QAAEoB,OAAO1H,IACtDW,EAAQ2F,YAAqB,QAAEC,YAAYvG,KAKjD,OADAqM,EAAOlM,KAAK2L,GACLO,CACT,CASeC,CAAgB3L,GAC7B,OAAOoL,EAAIA,IAAIQ,IAAA,IAAEC,EAAOC,EAAMC,GAAGH,EAAA,OAAMH,EAAKI,GAAOC,GAAMC,KAAMC,KAAK,GACtE,CCpIO,SAASC,EACdC,EACAC,GAEA,MAAMC,EAAgB,IAAIpG,EAAAA,GAASkG,EAAGvN,QAAS,CAC7C0N,MAAOH,EAAGvG,YAAmB,MAC7BkB,QAASqF,EAAGvG,YAAqB,QACjCmB,QAAS,CACPC,OAAQmF,EAAGvG,YAAqB,QAAEoB,OAClCnB,YAAa,IAAIC,MAAM,GAAGC,KAAK,MAEhCzF,+BACGiM,EAAgB,IAAItG,EAAAA,GAASmG,EAAGxN,QAAS,CAC7C0N,MAAOF,EAAGxG,YAAmB,MAC7BkB,QAASsF,EAAGxG,YAAqB,QACjCmB,QAAS,CACPC,OAAQoF,EAAGxG,YAAqB,QAAEoB,OAClCnB,YAAa,IAAIC,MAAM,GAAGC,KAAK,MAEhCzF,+BACH,OAAO+L,EAAcG,YAAYD,EACnC,CCxBO,IAAME,EAAuB,CAClC,CACE,OACA,OACA,QACA,UACA,QACA,IACA,OACA,OACA,OACA,QACA,KACA,SACA,MACA,KACA,KACA,MACA,QACA,OACA,KACA,UACA,GACA,WACA,IACA,SAEF,CACE,QACA,QACA,UACA,QACA,OACA,QACA,WACA,UACA,WACA,KACA,OACA,OACA,QACA,WACA,MACA,GACA,UACA,UACA,SACA,QACA,KACA,OACA,SACA,KAEF,CACE,YACA,aACA,YACA,aACA,UACA,UACA,aACA,aACA,WACA,WACA,WACA,SACA,eACA,gBACA,UACA,YACA,WACA,YACA,SACA,cACA,GACA,kBAEF,CACE,aACA,aACA,aACA,YACA,WACA,YACA,YACA,aACA,UACA,YACA,WACA,WACA,GACA,iBACA,WACA,SACA,SACA,cACA,UACA,WAEF,CACE,WACA,KACA,KACA,SACA,UACA,QACA,QACA,OACA,cACA,IACA,QACA,UACA,WACA,QACA,OACA,UACA,GACA,cAEF,CACE,eACA,aACA,aACA,aACA,UACA,YACA,WACA,YACA,aACA,aACA,WACA,SACA,YACA,UACA,UACA,GACA,eACA,gBACA,iBACA,YACA,UAEF,CACE,UACA,YACA,cACA,SACA,aACA,aACA,YACA,aACA,GACA,gBACA,eACA,YACA,aACA,UACA,gBACA,YAEF,CACE,KACA,YACA,OACA,UACA,GACA,WACA,KACA,SACA,QACA,aACA,IACA,YACA,QACA,WAEF,CACE,WACA,YACA,eACA,cACA,eACA,cACA,GACA,mBACA,iBACA,UACA,cACA,cACA,aACA,eACA,iBACA,WACA,eACA,gBAEF,CACE,SACA,iBACA,YACA,aACA,UACA,YACA,aACA,UACA,GACA,oBACA,aACA,cAEF,CACE,GACA,iBACA,SACA,YACA,YACA,UACA,UACA,UACA,UACA,UAEF,CACE,GACA,4BACA,4BACA,qBACA,qBACA,oBACA,oBACA,kBACA,mBACA,oBACA,oBACA,kBACA,mBACA,kBACA,mBAEF,CACE,KACA,iBACA,KACA,iBACA,IACA,iBACA,GACA,oBAEF,CACE,mBACA,iBACA,iBACA,iBACA,GACA,oBAEF,CACE,qBACA,iCACA,GACA,wBAEF,CACE,sBACA,2BACA,sBACA,0BACA,sBACA,sBACA,GACA,kCACA,kCACA,sBACA,sBACA,6BAEF,CACE,sBACA,sBACA,yBACA,GACA,sCACA,sCACA,sBACA,2BACA,uBAEF,CAAC,GAAI,kCAAmC,oCCtR1C,eAAsBC,IACpB,MAAM9N,QAAgBmF,EAAAA,GAAQ,SAASnF,UACvC,IAAIqB,EAAUrB,EAAQ+N,iBACtB,IAAK,MAAMC,KAASH,EAClBxM,EAAUA,EAAQ4M,SAASnL,EAAAA,GAAIsJ,YAAW8B,EAAAA,EAAAA,IAAaF,KAEzD,OFUK,SAAsBhO,EAAkBqB,GAC7C,GACEiM,EAAyCtN,EAAQ+N,iBAA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","sources":["../node_modules/random-uint-below/dist/esm/index.js","../node_modules/cubing/src/cubing/notation/CountAnimatedLeaves.ts","../node_modules/cubing/src/cubing/notation/CountMoves.ts","../node_modules/cubing/src/cubing/search/inside/solve/tremble.ts","../node_modules/cubing/src/cubing/search/inside/solve/twsearch.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/sgs-side-events/index.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/2x2x2.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/4x4x4/index.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/4x4x4.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/fto/index.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/fto.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/kilominx/index.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/kilominx.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/master_tetraminx/index.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/master_tetraminx.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/megaminx.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/pyraminx.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/sgs-unofficial/index.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/redi_cube.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/skewb.ts","../node_modules/cubing/src/cubing/search/inside/api.ts","../node_modules/cubing/src/cubing/search/inside/index.ts","../node_modules/cubing/src/cubing/search/inside/inside-worker.ts","../node_modules/cubing/src/cubing/search/inside/solve/addOrientationSuffix.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/3x3x3/index.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/3x3x3/convert.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/3x3x3/filter.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/3x3x3/legacy-sgs.ts","../node_modules/cubing/src/cubing/search/inside/solve/puzzles/3x3x3/index.ts","../node_modules/cubing/src/cubing/kpuzzle/combine.ts","../node_modules/cubing/src/cubing/kpuzzle/construct.ts","../node_modules/cubing/src/cubing/kpuzzle/KTransformation.ts","../node_modules/cubing/src/cubing/kpuzzle/calculate.ts","../node_modules/cubing/src/cubing/kpuzzle/KPattern.ts","../node_modules/cubing/src/cubing/kpuzzle/KPuzzle.ts","../node_modules/cubing/src/cubing/vendor/mit/p-lazy/p-lazy.ts","../node_modules/cubing/src/cubing/puzzles/stickerings/mask.ts","../node_modules/cubing/src/cubing/puzzles/stickerings/puzzle-stickerings.ts","../node_modules/cubing/src/cubing/puzzles/stickerings/cube-like-stickerings.ts","../node_modules/cubing/src/cubing/puzzles/async/lazy-cached.ts","../node_modules/cubing/src/cubing/puzzles/async/async-pg3d.ts","../node_modules/cubing/src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts","../node_modules/cubing/src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts","../node_modules/cubing/src/cubing/puzzles/transformAlg.ts","../node_modules/cubing/src/cubing/puzzles/customPGPuzzleLoader.ts","../node_modules/cubing/src/cubing/puzzles/implementations/dynamic/2x2x2/puzzle-orientation.ts","../node_modules/cubing/src/cubing/puzzles/cubing-private/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/cube3x3x3KeyMapping.ts","../node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/puzzle-specific-simplifications.ts","../node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/index.ts","../node_modules/cubing/src/cubing/puzzles/events.ts","../node_modules/cubing/src/cubing/puzzles/implementations/2x2x2/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/4x4x4/cube4x4x4And5x5x5KeyMapping.ts","../node_modules/cubing/src/cubing/puzzles/implementations/4x4x4/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/5x5x5/index.ts","../node_modules/cubing/src/cubing/puzzles/stickerings/fto-stickerings.ts","../node_modules/cubing/src/cubing/puzzles/implementations/fto/ftoKeyMapping.ts","../node_modules/cubing/src/cubing/puzzles/implementations/baby_fto/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/clock/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/fto/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/kilominx/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/loopover/index.ts","../node_modules/cubing/src/cubing/puzzles/stickerings/megaminx-stickerings.ts","../node_modules/cubing/src/cubing/puzzles/implementations/megaminx/megaminxKeyMapping.ts","../node_modules/cubing/src/cubing/puzzles/implementations/megaminx/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/melindas2x2x2x2/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/pyraminx/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/redi-cube/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/square1/index.ts","../node_modules/cubing/src/cubing/puzzles/implementations/tri_quad/index.ts","../node_modules/cubing/src/cubing/puzzles/index.ts","../node_modules/cubing/src/cubing/alg/common.ts","../node_modules/cubing/src/cubing/alg/alg-nodes/containers/Commutator.ts","../node_modules/cubing/src/cubing/alg/alg-nodes/containers/Conjugate.ts","../node_modules/cubing/src/cubing/alg/limits.ts","../node_modules/cubing/src/cubing/alg/AlgBuilder.ts","../node_modules/cubing/src/cubing/alg/alg-nodes/leaves/LineComment.ts","../node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Newline.ts","../node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Pause.ts","../node_modules/cubing/src/cubing/alg/debug.ts","../node_modules/cubing/src/cubing/alg/parseAlg.ts","../node_modules/cubing/src/cubing/alg/warnOnce.ts","../node_modules/cubing/src/cubing/alg/alg-nodes/QuantumWithAmount.ts","../node_modules/cubing/src/cubing/alg/iteration.ts","../node_modules/cubing/src/cubing/alg/alg-nodes/leaves/Move.ts","../node_modules/cubing/src/cubing/alg/alg-nodes/containers/Grouping.ts","../node_modules/cubing/src/cubing/alg/is.ts","../node_modules/cubing/src/cubing/alg/simplify/options.ts","../node_modules/cubing/src/cubing/alg/simplify/append.ts","../node_modules/cubing/src/cubing/alg/traversal.ts","../node_modules/cubing/src/cubing/alg/simplify/simplify.ts","../node_modules/cubing/src/cubing/alg/Alg.ts","../node_modules/cubing/src/cubing/alg/example.ts"],"sourcesContent":["// src/random-uint-below/randomUIntBelow.ts\nvar MAX_JS_PRECISE_INT = 2 ** 53;\nvar UPPER_HALF_MULTIPLIER = 2097152;\nvar LOWER_HALF_RIGHT_SHIFT_BITS = 11;\nvar arr = new Uint32Array(2);\nfunction random53BitNumber() {\n  globalThis.crypto.getRandomValues(arr);\n  const upper = arr[0];\n  const lower = arr[1];\n  return Math.floor(upper * UPPER_HALF_MULTIPLIER) + (lower >> LOWER_HALF_RIGHT_SHIFT_BITS);\n}\nfunction validateMax(max) {\n  if (typeof max !== \"number\" || max < 0 || Math.floor(max) !== max) {\n    throw new Error(\n      \"randomUIntBelow() not called with a positive integer value.\"\n    );\n  }\n  if (max > MAX_JS_PRECISE_INT) {\n    throw new Error(\n      `Called randomUIntBelow() with max === ${max}, which is larger than JavaScript can handle with integer precision.`\n    );\n  }\n}\nfunction randomUIntBelow(max) {\n  validateMax(max);\n  var val;\n  var block;\n  var blockMax;\n  while (true) {\n    val = random53BitNumber();\n    block = Math.floor(val / max);\n    blockMax = block * max;\n    if (blockMax <= MAX_JS_PRECISE_INT - max) {\n      return val - blockMax;\n    }\n  }\n}\n\n// src/random-uint-below/array-operations.ts\nfunction randomChoice(arr2) {\n  return arr2[randomUIntBelow(arr2.length)];\n}\nasync function randomPermuteInPlace(arr2) {\n  for (let i = 1; i < arr2.length; i++) {\n    const j = randomUIntBelow(i);\n    [arr2[i], arr2[j]] = [arr2[j], arr2[i]];\n  }\n}\nexport {\n  randomChoice,\n  randomPermuteInPlace,\n  randomUIntBelow\n};\n","import {\n  type Alg,\n  type Commutator,\n  type Conjugate,\n  functionFromTraversal,\n  type Grouping,\n  type LineComment,\n  type Move,\n  type Newline,\n  type Pause,\n  TraversalUp,\n} from \"../alg\";\n\n// TODO: Include Pause, include amounts\nclass CountAnimatedLeaves extends TraversalUp<number, number> {\n  public traverseAlg(alg: Alg): number {\n    let total = 0;\n    for (const part of alg.childAlgNodes()) {\n      total += this.traverseAlgNode(part);\n    }\n    return total;\n  }\n\n  public traverseGrouping(grouping: Grouping): number {\n    return this.traverseAlg(grouping.alg) * Math.abs(grouping.amount);\n  }\n\n  public traverseMove(_move: Move): number {\n    return 1;\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);\n  }\n\n  public traversePause(_pause: Pause): number {\n    return 1;\n  }\n\n  public traverseNewline(_newline: Newline): number {\n    return 0;\n  }\n\n  public traverseLineComment(_comment: LineComment): number {\n    return 0;\n  }\n}\n\nexport const countAnimatedLeaves = functionFromTraversal(CountAnimatedLeaves);\n","// TODO: move this file somewhere permanent.\nimport {\n  type Alg,\n  type Commutator,\n  type Conjugate,\n  functionFromTraversal,\n  type Grouping,\n  type LineComment,\n  type Move,\n  type Newline,\n  type Pause,\n  TraversalUp,\n} from \"../alg\";\nimport type { PuzzleLoader } from \"../puzzles\";\nimport { CommonMetric } from \"./commonMetrics\";\nimport { costFactorsByMetric, countMove3x3x3 } from \"./cube3x3x3Metrics\";\n\n/*\n *   For movecount, that understands puzzle rotations.  This code\n *   should be moved to the alg class, probably.\n */\nclass CountMoves extends TraversalUp<number> {\n  constructor(private metric: (move: Move) => number) {\n    super();\n  }\n\n  public traverseAlg(alg: Alg): number {\n    let r = 0;\n    for (const algNode of alg.childAlgNodes()) {\n      r += this.traverseAlgNode(algNode);\n    }\n    return r;\n  }\n\n  public traverseGrouping(grouping: Grouping): number {\n    const alg: Alg = grouping.alg;\n    return this.traverseAlg(alg) * Math.abs(grouping.amount);\n  }\n\n  public traverseMove(move: Move): number {\n    return this.metric(move);\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(_pause: Pause): number {\n    return 0;\n  }\n\n  public traverseNewline(_newLine: Newline): number {\n    return 0;\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseLineComment(_comment: LineComment): number {\n    return 0;\n  }\n}\n\n// TODO\nclass CountLeavesInExpansionForSimultaneousMoveIndexer extends TraversalUp<number> {\n  public traverseAlg(alg: Alg): number {\n    let r = 0;\n    for (const algNode of alg.childAlgNodes()) {\n      r += this.traverseAlgNode(algNode);\n    }\n    return r;\n  }\n\n  public traverseGrouping(grouping: Grouping): number {\n    const alg: Alg = grouping.alg;\n    return this.traverseAlg(alg) * Math.abs(grouping.amount);\n  }\n\n  public traverseMove(_move: Move): number {\n    return 1;\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(_pause: Pause): number {\n    return 1;\n  }\n\n  public traverseNewline(_newLine: Newline): number {\n    return 1;\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseLineComment(_comment: LineComment): number {\n    return 1;\n  }\n}\n\nfunction isCharUppercase(c: string): boolean {\n  return \"A\" <= c && c <= \"Z\";\n}\n\n// TODO: Implement a puzzle-specific way to calculate this.\nfunction baseMetric(move: Move): number {\n  const fam = move.family;\n  if (\n    (isCharUppercase(fam[0]) && fam[fam.length - 1] === \"v\") ||\n    fam === \"x\" ||\n    fam === \"y\" ||\n    fam === \"z\" ||\n    fam === \"T\"\n  ) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction etmMetric(_move: Move): number {\n  return 1;\n}\n\n// TODO: Implement a puzzle-specific way to calculate this.\nfunction rangeBlockTurnMetric(move: Move): number {\n  const fam = move.family;\n  if (\n    (isCharUppercase(fam[0]) && fam[fam.length - 1] === \"v\") ||\n    fam === \"x\" ||\n    fam === \"y\" ||\n    fam === \"z\" ||\n    fam === \"T\"\n  ) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\n// TODO: Implement a puzzle-specific way to calculate this.\nfunction quantumMetric(move: Move): number {\n  return Math.abs(move.amount) * rangeBlockTurnMetric(move);\n}\n\nexport const countMoves = functionFromTraversal(CountMoves, [baseMetric]);\nexport const countMovesETM = functionFromTraversal(CountMoves, [etmMetric]);\nexport const countRangeBlockQuantumMovesPG = functionFromTraversal(CountMoves, [\n  quantumMetric,\n]);\nexport const countRangeBlockMovesPG = functionFromTraversal(CountMoves, [\n  rangeBlockTurnMetric,\n]);\n\nexport const countLeavesInExpansionForSimultaneousMoveIndexer =\n  functionFromTraversal(CountLeavesInExpansionForSimultaneousMoveIndexer, []);\n\n/**\n * Only implemented so far:\n *\n * - 3x3x3: OBTM, RBTM, ETM\n */\nexport function countMetricMoves(\n  puzzleLoader: PuzzleLoader,\n  metric: CommonMetric,\n  alg: Alg,\n): number {\n  if (puzzleLoader.id === \"3x3x3\") {\n    if (metric in costFactorsByMetric) {\n      return functionFromTraversal(CountMoves, [\n        (move: Move) => countMove3x3x3(metric, move),\n      ])(alg);\n    }\n  } else {\n    switch (metric) {\n      case CommonMetric.ExecutionTurnMetric:\n        return countMovesETM(alg);\n      case CommonMetric.RangeBlockTurnMetric: {\n        if (puzzleLoader.pg) {\n          return countRangeBlockMovesPG(alg);\n        }\n        break;\n      }\n      case CommonMetric.RangeBlockQuantumTurnMetric: {\n        if (puzzleLoader.pg) {\n          return countRangeBlockQuantumMovesPG(alg);\n        }\n        break;\n      }\n    }\n  }\n  throw new Error(\"Unsupported puzzle or metric.\");\n}\n","import { randomChoice } from \"random-uint-below\";\nimport { Alg, AlgBuilder, Move, type QuantumMove } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\nimport type { KPattern } from \"../../../kpuzzle/KPattern\";\nimport { experimentalCountMoves } from \"../../../notation\";\nimport type { SGSCachedData } from \"./parseSGS\";\n\nconst DEFAULT_STAGE1_DEPTH_LIMIT = 2; // Moderately performant default.\n\nconst DOUBLECHECK_PLACED_PIECES = true;\nconst DEBUG = false;\n\n// TODO: Take moves instead of move names?\nfunction calculateMoves(\n  kpuzzle: KPuzzle,\n  moveNames: string[],\n): {\n  move: Move;\n  transformation: KTransformation;\n}[] {\n  const searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[] = [];\n  // const identity = identityTransformation(def); // TODO\n  // TODO: Make it easy to filter moves.\n  for (const moveName of moveNames) {\n    const rootMove = new Move(moveName);\n    if (rootMove.amount !== 1) {\n      throw new Error(\n        \"SGS cannot handle def moves with an amount other than 1 yet.\",\n      );\n    }\n    let transformation = kpuzzle.identityTransformation();\n    for (let i = 1; ; i++) {\n      transformation = transformation.applyMove(rootMove);\n      if (transformation.isIdentityTransformation()) {\n        break;\n      }\n      searchMoves.push({\n        move: rootMove.modified({ amount: i }),\n        transformation,\n      });\n    }\n  }\n  return searchMoves;\n}\n\n// function badRandomMoves(moves: string[], ksp: KSolvePuzzle): KSolvePuzzleState {\n//   // var sum = 0;\n//   var scramble = \"\";\n//   for (var i = 0; i < 1000; i++) {\n//     scramble = scramble + \" \" + moves[Math.floor(moves.length * Math.random())];\n//   }\n//   // var sol = \"\";\n//   const indexer = new TreeAlgIndexer(ksp, Alg.fromString(scramble));\n//   return indexer.transformAtIndex(indexer.numMoves()) as any; // TODO\n// }\n\nexport class TrembleSolver {\n  private searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[];\n\n  constructor(\n    private kpuzzle: KPuzzle,\n    private sgs: SGSCachedData,\n    trembleMoveNames?: string[],\n  ) {\n    this.searchMoves = calculateMoves(\n      this.kpuzzle,\n      trembleMoveNames ?? Object.keys(this.kpuzzle.definition.moves),\n    );\n  }\n\n  // public badRandomMoves(): KSolvePuzzleState {\n  //   return badRandomMoves(this.moves, this.ksp);\n  // }\n\n  public async solve(\n    pattern: KPattern,\n    stage1DepthLimit: number = DEFAULT_STAGE1_DEPTH_LIMIT,\n    quantumMoveOrder?: (quantumMove: QuantumMove) => number,\n  ): Promise<Alg> {\n    const transformation = pattern.experimentalToTransformation();\n    if (!transformation) {\n      throw new Error(\n        \"distinguishable pieces are not supported in tremble solver yt\",\n      );\n    }\n    let bestAlg: Alg | null = null;\n    let bestLen = 1000000;\n    const recur = (\n      recursiveTransformation: KTransformation, // TODO: Support KStatq1\n      togo: number,\n      sofar: Alg,\n    ) => {\n      // console.log(\"recur\");\n      if (togo === 0) {\n        const sgsAlg = this.sgsPhaseSolve(recursiveTransformation, bestLen);\n        if (!sgsAlg) {\n          return;\n        }\n        // console.log(\"sgs done!\", sofar.toString(), \"|\", sgsAlg.toString());\n        const newAlg = sofar.concat(sgsAlg).experimentalSimplify({\n          cancel: {\n            directional: \"any-direction\",\n            puzzleSpecificModWrap: \"canonical-centered\",\n          },\n          puzzleSpecificSimplifyOptions: { quantumMoveOrder },\n        });\n\n        const len = experimentalCountMoves(newAlg);\n        if (bestAlg === null || len < bestLen) {\n          if (DEBUG) {\n            console.log(`New best (${len} moves): ${newAlg.toString()}`);\n            console.log(`Tremble moves are: ${sofar.toString()}`);\n          }\n          bestAlg = newAlg;\n          bestLen = len;\n        }\n        return;\n      }\n      for (const searchMove of this.searchMoves) {\n        recur(\n          recursiveTransformation.applyTransformation(\n            searchMove.transformation,\n          ),\n          togo - 1,\n          sofar.concat([searchMove.move]),\n        );\n      }\n    };\n    for (let d = 0; d <= stage1DepthLimit; d++) {\n      recur(transformation, d, new Alg());\n    }\n    if (bestAlg === null) {\n      throw new Error(\"SGS search failed.\");\n    }\n    return bestAlg;\n  }\n\n  private sgsPhaseSolve(\n    initialTransformation: KTransformation, // TODO: Handle KPattern\n    bestLenSofar: number,\n  ): Alg | null {\n    // const pieceNames = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\n    // function loggo(s: string) {\n    //   // console.warn(s);\n    //   // document.body.appendChild(document.createElement(\"div\")).textContent = s;\n    // }\n\n    // console.log(\"sgsPhaseSolve\");\n    const algBuilder = new AlgBuilder();\n    let transformation = initialTransformation;\n    for (const step of this.sgs.ordering) {\n      const cubieSeq = step.pieceOrdering;\n      let key = \"\";\n      const inverseTransformation = transformation.invert();\n      for (let i = 0; i < cubieSeq.length; i++) {\n        const loc = cubieSeq[i];\n        const orbitName = loc.orbitName;\n        const idx = loc.permutationIdx;\n        key += ` ${inverseTransformation.transformationData[orbitName].permutation[idx]} ${inverseTransformation.transformationData[orbitName].orientationDelta[idx]}`;\n      }\n      // console.log(key, step.lookup);\n      const info = step.lookup[key];\n      if (!info) {\n        throw new Error(\"Missing algorithm in sgs or esgs?\");\n      }\n      algBuilder.experimentalPushAlg(info.alg);\n      if (algBuilder.experimentalNumAlgNodes() >= bestLenSofar) {\n        return null;\n      }\n      transformation = transformation.applyTransformation(info.transformation);\n      if (DOUBLECHECK_PLACED_PIECES) {\n        for (let i = 0; i < cubieSeq.length; i++) {\n          const location = cubieSeq[i];\n          const orbitName = location.orbitName;\n          const idx = location.permutationIdx;\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientationDelta[\n              idx\n            ] !== 0\n          ) {\n            throw new Error(\"bad SGS :-(\");\n          }\n        }\n      }\n    }\n    return algBuilder.toAlg();\n  }\n}\n\nexport function randomPatternFromSGS(\n  kpuzzle: KPuzzle,\n  sgs: SGSCachedData,\n): KPattern {\n  let transformation = kpuzzle.identityTransformation();\n  for (const step of sgs.ordering) {\n    const sgsAction = randomChoice(Object.values(step.lookup));\n    transformation = transformation.applyTransformation(\n      sgsAction.transformation,\n    );\n  }\n  return transformation.toKPattern();\n}\n","import type { Alg } from \"../../../alg\";\nimport type {\n  KPattern,\n  KPatternData,\n  KPuzzleDefinition,\n} from \"../../../kpuzzle\";\nimport { from } from \"../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const twsearchPromise: Promise<\n  typeof import(\"../../../vendor/mpl/twsearch\")\n> = from(async () => import(\"../../../vendor/mpl/twsearch\"));\n\nexport interface TwsearchOptions {\n  // TODO: start prune depth?\n  generatorMoves?: string[];\n  targetPattern?: KPatternData;\n  minDepth?: number;\n  maxDepth?: number;\n}\n\nexport async function wasmTwsearch(\n  def: KPuzzleDefinition,\n  pattern: KPattern,\n  options?: TwsearchOptions,\n): Promise<Alg> {\n  const { wasmTwsearch } = await twsearchPromise;\n  return wasmTwsearch(def, pattern, options);\n}\n\nexport async function wasmRandomScrambleForEvent(\n  eventID: string,\n): Promise<Alg> {\n  const { wasmRandomScrambleForEvent } = await twsearchPromise;\n  return wasmRandomScrambleForEvent(eventID);\n}\n","import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicSideEvents = from<\n  typeof import(\"./search-dynamic-sgs-side-events\")\n>(() => import(\"./search-dynamic-sgs-side-events\"));\n","import { randomPermuteInPlace, randomUIntBelow } from \"random-uint-below\";\nimport type { Alg } from \"../../../../alg\";\nimport type { KPuzzle } from \"../../../../kpuzzle\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { cube2x2x2, puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { wasmTwsearch } from \"../twsearch\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgsCachedData: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedData222();\n      return new TrembleSolver(\n        await puzzles[\"2x2x2\"].kpuzzle(),\n        sgsCachedData,\n        \"URFLBD\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitialize222(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: fix def consistency.\nexport async function solve222(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  return wasmTwsearch((await cube2x2x2.kpuzzle()).definition, pattern, {\n    generatorMoves: \"UFLR\".split(\"\"),\n  });\n}\n\n// TODO: factor out and test.\nfunction mutatingRandomizeOrbit(\n  kpuzzle: KPuzzle,\n  orbitName: string,\n  pattern: KPattern,\n  options?: { orientationSum?: number },\n): void {\n  randomPermuteInPlace(pattern.patternData[orbitName].pieces);\n\n  const orbitDefinition = kpuzzle.lookupOrbitDefinition(orbitName);\n  const ori = pattern.patternData[orbitName].orientation;\n\n  let sum = 0;\n  for (let i = 0; i < orbitDefinition.numPieces; i++) {\n    const o = randomUIntBelow(orbitDefinition.numOrientations);\n    ori[i] = o;\n    sum += o;\n  }\n\n  // console.log(\"aaaa\", options && \"orientationSum\" in options);\n  if (options && \"orientationSum\" in options) {\n    // console.log(\"sfdsf\", options!.orientationSum),\n    ori[0] =\n      (((ori[0] + options.orientationSum! - sum) %\n        orbitDefinition.numOrientations) +\n        orbitDefinition.numOrientations) %\n      orbitDefinition.numOrientations;\n  }\n}\n\n// TODO: Use SGS?\nexport async function random222Pattern(): Promise<KPattern> {\n  const kpuzzle = await puzzles[\"2x2x2\"].kpuzzle();\n  const patternCopy: KPattern = new KPattern(\n    kpuzzle,\n    structuredClone(kpuzzle.defaultPattern().patternData),\n  ); // TODO\n  mutatingRandomizeOrbit(kpuzzle, \"CORNERS\", patternCopy, {\n    orientationSum: 0,\n  });\n  return patternCopy;\n}\n","import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamic4x4x4Solver = from<\n  typeof import(\"./search-dynamic-solve-4x4x4\")\n>(() => import(\"./search-dynamic-solve-4x4x4\"));\n","import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { dynamic4x4x4Solver } from \"./dynamic/4x4x4\";\n\nconst randomSuffixes = [\n  [null, \"x\", \"x2\", \"x'\", \"z\", \"z'\"],\n  [null, \"y\", \"y2\", \"y'\"],\n];\n\nexport async function initialize444(): Promise<void> {\n  return (await dynamic4x4x4Solver).initialize();\n}\n\nexport async function random444Scramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamic4x4x4Solver).random444Scramble();\n}\n\nexport async function random444OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random444Scramble(), randomSuffixes);\n}\n","import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicFTO = from<typeof import(\"./search-dynamic-solve-fto\")>(\n  () => import(\"./search-dynamic-solve-fto\"),\n);\n","import { Alg } from \"../../../../alg\";\nimport type { KPattern } from \"../../../../kpuzzle/KPattern\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { from } from \"../../../../vendor/mit/p-lazy/p-lazy\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { dynamicFTO } from \"./dynamic/fto\";\n\nconst dynamic = from<\n  typeof import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\")\n>(() => import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\"));\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (await dynamic).sgsDataFTO();\n      return new TrembleSolver(await puzzles[\"fto\"].kpuzzle(), json, [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"L\",\n        \"D\",\n        \"B\",\n        \"BR\",\n        \"BL\",\n      ]);\n    })())\n  );\n}\n\nexport async function preInitializeFTO(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveFTO(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    pattern,\n    TREMBLE_DEPTH,\n    () => 3, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomFTOScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(await (await dynamicFTO).getRandomFTOScramble());\n}\n","import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicKilominxSolver = from<\n  typeof import(\"./search-dynamic-solve-kilominx\")\n>(() => import(\"./search-dynamic-solve-kilominx\"));\n","import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicKilominxSolver } from \"./dynamic/kilominx\";\n\nexport async function randomKilominxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamicKilominxSolver).getRandomKilominxScramble();\n}\n","import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicMasterTetraminxSolver = from<\n  typeof import(\"./search-dynamic-solve-master_tetraminx\")\n>(() => import(\"./search-dynamic-solve-master_tetraminx\"));\n","import { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicMasterTetraminxSolver } from \"./dynamic/master_tetraminx\";\n\nexport async function randomMasterTetraminxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(\n    await (\n      await dynamicMasterTetraminxSolver\n    ).randomMasterTetraminxScrambleString(),\n  );\n}\n","import type { Alg } from \"../../../../alg\";\nimport type { KPatternData } from \"../../../../kpuzzle\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 2;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedSGSDataMegaminx();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n        json,\n        [\"U\", \"R\", \"F\", \"L\", \"BR\", \"BL\", \"FR\", \"FL\", \"DR\", \"DL\", \"B\", \"D\"],\n      );\n    })())\n  );\n}\n\nexport async function preInitializeMegaminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveMegaminx(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const patternDataWithoutMO: KPatternData = structuredClone(\n    pattern.patternData,\n  );\n  patternDataWithoutMO[\"CENTERS\"].orientation = new Array(12).fill(0);\n  const patternWithoutMO = new KPattern(\n    await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n    patternDataWithoutMO,\n  );\n  const alg = await trembleSolver.solve(\n    patternWithoutMO,\n    TREMBLE_DEPTH,\n    () => 5, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n","import type { Alg } from \"../../../../alg\";\nimport type { KPattern } from \"../../../../kpuzzle/KPattern\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomPatternFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataPyraminx();\n      return new TrembleSolver(\n        await puzzles[\"pyraminx\"].kpuzzle(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializePyraminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solvePyraminx(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(pattern, TREMBLE_DEPTH, () => 3); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\nexport async function randomPyraminxPatternFixedOrientation(): Promise<KPattern> {\n  mustBeInsideWorker();\n  // Note: this sets all center orientations to 0.\n  return randomPatternFromSGS(\n    await puzzles[\"pyraminx\"].kpuzzle(),\n    await (await searchDynamicSideEvents).sgsDataPyraminxFixedOrientation(),\n  );\n}\n","import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicUnofficial = from<\n  typeof import(\"./search-dynamic-sgs-unofficial\")\n>(() => import(\"./search-dynamic-sgs-unofficial\"));\n","import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { searchDynamicUnofficial } from \"./dynamic/sgs-unofficial\";\n\nexport async function randomRediCubeScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await searchDynamicUnofficial).getRandomRediCubeScramble();\n}\n","import type { Alg, QuantumMove } from \"../../../../alg\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataSkewb();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializeSkewb(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nasync function resetCenterOrientation(pattern: KPattern): Promise<KPattern> {\n  return new KPattern(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    {\n      CORNERS: pattern.patternData[\"CORNERS\"],\n      CENTERS: {\n        pieces: pattern.patternData[\"CENTERS\"].pieces,\n        orientation: new Array(6).fill(0),\n      },\n    },\n  );\n}\n\n// TODO: fix def consistency.\nexport async function solveSkewb(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    await resetCenterOrientation(pattern),\n    TREMBLE_DEPTH,\n    (quantumMove: QuantumMove) => (quantumMove.family === \"y\" ? 4 : 3), // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n","import type { Alg } from \"../../alg\";\nimport {\n  KPattern,\n  type KPatternData,\n  KPuzzle,\n  type KPuzzleDefinition,\n} from \"../../kpuzzle\";\nimport { puzzles } from \"../../puzzles\";\nimport { setIsInsideWorker } from \"./inside-worker\";\nimport { preInitialize222, solve222 } from \"./solve/puzzles/2x2x2\";\nimport {\n  initialize333,\n  random333OrientedScramble,\n  random333Scramble,\n  solve333,\n} from \"./solve/puzzles/3x3x3\";\nimport {\n  initialize444,\n  random444OrientedScramble,\n  random444Scramble,\n} from \"./solve/puzzles/4x4x4\";\nimport { randomFTOScramble } from \"./solve/puzzles/fto\";\nimport { randomKilominxScramble } from \"./solve/puzzles/kilominx\";\nimport { randomMasterTetraminxScramble } from \"./solve/puzzles/master_tetraminx\";\nimport { solveMegaminx } from \"./solve/puzzles/megaminx\";\nimport { solvePyraminx } from \"./solve/puzzles/pyraminx\";\nimport { randomRediCubeScramble } from \"./solve/puzzles/redi_cube\";\nimport { solveSkewb } from \"./solve/puzzles/skewb\";\nimport {\n  type TwsearchOptions,\n  wasmRandomScrambleForEvent,\n  wasmTwsearch,\n} from \"./solve/twsearch\";\n\nconst IDLE_PREFETCH_TIMEOUT_MS = 1000;\n\nsetIsInsideWorker(true);\n\nlet DEBUG_MEASURE_PERF = true;\nexport function setDebugMeasurePerf(newDebugMeasurePerf: boolean): void {\n  DEBUG_MEASURE_PERF = newDebugMeasurePerf;\n}\n\nfunction now() {\n  return (typeof performance === \"undefined\" ? Date : performance).now();\n}\n\nasync function measurePerf<T>(\n  name: string,\n  f: () => T | Promise<T>,\n  options?: { isPrefetch?: boolean },\n): Promise<T> {\n  if (!DEBUG_MEASURE_PERF) {\n    return f();\n  }\n\n  const start = now();\n  const result = f();\n  if ((result as any)?.then) {\n    await result;\n  }\n  const end = now();\n  console.warn(\n    `${name}${options?.isPrefetch ? \" (prefetched)\" : \"\"}: ${Math.round(\n      end - start,\n    )}ms`,\n  );\n  return result;\n}\n\nconst prefetchPromises: Map<string, Promise<Alg>> = new Map();\n// This would just be a number, except `node` is extremely silly and returns an object instead.\n// https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\nlet queuedPrefetchTimeoutID: ReturnType<typeof setTimeout> | null = null;\n\n// This is used to ensure only one scramble is running (and measured) at a time, as interleaving scrambles within a single worker isn't supported (yet).\n// Scrambles may perform async work (e.g. loading code), and this guard this prevents unintended interleaving.\nlet scrambleActivityLock: Promise<Alg>;\n\nasync function randomScrambleForEvent(\n  eventID: string,\n  options?: { isPrefetch?: boolean },\n): Promise<Alg> {\n  return (scrambleActivityLock = (async () => {\n    await scrambleActivityLock;\n    function wasm(): Promise<Alg> {\n      return measurePerf(\n        `wasmRandomScrambleForEvent(${JSON.stringify(eventID)})`,\n        () => wasmRandomScrambleForEvent(eventID),\n        {\n          isPrefetch: options?.isPrefetch,\n        },\n      );\n    }\n\n    switch (eventID) {\n      // case \"333\":\n      case \"222\":\n        return (await wasm()).experimentalSimplify({\n          puzzleSpecificSimplifyOptions: {\n            quantumMoveOrder: () => 4,\n          },\n        });\n      // case \"444\":\n      case \"555\":\n      case \"666\":\n      case \"777\":\n      // case \"333bf\":\n      case \"333fm\":\n      // case \"333oh\":\n      // case \"clock\":\n      case \"minx\":\n      case \"pyram\":\n      case \"skewb\":\n      case \"sq1\":\n      // case \"444bf\":\n      case \"555bf\":\n      // case \"333mbf\":\n      // case \"fto\":\n      // case \"master_tetraminx\":\n      // case \"kilominx\":\n      // case \"redi_cube\":\n      case \"baby_fto\":\n        return wasm();\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"random333Scramble\", random333Scramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      case \"333bf\":\n      case \"333mbf\":\n        return measurePerf(\n          \"random333OrientedScramble\",\n          random333OrientedScramble,\n        );\n      case \"444\":\n        return measurePerf(\"random444Scramble\", random444Scramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      case \"444bf\":\n        return measurePerf(\n          \"random444OrientedScramble\",\n          random444OrientedScramble,\n        );\n      case \"fto\":\n        return measurePerf(\"randomFTOScramble\", randomFTOScramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      case \"master_tetraminx\":\n        return measurePerf(\n          \"randomMasterTetraminxScramble\",\n          randomMasterTetraminxScramble,\n        );\n      case \"kilominx\":\n        return measurePerf(\"randomKilominxScramble\", randomKilominxScramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      case \"redi_cube\":\n        return measurePerf(\"randomRediCubeScramble\", randomRediCubeScramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  })());\n}\n\nexport enum PrefetchLevel {\n  Auto = \"auto\",\n  None = \"none\",\n  Immediate = \"immediate\",\n}\n\nlet currentPrefetchLevel = PrefetchLevel.Auto;\n\nexport const insideAPI = {\n  initialize: async (eventID: string) => {\n    switch (eventID) {\n      case \"222\":\n        return measurePerf(\"preInitialize222\", preInitialize222);\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"initialize333\", initialize333);\n      case \"444\":\n        return measurePerf(\"initialize444\", initialize444);\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  },\n\n  setScramblePrefetchLevel(prefetchLevel: `${PrefetchLevel}`) {\n    currentPrefetchLevel = prefetchLevel as PrefetchLevel;\n  },\n\n  randomScrambleForEvent: async (eventID: string): Promise<Alg> => {\n    let promise = prefetchPromises.get(eventID);\n    if (promise) {\n      prefetchPromises.delete(eventID);\n    } else {\n      promise = randomScrambleForEvent(eventID);\n    }\n    if (currentPrefetchLevel !== PrefetchLevel.None) {\n      promise.then(() => {\n        // `queuedPrefetch` could be 0, but:\n        // > Passing an invalid ID to clearTimeout() silently does nothing; no exception is thrown.\n        // https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout#notes\n        if (queuedPrefetchTimeoutID) {\n          clearTimeout(queuedPrefetchTimeoutID);\n        }\n        queuedPrefetchTimeoutID = setTimeout(\n          () => {\n            prefetchPromises.set(\n              eventID,\n              randomScrambleForEvent(eventID, {\n                isPrefetch: true,\n              }),\n            );\n          },\n          currentPrefetchLevel === PrefetchLevel.Immediate\n            ? 0\n            : IDLE_PREFETCH_TIMEOUT_MS,\n        );\n      });\n    }\n    return promise;\n  },\n\n  randomScrambleStringForEvent: async (eventID: string): Promise<string> => {\n    return (await insideAPI.randomScrambleForEvent(eventID)).toString();\n  },\n\n  solve333ToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"3x3x3\"].kpuzzle(), patternData);\n    return (await solve333(pattern)).toString();\n  },\n\n  solve222ToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"2x2x2\"].kpuzzle(), patternData);\n    return (await solve222(pattern)).toString();\n  },\n\n  solveSkewbToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"skewb\"].kpuzzle(), patternData);\n    return (await solveSkewb(pattern)).toString();\n  },\n\n  solvePyraminxToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(\n      await puzzles[\"pyraminx\"].kpuzzle(),\n      patternData,\n    );\n    return (await solvePyraminx(pattern)).toString();\n  },\n\n  solveMegaminxToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(\n      await puzzles[\"megaminx\"].kpuzzle(),\n      patternData,\n    );\n    return (await solveMegaminx(pattern)).toString();\n  },\n\n  setDebugMeasurePerf: async (measure: boolean): Promise<void> => {\n    setDebugMeasurePerf(measure);\n  },\n\n  solveTwsearchToString: async (\n    def: KPuzzleDefinition,\n    patternData: KPatternData,\n    options?: TwsearchOptions,\n  ): Promise<string> => {\n    const kpuzzle = new KPuzzle(def);\n    const pattern = new KPattern(kpuzzle, patternData);\n    return (await wasmTwsearch(def, pattern, options)).toString();\n  },\n};\n\nexport type WorkerInsideAPI = typeof insideAPI;\n","import { expose } from \"../../vendor/apache/comlink-everywhere/inside\";\nimport { insideAPI } from \"./api\";\n\nexpose(insideAPI);\n","let isInsideWorker = false;\n\nexport function setIsInsideWorker(inside: boolean) {\n  isInsideWorker = inside;\n}\n\nexport function mustBeInsideWorker(): void {\n  if (!isInsideWorker) {\n    throw new Error(\n      \"Must be called from inside a worker, to avoid impact on page performance. Try importing from the top level of `cubing/solve`?\",\n    );\n  }\n}\n","import { randomChoice } from \"random-uint-below\";\nimport { type Alg, AlgBuilder, Move } from \"../../../alg\";\n\nexport function addOrientationSuffix(\n  alg: Alg,\n  suffixSpec: (null | string)[][],\n): Alg {\n  const algBuilder = new AlgBuilder();\n  algBuilder.experimentalPushAlg(alg);\n  for (const suffix of suffixSpec) {\n    const choice = randomChoice(suffix);\n    if (choice !== null) {\n      algBuilder.push(Move.fromString(choice));\n    }\n  }\n  return algBuilder.toAlg();\n}\n","import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamic3x3x3min2phase = from<\n  typeof import(\"./search-dynamic-solve-3x3x3\")\n>(() => import(\"./search-dynamic-solve-3x3x3\"));\n","/*\n\nFace order:\n\n U\nLFRB\n D\n\n         | 0| 1| 2|\n         | 3| 4| 5|\n         | 6| 7| 8|\n| 9|10|11|18|19|20|27|28|29|36|37|38|\n|12|13|14|21|22|23|30|31|32|39|40|41|\n|15|16|17|24|25|26|33|34|35|42|43|44|\n         |45|46|47|\n         |48|49|50|\n         |51|52|53|\n*/\n\nimport type { KPattern } from \"../../../../../kpuzzle/KPattern\";\n\nconst reidEdgeOrder = \"UF UR UB UL DF DR DB DL FR FL BR BL\".split(\" \");\nconst reidCornerOrder = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\nconst centerOrder = \"U L F R B D\".split(\" \");\n\n// const stickers = [reidEdgeOrder, reidCornerOrder, centerOrder];\n\n// /*\n//                |1 20|0 20|1 10|\n//                |0 30|2 00|0 10|\n//                |1 30|0 00|1 00|\n// |1 22|0 31|1 31|1 32|0 01|1 01|1 02|0 11|1 11|1 12|0 21|1 21|\n// |0111|2 10|0 91|0 90|2 20|0 80|0 81|2 30|0101|0100|2 40|0110|\n// |1 61|0 71|1 52|1 51|0 41|1 42|1 41|0 51|1 72|1 71|0 61|1 62|\n//                |1 50|0 40|1 40|\n//                |0 70|2 50|0 50|\n//                |1 60|0 60|1 70|\n// */\n\nconst map: [number, number, number][] = [\n  [1, 2, 0],\n  [0, 2, 0],\n  [1, 1, 0],\n  [0, 3, 0],\n  [2, 0, 0],\n  [0, 1, 0],\n  [1, 3, 0],\n  [0, 0, 0],\n  [1, 0, 0],\n  [1, 0, 2],\n  [0, 1, 1],\n  [1, 1, 1],\n  [0, 8, 1],\n  [2, 3, 0],\n  [0, 10, 1],\n  [1, 4, 1],\n  [0, 5, 1],\n  [1, 7, 2],\n  [1, 3, 2],\n  [0, 0, 1],\n  [1, 0, 1],\n  [0, 9, 0],\n  [2, 2, 0],\n  [0, 8, 0],\n  [1, 5, 1],\n  [0, 4, 1],\n  [1, 4, 2],\n  [1, 5, 0],\n  [0, 4, 0],\n  [1, 4, 0],\n  [0, 7, 0],\n  [2, 5, 0],\n  [0, 5, 0],\n  [1, 6, 0],\n  [0, 6, 0],\n  [1, 7, 0],\n  [1, 2, 2],\n  [0, 3, 1],\n  [1, 3, 1],\n  [0, 11, 1],\n  [2, 1, 0],\n  [0, 9, 1],\n  [1, 6, 1],\n  [0, 7, 1],\n  [1, 5, 2],\n  [1, 1, 2],\n  [0, 2, 1],\n  [1, 2, 1],\n  [0, 10, 0],\n  [2, 4, 0],\n  [0, 11, 0],\n  [1, 7, 1],\n  [0, 6, 1],\n  [1, 6, 2],\n];\n\nfunction rotateLeft(s: string, i: number): string {\n  return s.slice(i) + s.slice(0, i);\n}\n\nfunction toReid333Struct(pattern: KPattern): string[][] {\n  const output: string[][] = [[], []];\n  for (let i = 0; i < 6; i++) {\n    if (pattern.patternData[\"CENTERS\"].pieces[i] !== i) {\n      throw new Error(\"non-oriented puzzles are not supported\");\n    }\n  }\n  for (let i = 0; i < 12; i++) {\n    output[0].push(\n      rotateLeft(\n        reidEdgeOrder[pattern.patternData[\"EDGES\"].pieces[i]],\n        pattern.patternData[\"EDGES\"].orientation[i],\n      ),\n    );\n  }\n  for (let i = 0; i < 8; i++) {\n    output[1].push(\n      rotateLeft(\n        reidCornerOrder[pattern.patternData[\"CORNERS\"].pieces[i]],\n        pattern.patternData[\"CORNERS\"].orientation[i],\n      ),\n    );\n  }\n  output.push(centerOrder);\n  return output;\n}\n\n// function toReid333String(state: Transformation): string {\n//   return toReid333Struct(state)\n//     .map((l) => l.join(\" \"))\n//     .join(\" \");\n// }\n\nexport function toMin2PhasePattern(pattern: KPattern): string {\n  const reid = toReid333Struct(pattern);\n  return map.map(([orbit, perm, ori]) => reid[orbit][perm][ori]).join(\"\");\n}\n","import { Move } from \"../../../../../alg\";\nimport type { KPuzzle } from \"../../../../../kpuzzle\";\nimport { KPattern } from \"../../../../../kpuzzle\";\n\nexport function isEquivalentTranformationIgnoringCENTERS(\n  t1: KPattern,\n  t2: KPattern,\n): boolean {\n  const t1NoCenterOri = new KPattern(t1.kpuzzle, {\n    EDGES: t1.patternData[\"EDGES\"],\n    CORNERS: t1.patternData[\"CORNERS\"],\n    CENTERS: {\n      pieces: t1.patternData[\"CENTERS\"].pieces,\n      orientation: new Array(6).fill(0),\n    },\n  }).experimentalToTransformation()!;\n  const t2NoCenterOri = new KPattern(t2.kpuzzle, {\n    EDGES: t2.patternData[\"EDGES\"],\n    CORNERS: t2.patternData[\"CORNERS\"],\n    CENTERS: {\n      pieces: t2.patternData[\"CENTERS\"].pieces,\n      orientation: new Array(6).fill(0),\n    },\n  }).experimentalToTransformation()!;\n  return t1NoCenterOri.isIdentical(t2NoCenterOri);\n}\n\nexport function passesFilter(kpuzzle: KPuzzle, pattern: KPattern): boolean {\n  if (\n    isEquivalentTranformationIgnoringCENTERS(kpuzzle.defaultPattern(), pattern)\n  ) {\n    return false;\n  }\n\n  for (const face of \"ULFRBD\") {\n    for (let amount = 1; amount < 4; amount++) {\n      const transformation = kpuzzle\n        .moveToTransformation(new Move(face, amount))\n        .toKPattern();\n      if (isEquivalentTranformationIgnoringCENTERS(transformation, pattern)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n// TODO: implement tests\n// {\n//   const def = await puzzles[\"3x3x3\"].def();\n//   const kpuzzle = new KPuzzle(def);\n//   console.log(passesFilter(def, kpuzzle.state));\n//   kpuzzle.applyAlg(parse(\"R\"));\n//   console.log(passesFilter(def, kpuzzle.state));\n//   kpuzzle.applyAlg(parse(\"D\"));\n//   console.log(passesFilter(def, kpuzzle.state));\n//   kpuzzle.reset();\n//   kpuzzle.applyAlg(parse(\"(R' U' R U')5\"));\n//   console.log(passesFilter(def, kpuzzle.state));\n// }\n","// TODO: Verify\nexport const sgs3x3x3: string[][] = [\n  [\n    \"R U'\",\n    \"R2 B\", //\n    \"D2 B2\",\n    \"D' L B'\", //\n    \"R' U'\",\n    \"B\", //\n    \"D B2\",\n    \"R' B\", //\n    \"L' U\",\n    \"L2 B'\", //\n    \"B2\",\n    \"D L B'\", //\n    \"L U\",\n    \"B'\", //\n    \"U'\",\n    \"R B\", //\n    \"D' B2\",\n    \"L B'\", //\n    \"U2\",\n    \"U L' B'\", //\n    \"\",\n    \"U' L' B'\", //\n    \"U\",\n    \"L' B'\",\n  ],\n  [\n    \"F2 L2\",\n    \"F' L'\",\n    \"R' F L2\", //\n    \"D' L2\",\n    \"F L2\",\n    \"F2 L'\", //\n    \"R' F' L'\",\n    \"R2 F L2\",\n    \"R2 F2 L'\", //\n    \"L2\",\n    \"F L'\",\n    \"D' L\", //\n    \"D2 L2\",\n    \"R2 F' L'\",\n    \"D L\", //\n    \"\",\n    \"L2 F L'\",\n    \"L F' L2\", //\n    \"L F L'\",\n    \"F' L2\",\n    \"L'\", //\n    \"D L2\",\n    \"D F L'\",\n    \"L\",\n  ],\n  [\n    \"R B U2 B'\",\n    \"R2 B U' B'\", //\n    \"F2 B U B'\",\n    \"F B2 L' B2\", //\n    \"B2 L B2\",\n    \"B U' B'\", //\n    \"R2 B U2 B'\",\n    \"R' B U' B'\", //\n    \"B2 L' B2\",\n    \"F B U B'\", //\n    \"B2 U' B2\",\n    \"B' L B\", //\n    \"L F' B D' B'\",\n    \"B' U' B2 D B'\", //\n    \"B U2 B'\",\n    \"R B U' B'\", //\n    \"B2 L2 B2\",\n    \"D' B' L B\", //\n    \"B U B'\",\n    \"F' B2 L' B2\", //\n    \"\",\n    \"B2 L' B' U' B'\",\n  ],\n  [\n    \"U F2 L2 U'\",\n    \"F' U L' U'\", //\n    \"F2 U L' U'\",\n    \"U F L2 U'\", //\n    \"U2 B2 U2\",\n    \"R' U' B U\", //\n    \"D2 U L U'\",\n    \"D U2 B' U2\", //\n    \"U L2 U'\",\n    \"F U L' U'\", //\n    \"D U L U'\",\n    \"U2 B' U2\", //\n    \"\",\n    \"U2 B' U' L' U'\", //\n    \"U2 L' U2\",\n    \"U' B U\", //\n    \"U L U'\",\n    \"D' U2 B' U2\", //\n    \"U L' U'\",\n    \"U2 B U2\",\n  ],\n  [\n    \"R' D' F2\",\n    \"F'\", //\n    \"F2\",\n    \"D R F'\", //\n    \"R D' F2\",\n    \"R2 F'\", //\n    \"D' F2\",\n    \"R F'\", //\n    \"F2 R' D' F2\",\n    \"F\", //\n    \"D2 F2\",\n    \"D' R F'\", //\n    \"R2 D' F2\",\n    \"R' F'\", //\n    \"D F2\",\n    \"D2 R F'\", //\n    \"\",\n    \"F R' D' F2\",\n  ],\n  [\n    \"R' D2 F' D F\",\n    \"R F2 R2 F2\",\n    \"R2 F' D2 F\", //\n    \"F' R2 D2 F\",\n    \"L D' L'\",\n    \"D F' D2 F\", //\n    \"F2 R2 F2\",\n    \"R F' D2 F\",\n    \"F' R2 D' F\", //\n    \"F' R' D2 F\",\n    \"F2 R' F2\",\n    \"L D L'\", //\n    \"F' R D' F\",\n    \"F2 R F2\",\n    \"F' D2 F\", //\n    \"\",\n    \"L D2 R D' L'\",\n    \"F' D2 F' R F2\", //\n    \"D2 R2 F2 R2 F2\",\n    \"D F' D' F\",\n    \"F' D F\",\n  ],\n  [\n    \"U F2 U'\",\n    \"R U F' U'\", //\n    \"D R U F2 U'\",\n    \"U F U'\", //\n    \"R2 U F2 U'\",\n    \"R' U F' U'\", //\n    \"R U F2 U'\",\n    \"R2 U F' U'\", //\n    \"\",\n    \"U L D L' F U'\", //\n    \"F2 D' R D F2\",\n    \"D2 U F U'\", //\n    \"R' U F2 U'\",\n    \"U F' U'\", //\n    \"F2 D2 R D2 F2\",\n    \"D U F U'\",\n  ],\n  [\n    \"R2\",\n    \"R' B' D B\", //\n    \"D R'\",\n    \"F' R2 F\", //\n    \"\",\n    \"R B' D B\", //\n    \"R'\",\n    \"B' D B\", //\n    \"D' R'\",\n    \"D2 F' R2 F\", //\n    \"R\",\n    \"R2 B' D B\", //\n    \"D2 R'\",\n    \"B' D' B\",\n  ],\n  [\n    \"R2 D' R2\",\n    \"F' R' F R\",\n    \"R D' R2 D R'\", //\n    \"D2 R2 D2 R2\",\n    \"R' D' F' R F\",\n    \"U F D F' U'\", //\n    \"\",\n    \"R2 D2 B R' B' R'\",\n    \"R' F D' F2 R F\", //\n    \"R2 D R2\",\n    \"F2 U F U' F\",\n    \"R' D F' R F\", //\n    \"D R2 D2 R2\",\n    \"U F D' F' U'\",\n    \"D R' D2 F' R F\", //\n    \"R2 D2 R2\",\n    \"U F D2 F' U'\",\n    \"R' D2 F' R F\",\n  ],\n  [\n    \"B R B'\",\n    \"F D F' B R2 B'\", //\n    \"D B R2 B'\",\n    \"D2 B R' B'\", //\n    \"B R2 B'\",\n    \"D B R' B'\", //\n    \"D' B R2 B'\",\n    \"B R' B'\", //\n    \"\",\n    \"B R2 B' D B R' B'\", //\n    \"D2 B R2 B'\",\n    \"D' B R' B'\",\n  ],\n  [\n    \"\",\n    \"R' D R F D2 F'\", //\n    \"R' D R\",\n    \"D F D' F'\", //\n    \"R F' R' F\",\n    \"F D' F'\", //\n    \"R' D' R\",\n    \"F D2 F'\", //\n    \"R' D2 R\",\n    \"F D F'\",\n  ],\n  [\n    \"\",\n    \"F2 D2 R F' R' D2 F' D2 F'\",\n    \"F2 D2 F' D' F D' F' D2 F'\", //\n    \"F2 D F2 D F2 D2 F2\",\n    \"D2 F L D2 L' D2 F'\",\n    \"D F D2 L D2 L' F'\", //\n    \"R' D B' D2 B D' R\",\n    \"R' D2 B' D2 B R\",\n    \"F D2 F' D F D F'\", //\n    \"F D' L D2 L' D F'\",\n    \"B D' F D B' D' F'\",\n    \"F D2 L D2 L' F'\", //\n    \"F D' L D L' D F'\",\n    \"F L D2 L' D2 F'\",\n    \"R' B' D2 B D2 R\",\n  ],\n  [\n    \"D'\",\n    \"F L D L' D' F'\", //\n    \"D2\",\n    \"L B D B' D' L'\", //\n    \"D\",\n    \"B' L' D' L D B\", //\n    \"\",\n    \"D F L D L' D' F'\",\n  ],\n  [\n    \"F' D2 F D F' D F\",\n    \"F' D' R' D R F\", //\n    \"F' R' D' R D F\",\n    \"B D R D' R' B'\", //\n    \"\",\n    \"D B' D' L' D L B\",\n  ],\n  [\n    \"D F D F' D F D2 F'\",\n    \"F' U2 B' R' B U2 F' L F' L' F'\", //\n    \"\",\n    \"D2 L D L2 F L F2 D F\",\n  ],\n  [\n    \"L B' L' F L B L' F'\",\n    \"F2 U F' D2 F U' F' D2 F'\",\n    \"D' F' D B D' F D B'\", //\n    \"F L2 F R2 F' L2 F R2 F2\",\n    \"D B D' F' D B' D' F\",\n    \"R F L F' R' F L' F'\", //\n    \"\",\n    \"D2 B L' U2 L B' D2 B L' U2 L B'\",\n    \"D2 F R' U2 R F' D2 F R' U2 R F'\", //\n    \"R F L' F' R' F L F'\",\n    \"D F D' B' D F' D' B\",\n    \"L2 F2 L' B2 L F2 L' B2 L'\",\n  ],\n  [\n    \"L B R' B' L' B R B'\",\n    \"R' B R F' R' B' R F\",\n    \"L D2 L U L' D2 L U' L2\", //\n    \"\",\n    \"D2 B' D2 F D' L2 F L2 F' D2 B D' F'\",\n    \"D2 F' R' F R2 B' D2 B D2 R' F D2 F'\", //\n    \"L B L' F L B' L' F'\",\n    \"F' D2 F' U' F D2 F' U F2\",\n    \"D' B' D F D' B D F'\",\n  ],\n  [\"\", \"D2 F' L U2 L' F D2 F' L U2 L' F\", \"D2 B' R U2 R' B D2 B' R U2 R' B\"],\n];\n","import { randomChoice } from \"random-uint-below\";\nimport { Alg } from \"../../../../../alg\";\nimport type { KPattern } from \"../../../../../kpuzzle/KPattern\";\nimport { puzzles } from \"../../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../../inside-worker\";\nimport { addOrientationSuffix } from \"../../addOrientationSuffix\";\nimport { dynamic3x3x3min2phase } from \"../dynamic/3x3x3\";\nimport { toMin2PhasePattern } from \"./convert\";\nimport { passesFilter } from \"./filter\";\nimport { sgs3x3x3 } from \"./legacy-sgs\";\n\nexport async function random333Pattern(): Promise<KPattern> {\n  const kpuzzle = await puzzles[\"3x3x3\"].kpuzzle();\n  let pattern = kpuzzle.defaultPattern();\n  for (const piece of sgs3x3x3) {\n    pattern = pattern.applyAlg(Alg.fromString(randomChoice(piece)));\n  }\n  if (!passesFilter(kpuzzle, pattern)) {\n    return random333Pattern();\n  }\n  return pattern;\n}\n\nexport async function solve333(s: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  return Alg.fromString(\n    (await dynamic3x3x3min2phase).solvePattern(toMin2PhasePattern(s)),\n  );\n}\n\nexport async function random333Scramble(): Promise<Alg> {\n  return solve333(await random333Pattern());\n}\n\nexport async function initialize333(): Promise<void> {\n  (await dynamic3x3x3min2phase).initialize();\n}\n\nconst randomSuffixes = [\n  [null, \"Rw\", \"Rw2\", \"Rw'\", \"Fw\", \"Fw'\"],\n  [null, \"Dw\", \"Dw2\", \"Dw'\"],\n];\n\nexport async function random333OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random333Scramble(), randomSuffixes);\n}\n","import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPatternData,\n  KPatternOrbitData,\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitDefinition of definition.orbits) {\n    const orbit1 = transformationData1[orbitDefinition.orbitName];\n    const orbit2 = transformationData2[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitDefinition.orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitDefinition.orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitDefinition.orbitName] = {\n          permutation: newPerm,\n          orientationDelta: orbit1.orientationDelta,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientationDelta[orbit2.permutation[idx]] +\n              orbit2.orientationDelta[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitDefinition.orbitName] = {\n          permutation: newPerm,\n          orientationDelta: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToKPatternData(\n  definition: KPuzzleDefinition,\n  patternData: KPatternData,\n  transformationData: KTransformationData,\n): KPatternData {\n  const newPatternData = {} as KPatternData;\n  for (const orbitDefinition of definition.orbits) {\n    const patternOrbit = patternData[orbitDefinition.orbitName];\n    const transformationOrbit = transformationData[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        transformationOrbit,\n      )\n    ) {\n      // common case for big cubes\n      newPatternData[orbitDefinition.orbitName] = patternOrbit;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] =\n            patternOrbit.pieces[transformationOrbit.permutation[idx]];\n        }\n        const newOrbitData: KPatternOrbitData = {\n          pieces: newPieces,\n          orientation: patternOrbit.orientation, // copy all 0\n        };\n        newPatternData[orbitDefinition.orbitName] = newOrbitData;\n      } else {\n        const newOrientation = new Array(orbitDefinition.numPieces);\n        const newOrientationMod: number[] | undefined =\n          patternOrbit.orientationMod\n            ? new Array(orbitDefinition.numPieces)\n            : undefined;\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          const transformationIdx = transformationOrbit.permutation[idx];\n          let mod = orbitDefinition.numOrientations;\n          if (patternOrbit.orientationMod) {\n            const orientationMod =\n              patternOrbit.orientationMod[transformationIdx];\n            newOrientationMod![idx] = orientationMod;\n            mod = orientationMod || orbitDefinition.numOrientations;\n          }\n          newOrientation[idx] =\n            (patternOrbit.orientation[transformationIdx] +\n              transformationOrbit.orientationDelta[idx]) %\n            mod; // We don't have to use `modIntoRange` (assuming input is well-formed), because we're adding.\n          newPieces[idx] = patternOrbit.pieces[transformationIdx];\n        }\n        const newOrbitData: KPatternOrbitData = {\n          pieces: newPieces,\n          orientation: newOrientation,\n        };\n        if (newOrientationMod) {\n          newOrbitData.orientationMod = newOrientationMod;\n        }\n        newPatternData[orbitDefinition.orbitName] = newOrbitData;\n      }\n    }\n  }\n  return newPatternData;\n}\n","import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientationDelta: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const orbitDefinition of definition.orbits) {\n    transformation[orbitDefinition.orbitName] =\n      constructIdentityOrbitTransformation(orbitDefinition.numPieces);\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  function getTransformationData(\n    key: {\n      toString: () => string;\n    },\n    multiplyAmount: number,\n  ): KTransformationData | undefined {\n    const s = key.toString();\n    const movesDef = kpuzzle.definition.moves[s];\n    if (movesDef) {\n      return repeatTransformationUncached(kpuzzle, movesDef, multiplyAmount);\n    }\n    const derivedDef = kpuzzle.definition.derivedMoves?.[s];\n    if (derivedDef) {\n      return repeatTransformationUncached(\n        kpuzzle,\n        kpuzzle.algToTransformation(derivedDef).transformationData,\n        multiplyAmount,\n      );\n    }\n    return undefined;\n  }\n\n  // TODO: Use Euclid's algorithm to pre-calculate the GCD of moves for each\n  // quantum, along with its transformation. This will make lookup `O(1)` for multiples of e.g. `y2`.\n\n  const data =\n    getTransformationData(move.quantum, move.amount) ??\n    // Handle e.g. `y2` if `y2` is defined.\n    // Note: this doesn't handle multiples.\n    getTransformationData(move, 1) ??\n    // Handle e.g. `y2'` if `y2` is defined.\n    // Note: this doesn't handle multiples.\n    getTransformationData(move.invert, -1);\n\n  if (data) {\n    return data;\n  }\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n","import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport { KPattern } from \"./KPattern\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKPattern(): KPattern {\n    return KPattern.fromTransformation(this);\n  }\n\n  // TODO: support calculating this for a given start state. (For `R U R' U` on 3x3x3, should this default to 5 or 10?)\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n","import {\n  type Alg,\n  type Commutator,\n  type Conjugate,\n  functionFromTraversal,\n  type Grouping,\n  type LineComment,\n  type Move,\n  type Newline,\n  type Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPatternData,\n  KPatternOrbitData,\n  KPuzzleDefinition,\n  KPuzzleOrbitDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  if (!orbitTransformationData.permutation) {\n    console.log(orbitTransformationData);\n  }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientationDelta: orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KPuzzleOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignorePieceOrientations?: boolean;\n    ignorePiecePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignorePieceOrientations &&\n      orbitTransformationData1.orientationDelta[idx] !==\n        orbitTransformationData2.orientationDelta[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePiecePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitDefinition.orbitName],\n        transformationData2[orbitDefinition.orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isOrbitPatternDataIdentical(\n  orbitDefinition: KPuzzleOrbitDefinition,\n  orbitPatternData1: KPatternOrbitData,\n  orbitPatternData2: KPatternOrbitData,\n  options: {\n    ignorePieceOrientations?: boolean;\n    ignorePieceIndices?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignorePieceOrientations &&\n      (orbitPatternData1.orientation[idx] !==\n        orbitPatternData2.orientation[idx] ||\n        (orbitPatternData1.orientationMod?.[idx] ?? 0) !==\n          (orbitPatternData2.orientationMod?.[idx] ?? 0))\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePieceIndices &&\n      orbitPatternData1.pieces[idx] !== orbitPatternData2.pieces[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isPatternDataIdentical(\n  kpuzzle: KPuzzle,\n  patternData1: KPatternData,\n  patternData2: KPatternData,\n): boolean {\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    if (\n      !isOrbitPatternDataIdentical(\n        orbitDefinition,\n        patternData1[orbitDefinition.orbitName],\n        patternData2[orbitDefinition.orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    const orbitTransformationData =\n      transformationData[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitDefinition.orbitName] =\n        orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitDefinition.orbitName] = {\n        permutation: newPerm,\n        orientationDelta: orbitTransformationData.orientationDelta,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientationDelta[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitDefinition.orbitName] = {\n        permutation: newPerm,\n        orientationDelta: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nexport const algToTransformation = functionFromTraversal(\n  AlgToTransformationTraversal,\n);\n\n// export function canConvertDefaultPatternToUniqueTransformationUncached(\n//   definition: KPuzzleDefinition,\n// ): boolean {\n//   for (const orbitDefinition of definition.orbits) {\n//     const pieces = new Array(orbitDefinition.numPieces).fill(false);\n//     for (const piece of definition.defaultPattern[orbitDefinition.orbitName]\n//       .pieces) {\n//       pieces[piece] = true;\n//     }\n//     for (const piece of pieces) {\n//       if (!piece) {\n//         return false;\n//       }\n//     }\n//   }\n//   return true;\n// }\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitDefinition of definition.orbits) {\n    const transformationOrbit =\n      transformation.transformationData[orbitDefinition.orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientationDelta[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n","import type { Alg, Move } from \"../alg\";\nimport { isPatternDataIdentical } from \"./calculate\";\nimport { applyTransformationDataToKPatternData } from \"./combine\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KPatternData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport class KPattern {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly patternData: KPatternData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      patternData: this.patternData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KPattern {\n    const newPatternData = applyTransformationDataToKPatternData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.defaultPattern,\n      transformation.transformationData,\n    );\n    return new KPattern(transformation.kpuzzle, newPatternData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KPattern {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KPattern {\n    if (transformation.isIdentityTransformation()) {\n      return new KPattern(this.kpuzzle, this.patternData);\n    }\n    const newPatternData = applyTransformationDataToKPatternData(\n      this.kpuzzle.definition,\n      this.patternData,\n      transformation.transformationData,\n    );\n    return new KPattern(this.kpuzzle, newPatternData);\n  }\n\n  applyMove(move: Move | string): KPattern {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KPattern {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  isIdentical(other: KPattern): boolean {\n    return isPatternDataIdentical(\n      this.kpuzzle,\n      this.patternData,\n      other.patternData,\n    );\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertDefaultPatternToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, patternOrbitData] of Object.entries(\n      this.patternData,\n    )) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: patternOrbitData.pieces,\n        orientationDelta: patternOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    // Note: `ignoreCenterOrientation` must currently be specified even if the puzzle does not have centers with indistinguishable orientations (in which case the value will be ignored).\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsPatternSolved) {\n      throw new Error(\n        \"`KPattern.experimentalIsPatternSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsPatternSolved(this, options);\n  }\n}\n","import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport { KPattern } from \"./KPattern\";\nimport type {\n  KPuzzleDefinition,\n  KPuzzleOrbitDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  #indexedOrbits: Record<string, KPuzzleOrbitDefinition> | undefined;\n  // Note: this function is needed much more rarely than you might think. Most\n  // operations related to orbits require iterating through all of them, for\n  // which the following is better:\n  //\n  //    for (const orbitDefinition of kpuzzle.definition.orbits) { // \n  //    }\n  lookupOrbitDefinition(orbitName: string): KPuzzleOrbitDefinition {\n    this.#indexedOrbits ||= (() => {\n      const indexedOrbits: Record<string, KPuzzleOrbitDefinition> = {};\n      for (const orbitDefinition of this.definition.orbits) {\n        indexedOrbits[orbitDefinition.orbitName] = orbitDefinition;\n      }\n      return indexedOrbits;\n    })();\n    return this.#indexedOrbits[orbitName];\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  defaultPattern(): KPattern {\n    return new KPattern(this, this.definition.defaultPattern);\n  }\n\n  #cachedCanConvertDefaultPatternToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete default pattern data\n  canConvertDefaultPatternToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertDefaultPatternToUniqueTransformation ??=\n      ((): boolean => {\n        for (const orbitDefinition of this.definition.orbits) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.defaultPattern[\n            orbitDefinition.orbitName\n          ].pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n}\n","// @ts-nocheck\n\nexport class PLazy<T> extends Promise<T> {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n\n    this._executor = executor;\n  }\n\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  // biome-ignore lint/suspicious/noThenProperty: This is implementing the `Promise` API.\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.catch(onRejected);\n  }\n}\n\nexport function from<T>(function_): Promise<T> {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n","// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshStickeringMask =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"experimentalOriented2\" // TODO\n  | \"ignored\"\n  | \"invisible\"\n  | \"mystery\";\n\nexport type FaceletStickeringMask = {\n  mask: FaceletMeshStickeringMask;\n  hintMask?: FaceletMeshStickeringMask;\n};\n\nexport type PieceStickeringMask = {\n  // TODO: foundation?\n  facelets: (FaceletMeshStickeringMask | FaceletStickeringMask | null)[];\n};\n\nexport type OrbitStickeringMask = {\n  pieces: (PieceStickeringMask | null)[];\n};\n\nexport type StickeringMask = {\n  specialBehaviour?: \"picture\"; // TODO: remove this\n  name?: string; // TODO\n  orbits: Record<string, OrbitStickeringMask>;\n};\n\nexport function getFaceletStickeringMask(\n  stickeringMask: StickeringMask,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshStickeringMask {\n  const orbitStickeringMask = stickeringMask.orbits[orbitName];\n  const pieceStickeringMask: PieceStickeringMask | null =\n    orbitStickeringMask.pieces[pieceIdx];\n  if (pieceStickeringMask === null) {\n    return regular;\n  }\n  const faceletStickeringMask:\n    | FaceletMeshStickeringMask\n    | FaceletStickeringMask\n    | null = pieceStickeringMask.facelets?.[faceletIdx];\n  if (faceletStickeringMask === null) {\n    return regular;\n  }\n  if (typeof faceletStickeringMask === \"string\") {\n    return faceletStickeringMask;\n  }\n  if (hint) {\n    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;\n  }\n  console.log(faceletStickeringMask);\n  return faceletStickeringMask.mask;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n  ExperimentalOrientationWithoutPermutation2 = \"ExperimentalOrientationWithoutPermutation2\", // TODO\n  Mystery = \"Mystery\", // TODO\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const orbitDefinition of kpuzzle.definition.orbits) {\n      this.stickerings.set(\n        orbitDefinition.orbitName,\n        new Array(orbitDefinition.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst experimentalOriented2 = \"experimentalOriented2\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\nconst mystery = \"mystery\";\n\n// We specify 5 facelets, because that's the maximum we need for any built-in puzzles (e.g. Megaminx centers or icosa vertices).\n// TODO: use \"primary\" and \"non-primary\" fields instead of listing all non-primary facelets.\nconst pieceStickerings: Record<string, PieceStickeringMask> = {\n  // regular\n  [PieceStickering.Regular]: {\n    // r\n    facelets: [regular, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Ignored]: {\n    // i\n    facelets: [ignored, ignored, ignored, ignored, ignored],\n  },\n\n  // oriented stickers\n  [PieceStickering.OrientationStickers]: {\n    // o\n    facelets: [oriented, oriented, oriented, oriented, oriented],\n  },\n\n  // \"OLL\"\n  [PieceStickering.IgnoreNonPrimary]: {\n    // riiii\n    facelets: [regular, ignored, ignored, ignored, ignored],\n  },\n\n  // invisible\n  [PieceStickering.Invisible]: {\n    // invisiblePiece\n    facelets: [invisible, invisible, invisible, invisible, invisible],\n  },\n\n  // \"PLL\"\n  [PieceStickering.PermuteNonPrimary]: {\n    // drrrr\n    facelets: [dim, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Dim]: {\n    // d\n    facelets: [dim, dim, dim, dim, dim],\n  },\n\n  // \"OLL\"\n  [PieceStickering.Ignoriented]: {\n    // diiii\n    facelets: [dim, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.OrientationWithoutPermutation]: {\n    // oiiii\n    facelets: [oriented, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.ExperimentalOrientationWithoutPermutation2]: {\n    // oiiii\n    facelets: [experimentalOriented2, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.Mystery]: {\n    // oiiii\n    facelets: [mystery, mystery, mystery, mystery, mystery],\n  },\n};\n\nexport function getPieceStickeringMask(\n  pieceStickering: PieceStickering,\n): PieceStickeringMask {\n  return pieceStickerings[pieceStickering];\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toStickeringMask(): StickeringMask {\n    const stickeringMask: StickeringMask = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceStickeringMask[] = [];\n      const orbitStickeringMask: OrbitStickeringMask = {\n        pieces,\n      };\n      stickeringMask.orbits[orbitName] = orbitStickeringMask;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceStickeringMask(pieceStickering));\n      }\n    }\n    return stickeringMask;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      pieceLoop: for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      pieceLoop: for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] =\n          !pieceSet.stickerings.get(orbitDefinition.orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitDefinition.orbitName]\n            .permutation[i] !== i ||\n          transformation.transformationData[orbitDefinition.orbitName]\n            .orientationDelta[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  orbits(orbitNames: string[]): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName)!.fill(true);\n    }\n    return pieceSet;\n  }\n\n  orbitPrefix(orbitPrefix: string): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      if (orbitDefinition.orbitName.startsWith(orbitPrefix)) {\n        pieceSet.stickerings.get(orbitDefinition.orbitName)!.fill(true);\n      }\n    }\n    return pieceSet;\n  }\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const orbitDefinition of this.def.orbits) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDefinition.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n","import type { PuzzleID } from \"../../twisty\";\n\nconst LL = \"Last Layer\";\nconst LS = \"Last Slot\";\nconst megaAnd3x3x3LL = {\n  \"3x3x3\": LL,\n  megaminx: LL,\n};\nconst megaAnd3x3x3LS = {\n  \"3x3x3\": LS,\n  megaminx: LS,\n};\n\nexport const experimentalStickerings: Record<\n  string,\n  { groups?: Partial<Record<PuzzleID, string>> }\n> = {\n  full: { groups: { \"3x3x3\": \"Stickering\", megaminx: \"Stickering\" } }, // default\n  OLL: { groups: megaAnd3x3x3LL },\n  PLL: { groups: megaAnd3x3x3LL },\n  LL: { groups: megaAnd3x3x3LL },\n  EOLL: { groups: megaAnd3x3x3LL },\n  COLL: { groups: megaAnd3x3x3LL },\n  OCLL: { groups: megaAnd3x3x3LL },\n  CPLL: { groups: megaAnd3x3x3LL },\n  CLL: { groups: megaAnd3x3x3LL },\n  EPLL: { groups: megaAnd3x3x3LL },\n  ELL: { groups: megaAnd3x3x3LL },\n  ZBLL: { groups: megaAnd3x3x3LL },\n  LS: { groups: megaAnd3x3x3LS },\n  LSOLL: { groups: megaAnd3x3x3LS },\n  LSOCLL: { groups: megaAnd3x3x3LS },\n  ELS: { groups: megaAnd3x3x3LS },\n  CLS: { groups: megaAnd3x3x3LS },\n  ZBLS: { groups: megaAnd3x3x3LS },\n  VLS: { groups: megaAnd3x3x3LS },\n  WVLS: { groups: megaAnd3x3x3LS },\n  F2L: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Daisy: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Cross: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  EO: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOline: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOcross: { groups: { \"3x3x3\": \"ZZ\" } },\n  FirstBlock: { groups: { \"3x3x3\": \"Roux\" } },\n  SecondBlock: { groups: { \"3x3x3\": \"Roux\" } },\n  CMLL: { groups: { \"3x3x3\": \"Roux\" } },\n  L10P: { groups: { \"3x3x3\": \"Roux\" } },\n  L6E: { groups: { \"3x3x3\": \"Roux\" } },\n  L6EO: { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  EODF: { groups: { \"3x3x3\": \"Nautilus\" } },\n  G1: { groups: { \"3x3x3\": \"FMC\" } },\n  L2C: {\n    groups: {\n      \"4x4x4\": \"Reduction\",\n      \"5x5x5\": \"Reduction\",\n      \"6x6x6\": \"Reduction\",\n    },\n  },\n  PBL: {\n    groups: {\n      \"2x2x2\": \"Ortega\",\n    },\n  },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  invisible: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  picture: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } }, // TODO\n  \"opposite-centers\": { groups: { \"4x4x4\": \"Reduction\" } }, // TODO\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } },\n};\n","import type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  type PieceSet,\n  PieceStickering,\n  PuzzleStickering,\n  StickeringManager,\n  type StickeringMask,\n} from \"./mask\";\nimport { experimentalStickerings } from \"./puzzle-stickerings\";\n\nexport async function cubeLikeStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  return (\n    await cubeLikePuzzleStickering(puzzleLoader, stickering)\n  ).toStickeringMask();\n}\n\n// TODO: cache calculations?\nexport async function cubeLikePuzzleStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleStickering> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const CENTERS = (): PieceSet => m.orbitPrefix(\"CENTER\");\n  const CENTER = (faceMove: string): PieceSet =>\n    m.and([m.move(faceMove), CENTERS()]);\n  const EDGES = (): PieceSet => m.orbitPrefix(\"EDGE\");\n  const EDGE = (faceMoves: string[]): PieceSet =>\n    m.and([m.and(m.moves(faceMoves)), EDGES()]);\n  const CORNERS = (): PieceSet =>\n    m.or([\n      m.orbitPrefix(\"CORNER\"),\n      m.orbitPrefix(\"C4RNER\"),\n      m.orbitPrefix(\"C5RNER\"),\n    ]);\n\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n  const centerLL = (): PieceSet => m.and([LL(), CENTERS()]);\n\n  const edgeFR = (): PieceSet => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  // Handles Megaminx\n  const cornerDFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Regular); // For PG\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\": {\n      dimF2L();\n      setPLL();\n      break;\n    }\n    case \"CLS\": {\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"OLL\": {\n      dimF2L();\n      setOLL();\n      break;\n    }\n    case \"EOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"COLL\": {\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"OCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"CPLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.and([CORNERS(), LL()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      puzzleStickering.set(\n        m.and([m.not(CORNERS()), LL()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"CLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"EPLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), EDGES()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"ELL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ELS\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    }\n    case \"LL\": {\n      dimF2L();\n      break;\n    }\n    case \"F2L\": {\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    }\n    case \"ZBLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ZBLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"VLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    }\n    case \"WVLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"LS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim);\n      break;\n    }\n    case \"LSOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      break;\n    }\n    case \"LSOCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      break;\n    }\n    case \"EO\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    }\n    case \"EOline\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    }\n    case \"EOcross\": {\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    }\n    case \"CMLL\": {\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L10P\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L6E\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    }\n    case \"L6EO\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.ExperimentalOrientationWithoutPermutation2,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.ExperimentalOrientationWithoutPermutation2,\n      ); // For PG\n      puzzleStickering.set(\n        m.and([m.move(\"M\"), m.move(\"E\")]),\n        PieceStickering.Ignored,\n      );\n      break;\n    }\n    case \"Daisy\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"Cross\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"2x2x2\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"2x2x3\": {\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"G1\": {\n      puzzleStickering.set(\n        m.all(),\n        PieceStickering.ExperimentalOrientationWithoutPermutation2,\n      );\n      puzzleStickering.set(\n        m.or(m.moves([\"E\"])),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"E\", \"S\"])), PieceStickering.Ignored);\n      break;\n    }\n    case \"L2C\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"L\", \"R\", \"B\", \"D\"])),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    case \"PBL\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"D\"])),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"FirstBlock\": {\n      puzzleStickering.set(\n        m.not(m.and([m.and(m.moves([\"L\"])), m.not(LL())])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(CENTER(\"R\"), PieceStickering.Dim);\n      break;\n    }\n    case \"SecondBlock\": {\n      puzzleStickering.set(\n        m.not(m.and([m.and(m.moves([\"L\"])), m.not(LL())])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.and(m.moves([\"L\"])), m.not(LL())]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.and(m.moves([\"R\"])), m.not(LL())]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"EODF\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.or([cornerDFR(), m.and([LL(), CORNERS()])]),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.or([m.and([LL(), EDGES()]), edgeFR()]),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(EDGE([\"D\", \"F\"]), PieceStickering.Regular);\n      puzzleStickering.set(CENTER(\"F\"), PieceStickering.Regular);\n      break;\n    }\n    case \"Void Cube\": {\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    }\n    case \"picture\":\n    // fallthrough\n    case \"invisible\": {\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    }\n    case \"centers-only\": {\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    case \"opposite-centers\": {\n      puzzleStickering.set(\n        m.not(m.and([CENTERS(), m.or(m.moves([\"U\", \"D\"]))])),\n        PieceStickering.Ignored,\n      );\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering;\n}\n\nexport async function cubeLikeStickeringList(\n  puzzleID: PuzzleID,\n  options?: { use3x3x3Fallbacks: boolean },\n): Promise<ExperimentalStickering[]> {\n  const stickerings: ExperimentalStickering[] = [];\n  const stickeringsFallback: ExperimentalStickering[] = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups) {\n      if (puzzleID in info.groups) {\n        stickerings.push(name);\n      } else if (options?.use3x3x3Fallbacks && \"3x3x3\" in info.groups) {\n        stickeringsFallback.push(name);\n      }\n    }\n  }\n  return stickerings.concat(stickeringsFallback);\n}\n","export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n","import {\n  Move,\n  type PuzzleSpecificSimplifyOptions,\n  type QuantumMove,\n} from \"../../alg\";\nimport { KPuzzle, type KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport { PLazy } from \"../../vendor/mit/p-lazy/p-lazy\";\nimport { cubeMirrorTransforms } from \"../implementations/3x3x3\";\nimport type { AlgTransformData, PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../stickerings/cube-like-stickerings\";\nimport type { StickeringMask } from \"../stickerings/mask\";\nimport { getCached } from \"./lazy-cached\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// When we need a base puzzle (when a user wants GAP or Mathematica\n// or KSolve output), or if we want to run Schreier-Sims or such,\n// we need a default base puzzle to work with (for instance, 333\n// without slice moves or oriented centers  is what people expect).\n// This function lets those operations behave more in line with\n// what people want.\nasync function asyncGetBasePuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName);\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n  setOrientationModTo1ForPiecesOfOrbits?: string[], // TODO: make this unhacky\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  if (setOrientationModTo1ForPiecesOfOrbits) {\n    const setOrientationModTo1ForPiecesOfOrbitsSet = new Set(\n      setOrientationModTo1ForPiecesOfOrbits,\n    );\n    for (const [orbitName, orbitData] of Object.entries(\n      kpuzzleDefinition.defaultPattern,\n    )) {\n      if (setOrientationModTo1ForPiecesOfOrbitsSet.has(orbitName)) {\n        orbitData.orientationMod = new Array(\n          orbitData.pieces.length, // TODO: get this from the orbit definition, especially once we allow empty entries.\n        ).fill(1);\n      }\n    }\n  }\n  return new KPuzzle(pgNotation.remapKPuzzleDefinition(kpuzzleDefinition), {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  setOrientationModTo1ForPiecesOfOrbits?: string[];\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  #setOrientationModTo1ForPiecesOfOrbits?: string[]; //  // TODO: make this unhacky\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n    this.#setOrientationModTo1ForPiecesOfOrbits =\n      info.setOrientationModTo1ForPiecesOfOrbits;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedBasePG: Promise<PuzzleGeometry> | undefined;\n  basePG(): Promise<PuzzleGeometry> {\n    return (this.#cachedBasePG ??= asyncGetBasePuzzleGeometry(\n      this.pgId ?? this.id,\n    ));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(\n      this.pg(),\n      this.id,\n      this.#setOrientationModTo1ForPiecesOfOrbits,\n    ));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n\n  puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(\n    this.kpuzzle.bind(this),\n  );\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return cubeLikeStickeringMask(this, stickering);\n  }\n  stickerings = () =>\n    cubeLikeStickeringList(this.id as PuzzleID, { use3x3x3Fallbacks: true });\n  algTransformData: AlgTransformData = cubeMirrorTransforms;\n}\n\nexport function puzzleSpecificSimplifyOptionsPromise(\n  kpuzzlePromiseFn: () => Promise<KPuzzle>,\n): Promise<PuzzleSpecificSimplifyOptions> {\n  return new PLazy(\n    async (resolve: (options: PuzzleSpecificSimplifyOptions) => void) => {\n      const kpuzzle = await kpuzzlePromiseFn();\n      resolve({\n        quantumMoveOrder: (m: QuantumMove) => {\n          return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();\n        },\n      });\n    },\n  );\n}\n","import type { KPuzzleDefinition } from \"../../../../kpuzzle\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: [\n    { orbitName: \"EDGES\", numPieces: 12, numOrientations: 2 },\n    { orbitName: \"CORNERS\", numPieces: 8, numOrientations: 3 },\n    { orbitName: \"CENTERS\", numPieces: 6, numOrientations: 4 },\n  ],\n  defaultPattern: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n      orientationMod: [1, 1, 1, 1, 1, 1],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientationDelta: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientationDelta: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientationDelta: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientationDelta: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientationDelta: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientationDelta: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientationDelta: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientationDelta: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientationDelta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientationDelta: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientationDelta: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientationDelta: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientationDelta: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientationDelta: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientationDelta: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientationDelta: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientationDelta: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientationDelta: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientationDelta: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientationDelta: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientationDelta: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n  derivedMoves: {\n    Uw: \"u\",\n    Lw: \"l\",\n    Fw: \"f\",\n    Rw: \"r\",\n    Bw: \"b\",\n    Dw: \"d\",\n\n    Uv: \"y\",\n    Lv: \"x'\",\n    Fv: \"z\",\n    Rv: \"x\",\n    Bv: \"z'\",\n    Dv: \"y'\",\n\n    \"2U\": \"u U'\",\n    \"2L\": \"l L'\",\n    \"2F\": \"f F'\",\n    \"2R\": \"r R'\",\n    \"2B\": \"b B'\",\n    \"2D\": \"d D'\",\n  },\n};\n","import { Alg } from \"../../../../alg\";\nimport { KPattern, type KTransformation } from \"../../../../kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../cubing-private\";\n\nexport function puzzleOrientation3x3x3Idx(pattern: KPattern): [number, number] {\n  const idxU = pattern.patternData[\"CENTERS\"].pieces[0];\n  const idxD = pattern.patternData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = pattern.patternData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nexport function puzzleOrientation3x3x3Cache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKPattern(),\n          );\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize3x3x3Orientation(pattern: KPattern): KPattern {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(pattern);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return pattern.applyTransformation(orientationTransformation);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  pattern: KPattern,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    pattern = normalize3x3x3Orientation(pattern);\n  }\n  // TODO(orientationMod)\n  if (options.ignoreCenterOrientation) {\n    pattern = new KPattern(pattern.kpuzzle, {\n      EDGES: pattern.patternData[\"EDGES\"],\n      CORNERS: pattern.patternData[\"CORNERS\"],\n      CENTERS: {\n        pieces: pattern.patternData[\"CENTERS\"].pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!pattern.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n","import type { AlgTransformData } from \"cubing/puzzles/cubing-private\";\nimport {\n  Alg,\n  type AlgNode,\n  Commutator,\n  Conjugate,\n  functionFromTraversal,\n  type Grouping,\n  type LineComment,\n  type Move,\n  type Newline,\n  type Pause,\n  TraversalDownUp,\n} from \"../alg\";\n\nclass TransformAlg extends TraversalDownUp<\n  AlgTransformData[string],\n  Alg,\n  AlgNode\n> {\n  public traverseAlg(alg: Alg, dataDown: AlgTransformData[string]): Alg {\n    const algNodes: AlgNode[] = [];\n    for (const algNode of alg.childAlgNodes()) {\n      algNodes.push(this.traverseAlgNode(algNode, dataDown));\n    }\n    return new Alg(algNodes);\n  }\n\n  public traverseGrouping(\n    grouping: Grouping,\n    dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return grouping.modified({ alg: this.traverseAlg(grouping.alg, dataDown) });\n  }\n\n  public traverseMove(move: Move, dataDown: AlgTransformData[string]): AlgNode {\n    const invert = (() => {\n      const { invertExceptByFamily } = dataDown;\n      if (!invertExceptByFamily) {\n        return false;\n      }\n      return !invertExceptByFamily.has(move.family);\n    })();\n    return move.modified({\n      amount: invert ? -move.amount : move.amount,\n      family: dataDown.replaceMovesByFamily[move.family] ?? move.family,\n    });\n  }\n\n  public traverseCommutator(\n    commutator: Commutator,\n    dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return new Commutator(\n      this.traverseAlg(commutator.A, dataDown),\n      this.traverseAlg(commutator.B, dataDown),\n    );\n  }\n\n  public traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return new Conjugate(\n      this.traverseAlg(conjugate.A, dataDown),\n      this.traverseAlg(conjugate.B, dataDown),\n    );\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(\n    pause: Pause,\n    _dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return pause;\n  }\n\n  public traverseNewline(\n    newLine: Newline,\n    _dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return newLine;\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseLineComment(\n    comment: LineComment,\n    _dataDown: AlgTransformData[string],\n  ): AlgNode {\n    return comment;\n  }\n}\n\nexport const transformAlg = functionFromTraversal(TransformAlg);\n","import type { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport {\n  asyncGetKPuzzle,\n  puzzleSpecificSimplifyOptionsPromise,\n} from \"./async/async-pg3d\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n  options?: {\n    includeCenterOrbits?: boolean;\n    includeEdgeOrbits?: boolean;\n    // TODO: expose the API better.\n    allMoves?: boolean;\n    orientCenters?: boolean;\n    addRotations?: boolean;\n  },\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: options?.allMoves ?? true,\n    orientCenters: options?.orientCenters ?? true,\n    addRotations: options?.addRotations ?? true,\n    ...options,\n  });\n}\n\nexport async function asyncGetKPuzzleByDesc(\n  desc: PuzzleDescriptionString,\n  options?: { includeCenterOrbits?: boolean; includeEdgeOrbits?: boolean },\n): Promise<KPuzzle> {\n  const pgPromise = descAsyncGetPuzzleGeometry(desc, options);\n  return asyncGetKPuzzle(pgPromise, `description: ${desc}`);\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const kpuzzlePromiseFn = async () => {\n    return (cachedKPuzzle ??= asyncGetKPuzzleByDesc(desc));\n  };\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: kpuzzlePromiseFn,\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n    basePG: async () => {\n      return descAsyncGetPuzzleGeometry(desc, {\n        allMoves: false,\n        orientCenters: false,\n        addRotations: false,\n      });\n    },\n    puzzleSpecificSimplifyOptionsPromise:\n      puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn),\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n","import { Alg } from \"../../../../alg\";\nimport type { KPattern, KPuzzle, KTransformation } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientation2x2x2Idx(pattern: KPattern): number {\n  const inverse = pattern.experimentalToTransformation()!.invert();\n\n  const inverseDFL = inverse.transformationData[\"CORNERS\"];\n  return inverseDFL.permutation[6] * 3 + inverseDFL.orientationDelta[6];\n}\n\nconst puzzleOrientationCacheRaw: {\n  transformation: KTransformation;\n  alg: Alg;\n}[] = new Array<KTransformation>(24) as any;\n\nconst puzzleOrientationCacheInitialized = false;\n// We rely on the (first) caller to pass in the `KPuzzle`, so that we don't need to get our own synchronous reference.\nexport function puzzleOrientation2x2x2Cache(\n  kpuzzle: KPuzzle,\n): typeof puzzleOrientationCacheRaw {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = kpuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const idx = puzzleOrientation2x2x2Idx(transformation.toKPattern());\n          puzzleOrientationCacheRaw[idx] = {\n            transformation: transformation.invert(),\n            alg: uAlg.concat(yAlg),\n          };\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize2x2x2Orientation(pattern: KPattern): {\n  normalizedPattern: KPattern;\n  normalizationAlg: Alg;\n} {\n  const idx = puzzleOrientation2x2x2Idx(pattern);\n  const { transformation, alg } = puzzleOrientation2x2x2Cache(pattern.kpuzzle)[\n    idx\n  ];\n  return {\n    normalizedPattern: pattern.applyTransformation(transformation),\n    normalizationAlg: alg.invert(),\n  };\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs2x2x2Solved(\n  pattern: KPattern,\n  options: {\n    ignorePuzzleOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    pattern = normalize2x2x2Orientation(pattern).normalizedPattern;\n  }\n  return !!pattern.experimentalToTransformation()!.isIdentityTransformation(); // TODO: Compare to start pattern instead?\n}\n","import { KPuzzle } from \"../../kpuzzle\";\nimport { getCached } from \"../async/lazy-cached\";\nimport { cube3x3x3KPuzzleDefinition as experimentalCube3x3x3KPuzzleDefinition } from \"../implementations/dynamic/3x3x3/3x3x3.kpuzzle.json\";\nimport { experimentalIs3x3x3Solved } from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\n\nexport {\n  type AlgTransformData,\n  getPartialAppendOptionsForPuzzleSpecificSimplifyOptions,\n} from \"../PuzzleLoader\";\nexport { transformAlg } from \"../transformAlg\";\nexport { experimentalCube3x3x3KPuzzleDefinition };\n\n/** @deprecated */\nexport const experimental3x3x3KPuzzle = new KPuzzle(\n  experimentalCube3x3x3KPuzzleDefinition,\n);\nexperimentalCube3x3x3KPuzzleDefinition.experimentalIsPatternSolved =\n  experimentalIs3x3x3Solved;\n\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"../customPGPuzzleLoader\";\nexport {\n  experimentalIs2x2x2Solved,\n  normalize2x2x2Orientation as experimentalNormalize2x2x2Orientation,\n  puzzleOrientation2x2x2Cache as experimentalPuzzleOrientation2x2x2Cache,\n  puzzleOrientation2x2x2Idx as experimentalPuzzleOrientation2x2x2Idx,\n} from \"../implementations/dynamic/2x2x2/puzzle-orientation\"; // TODO: Actually dynamic\nexport {\n  experimentalIs3x3x3Solved,\n  normalize3x3x3Orientation as experimentalNormalize3x3x3Orientation,\n  puzzleOrientation3x3x3Cache as experimentalPuzzleOrientation3x3x3Cache,\n  puzzleOrientation3x3x3Idx as experimentalPuzzleOrientation3x3x3Idx,\n} from \"../implementations/dynamic/3x3x3/puzzle-orientation\"; // TODO: Actually dynamic\nexport type { KeyMapping } from \"../PuzzleLoader\";\nexport type {\n  FaceletMeshStickeringMask as ExperimentalFaceletMeshStickeringMask,\n  PieceStickeringMask as ExperimentalPieceStickeringMask,\n  StickeringMask as ExperimentalStickeringMask,\n} from \"../stickerings/mask\";\nexport {\n  getFaceletStickeringMask as experimentalGetFaceletStickeringMask,\n  getPieceStickeringMask as experimentalGetPieceStickeringMask,\n  PieceStickering as ExperimentalPieceStickering,\n} from \"../stickerings/mask\";\nexport { experimentalStickerings } from \"../stickerings/puzzle-stickerings\";\nexport const bigCubePuzzleOrientation = getCached(\n  () => import(\"../implementations/dynamic/big-cubes/big-puzzle-orientation\"),\n);\n","import { type AlgLeaf, Move, Pause } from \"../../../alg\";\n\n// See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n\nexport const cube3x3x3KeyMapping: { [key: number | string]: AlgLeaf } = {\n  KeyI: new Move(\"R\"),\n  KeyK: new Move(\"R'\"),\n  KeyW: new Move(\"B\"),\n  KeyO: new Move(\"B'\"),\n  KeyS: new Move(\"D\"),\n  KeyL: new Move(\"D'\"),\n  KeyD: new Move(\"L\"),\n  KeyE: new Move(\"L'\"),\n  KeyJ: new Move(\"U\"),\n  KeyF: new Move(\"U'\"),\n  KeyH: new Move(\"F\"),\n  KeyG: new Move(\"F'\"),\n\n  KeyC: new Move(\"l\"),\n  KeyR: new Move(\"l'\"),\n  KeyU: new Move(\"r\"),\n  KeyM: new Move(\"r'\"),\n\n  KeyX: new Move(\"d\"),\n  Comma: new Move(\"d'\"),\n\n  KeyT: new Move(\"x\"),\n  KeyY: new Move(\"x\"),\n  KeyV: new Move(\"x'\"),\n  KeyN: new Move(\"x'\"),\n  Semicolon: new Move(\"y\"),\n  KeyA: new Move(\"y'\"),\n  KeyP: new Move(\"z\"),\n  KeyQ: new Move(\"z'\"),\n\n  KeyZ: new Move(\"M'\"),\n  KeyB: new Move(\"M\"),\n  Period: new Move(\"M'\"),\n\n  Backquote: new Pause(),\n};\n","import type { PuzzleSpecificSimplifyOptions } from \"../../../alg\";\nimport { Move, QuantumMove } from \"../../../alg\";\n\nenum Axis {\n  X = \"x axis\",\n  Y = \"y axis\",\n  Z = \"z axis\",\n}\n\nenum MoveSourceType {\n  INDEXABLE_SLICE_NEAR,\n  INDEXABLE_SLICE_FAR,\n  INDEXABLE_WIDE_NEAR,\n  INDEXABLE_WIDE_FAR,\n  SPECIFIC_SLICE,\n  ROTATION,\n}\n\ninterface MoveSourceInfo {\n  family: string;\n  direction: -1 | 1;\n  type: MoveSourceType;\n  from: number;\n  to: number;\n}\n\nfunction makeSourceInfo(\n  moveStrings: string[],\n  type: MoveSourceType,\n  from: number,\n  to: number,\n): MoveSourceInfo[] {\n  const output: MoveSourceInfo[] = [];\n  for (const moveString of moveStrings) {\n    const move = Move.fromString(moveString);\n    const { family, amount: direction } = move;\n    if (![-1, 1].includes(direction)) {\n      // TODO: test iner/outer\n      // TODO: Can we move this to a test file?\n      throw new Error(\"Invalid config move\");\n    }\n    output.push({ family, direction: direction as -1 | 1, type, from, to });\n  }\n  return output;\n}\n\ninterface AxisInfo {\n  sliceDiameter: number;\n  extendsThroughEntirePuzzle: boolean;\n  moveSourceInfos: MoveSourceInfo[];\n}\n\n// TODO: wide slices\nconst axisInfos: Record<Axis, AxisInfo> = {\n  [Axis.X]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"R\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"L'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"r\", \"Rw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"l'\", \"Lw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"M'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"x\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Y]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"U\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"D'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"u\", \"Uw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"d'\", \"Dw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"E'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"y\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Z]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"F\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"B'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"f\", \"Fw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 3),\n      ...makeSourceInfo([\"b'\", \"Bw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 3),\n      ...makeSourceInfo([\"S\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"z\", \"Fv\", \"Bv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n};\n\nconst byFamily: Record<string, { axis: Axis; moveSourceInfo: MoveSourceInfo }> =\n  {};\nfor (const [axis, info] of Object.entries(axisInfos)) {\n  for (const moveSourceInfo of info.moveSourceInfos) {\n    byFamily[moveSourceInfo.family] = { axis: axis as Axis, moveSourceInfo };\n  }\n}\n\n// TODO: lazy initialization?\nconst byAxisThenType: Record<\n  Axis,\n  Partial<Record<MoveSourceType, MoveSourceInfo[]>>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Partial<Record<MoveSourceType, MoveSourceInfo[]>> = {};\n  byAxisThenType[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    (entry[moveSourceInfo.type] ??= []).push(moveSourceInfo);\n  }\n}\n\n// TODO: consolidate lookup tables?\nconst byAxisThenSpecificSlices: Record<\n  Axis,\n  Map<number, MoveSourceInfo>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Map<number, MoveSourceInfo> = new Map();\n  byAxisThenSpecificSlices[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    // We only want to use the first entry per slice index (in the unlikely case there are multiple).\n    if (!entry.get(moveSourceInfo.from)) {\n      entry.set(moveSourceInfo.from, moveSourceInfo);\n    }\n  }\n}\n\nfunction firstOfType(\n  axis: Axis,\n  moveSourceType: MoveSourceType,\n): MoveSourceInfo {\n  const entry = byAxisThenType[axis][moveSourceType]?.[0];\n  if (!entry) {\n    throw new Error(\n      `Could not find a reference move (axis: ${axis}, move source type: ${moveSourceType})`,\n    );\n  }\n  return entry;\n}\n\nconst areQuantumMovesSameAxis = (\n  quantumMove1: QuantumMove,\n  quantumMove2: QuantumMove,\n) => {\n  return (\n    byFamily[quantumMove1.family].axis === byFamily[quantumMove2.family].axis\n  );\n};\n\nfunction simplestMove(\n  axis: Axis,\n  from: number,\n  to: number,\n  directedAmount: number,\n): Move {\n  if (from + 1 === to) {\n    const sliceSpecificInfo = byAxisThenSpecificSlices[axis].get(from);\n    if (sliceSpecificInfo) {\n      return new Move(\n        new QuantumMove(sliceSpecificInfo.family),\n        directedAmount * sliceSpecificInfo.direction,\n      );\n    }\n  }\n\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  if (from === 0 && to === sliceDiameter) {\n    const moveSourceInfo = firstOfType(axis, MoveSourceType.ROTATION);\n    return new Move(\n      new QuantumMove(moveSourceInfo.family),\n      directedAmount * moveSourceInfo.direction,\n    );\n  }\n\n  // const specificSliceInfo = byAxisThenSpecificSlices[axis].get(from);\n  const far = from + to > sliceDiameter; // (from + to) / 2 > sliceDiameter / 2\n  if (far) {\n    [from, to] = [sliceDiameter - to, sliceDiameter - from];\n  }\n\n  let outerLayer: number | null = from + 1; // change to 1-indexed\n  let innerLayer: number | null = to; // already 1-indexed\n  const slice = outerLayer === innerLayer;\n  if (slice) {\n    innerLayer = null;\n  }\n\n  if (outerLayer === 1) {\n    outerLayer = null;\n  }\n  if (slice && outerLayer === 1) {\n    innerLayer = null;\n  }\n  if (!slice && innerLayer === 2) {\n    innerLayer = null;\n  }\n\n  const moveSourceType = slice\n    ? far\n      ? MoveSourceType.INDEXABLE_SLICE_FAR\n      : MoveSourceType.INDEXABLE_SLICE_NEAR\n    : far\n      ? MoveSourceType.INDEXABLE_WIDE_FAR\n      : MoveSourceType.INDEXABLE_WIDE_NEAR;\n  const moveSourceInfo = firstOfType(axis, moveSourceType);\n  return new Move(\n    new QuantumMove(moveSourceInfo.family, innerLayer, outerLayer),\n    directedAmount * moveSourceInfo.direction,\n  );\n}\n\nfunction simplifySameAxisMoves(\n  moves: Move[],\n  quantumMod: boolean = true, // TODO\n): Move[] {\n  if (moves.length === 0) {\n    // TODO: can we use the type system to avoid this?\n    return [];\n  }\n\n  const axis: Axis = byFamily[moves[0].family].axis;\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  const sliceDeltas = new Map<number, number>();\n  let lastCandidateRange: {\n    suffixLength: number;\n    sliceDeltas: Map<number, number>;\n  } | null = null;\n\n  function adjustValue(idx: number, relativeDelta: number) {\n    let newDelta = (sliceDeltas.get(idx) ?? 0) + relativeDelta;\n    if (quantumMod) {\n      newDelta = (newDelta % 4) + (5 % 4) - 1; // TODO: Use a passed-in `modMove`?\n    }\n    if (newDelta === 0) {\n      sliceDeltas.delete(idx);\n    } else {\n      sliceDeltas.set(idx, newDelta);\n    }\n  }\n  // TODO: go as far as possible instead of trying to take all moves, e.g. simplify U y y' to U.\n  let suffixLength = 0;\n  // TODO: Reverse iterator?\n  for (const move of Array.from(moves).reverse()) {\n    suffixLength++;\n    const { moveSourceInfo } = byFamily[move.family];\n    const directedAmount = move.amount * moveSourceInfo.direction;\n    // console.log({ directedAmount });\n    switch (moveSourceInfo.type) {\n      case MoveSourceType.INDEXABLE_SLICE_NEAR: {\n        // We convert to zero-indexing\n        const idx = (move.innerLayer ?? 1) - 1;\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_SLICE_FAR: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        const idx = sliceDiameter - (move.innerLayer ?? 1);\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_NEAR: {\n        adjustValue((move.outerLayer ?? 1) - 1, directedAmount);\n        adjustValue(move.innerLayer ?? 2, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_FAR: {\n        adjustValue(sliceDiameter - (move.innerLayer ?? 2), directedAmount);\n        adjustValue(\n          sliceDiameter - ((move.outerLayer ?? 1) - 1),\n          -directedAmount,\n        );\n        break;\n      }\n      case MoveSourceType.SPECIFIC_SLICE: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        adjustValue(moveSourceInfo.from, directedAmount);\n        adjustValue(moveSourceInfo.to, -directedAmount);\n        break;\n      }\n      case MoveSourceType.ROTATION: {\n        adjustValue(0, directedAmount);\n        adjustValue(sliceDiameter, -directedAmount);\n        break;\n      }\n    }\n    if ([0, 2].includes(sliceDeltas.size)) {\n      lastCandidateRange = { suffixLength, sliceDeltas: new Map(sliceDeltas) };\n    }\n  }\n  if (sliceDeltas.size === 0) {\n    return [];\n  }\n  // TODO: handle this check in the destructuring assignment?\n  if (!lastCandidateRange) {\n    return moves;\n  }\n  let [from, to] = lastCandidateRange.sliceDeltas.keys();\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n  const directedAmount = lastCandidateRange.sliceDeltas.get(from)!;\n  // TODO: Handle empty move\n  return [\n    ...moves.slice(0, -lastCandidateRange.suffixLength),\n    ...(directedAmount !== 0\n      ? [simplestMove(axis, from, to, directedAmount)]\n      : []),\n  ];\n}\n\nexport const puzzleSpecificSimplifyOptions333: PuzzleSpecificSimplifyOptions = {\n  quantumMoveOrder: () => 4,\n  // doQuantumMovesCommute: areQuantumMovesSameAxis,\n  axis: { areQuantumMovesSameAxis, simplifySameAxisMoves },\n};\n","// Include 3x3x3 in the main bundle for better performance.\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport { experimental3x3x3KPuzzle } from \"../../cubing-private\";\nimport type { AlgTransformData, PuzzleLoader } from \"../../PuzzleLoader\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../../stickerings/cube-like-stickerings\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport { cube3x3x3KeyMapping } from \"./cube3x3x3KeyMapping\";\nimport { puzzleSpecificSimplifyOptions333 } from \"./puzzle-specific-simplifications\";\n\nexport const cubeMirrorTransforms: AlgTransformData = {\n  \" Mirror (M)\": {\n    replaceMovesByFamily: {\n      L: \"R\",\n      R: \"L\",\n      l: \"r\",\n      r: \"l\",\n      Lw: \"Rw\",\n      Rw: \"Lw\",\n      Lv: \"Rv\",\n      Rv: \"Lv\",\n    },\n    invertExceptByFamily: new Set([\"x\", \"M\", \"m\"]),\n  },\n  \" Mirror (S)\": {\n    replaceMovesByFamily: {\n      F: \"B\",\n      B: \"F\",\n      f: \"b\",\n      b: \"f\",\n      Fw: \"Bw\",\n      Bw: \"Fw\",\n      Fv: \"Bv\",\n      Bv: \"Fv\",\n    },\n    invertExceptByFamily: new Set([\"z\", \"S\", \"s\"]),\n  },\n  \" Mirror (E)\": {\n    replaceMovesByFamily: {\n      U: \"D\",\n      D: \"U\",\n      u: \"d\",\n      d: \"u\",\n      Uw: \"Dw\",\n      Dw: \"Uw\",\n      Uv: \"Dv\",\n      Dv: \"Uv\",\n    },\n    invertExceptByFamily: new Set([\"y\", \"E\", \"e\"]),\n  },\n};\n\n/** @category Specific Puzzles */\nexport const cube3x3x3 = {\n  id: \"3x3x3\",\n  fullName: \"333 Cube\",\n  inventedBy: [\"Ern Rubik\"],\n  inventionYear: 1974, // https://en.wikipedia.org/wiki/Rubik%27s_Cube#Conception_and_development\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3SVG;\n  }),\n  llSVG: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3LLSVG;\n  }),\n  llFaceSVG: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3LLFaceSVG;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube3x3x3, stickering),\n  stickerings: () => cubeLikeStickeringList(\"3x3x3\"),\n  puzzleSpecificSimplifyOptions: puzzleSpecificSimplifyOptions333,\n  keyMapping: async () => cube3x3x3KeyMapping, // TODO: async loading\n  algTransformData: cubeMirrorTransforms,\n} satisfies PuzzleLoader;\n","import type { PuzzleID } from \"../twisty\";\n\ninterface EventInfo {\n  puzzleID: PuzzleID;\n  eventName: string;\n  /** Whether/how scrambles are implemented in `randomScrambleForEvent()` in this version of `cubing.js` */\n  scramblesImplemented: null | \"random-state\" | \"random-moves\";\n}\n\nexport const wcaEvents: Record<string, EventInfo> = {\n  \"333\": {\n    puzzleID: \"3x3x3\",\n    eventName: \"3x3x3 Cube\",\n    scramblesImplemented: \"random-state\",\n  },\n  \"222\": {\n    puzzleID: \"2x2x2\",\n    eventName: \"2x2x2 Cube\",\n    scramblesImplemented: \"random-state\",\n  },\n  \"444\": {\n    puzzleID: \"4x4x4\",\n    eventName: \"4x4x4 Cube\",\n    scramblesImplemented: \"random-state\",\n  },\n  \"555\": {\n    puzzleID: \"5x5x5\",\n    eventName: \"5x5x5 Cube\",\n    scramblesImplemented: \"random-moves\",\n  },\n  \"666\": {\n    puzzleID: \"6x6x6\",\n    eventName: \"6x6x6 Cube\",\n    scramblesImplemented: \"random-moves\",\n  },\n  \"777\": {\n    puzzleID: \"7x7x7\",\n    eventName: \"7x7x7 Cube\",\n    scramblesImplemented: \"random-moves\",\n  },\n  \"333bf\": {\n    puzzleID: \"3x3x3\",\n    eventName: \"3x3x3 Blindfolded\",\n    scramblesImplemented: \"random-state\",\n  },\n  \"333fm\": {\n    puzzleID: \"3x3x3\",\n    eventName: \"3x3x3 Fewest Moves\",\n    scramblesImplemented: \"random-state\",\n  },\n  \"333oh\": {\n    puzzleID: \"3x3x3\",\n    eventName: \"3x3x3 One-Handed\",\n    scramblesImplemented: \"random-state\",\n  },\n  clock: {\n    puzzleID: \"clock\",\n    eventName: \"Clock\",\n    scramblesImplemented: \"random-state\",\n  },\n  minx: {\n    puzzleID: \"megaminx\",\n    eventName: \"Megaminx\",\n    scramblesImplemented: \"random-moves\",\n  },\n  pyram: {\n    puzzleID: \"pyraminx\",\n    eventName: \"Pyraminx\",\n    scramblesImplemented: \"random-state\",\n  },\n  skewb: {\n    puzzleID: \"skewb\",\n    eventName: \"Skewb\",\n    scramblesImplemented: \"random-state\",\n  },\n  sq1: {\n    puzzleID: \"square1\",\n    eventName: \"Square-1\",\n    scramblesImplemented: \"random-state\",\n  },\n  \"444bf\": {\n    puzzleID: \"4x4x4\",\n    eventName: \"4x4x4 Blindfolded\",\n    scramblesImplemented: \"random-state\",\n  },\n  \"555bf\": {\n    puzzleID: \"5x5x5\",\n    eventName: \"5x5x5 Blindfolded\",\n    scramblesImplemented: \"random-moves\",\n  },\n  \"333mbf\": {\n    puzzleID: \"3x3x3\",\n    eventName: \"3x3x3 Multi-Blind\",\n    scramblesImplemented: \"random-state\",\n  },\n};\n\n/** @category Event Info */\nexport function wcaEventInfo(event: string): EventInfo | null {\n  return wcaEvents[event] ?? null;\n}\n\nexport const twizzleEvents: Record<string, EventInfo> = {\n  ...wcaEvents,\n  fto: {\n    puzzleID: \"fto\",\n    eventName: \"Face-Turning Octahedron\",\n    scramblesImplemented: \"random-state\",\n  },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\",\n    scramblesImplemented: \"random-state\",\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\",\n    scramblesImplemented: \"random-state\",\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\",\n    scramblesImplemented: \"random-state\",\n  },\n  baby_fto: {\n    puzzleID: \"baby_fto\",\n    eventName: \"Baby FTO\",\n    scramblesImplemented: \"random-state\",\n  },\n  loopover: {\n    puzzleID: \"loopover\",\n    eventName: \"Loopover\",\n    scramblesImplemented: null,\n  },\n};\n\n/** @category Event Info */\nexport function eventInfo(event: string): EventInfo | null {\n  return twizzleEvents[event] ?? null;\n}\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { experimentalIs2x2x2Solved } from \"../../../puzzles/cubing-private\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../../stickerings/cube-like-stickerings\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport { cubeMirrorTransforms } from \"../3x3x3\";\n\n/** @category Specific Puzzles */\nexport const cube2x2x2: PuzzleLoader = {\n  id: \"2x2x2\",\n  fullName: \"222 Cube\",\n  kpuzzle: getCached(async () => {\n    const kpuzzle = new KPuzzle(\n      (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n        .cube2x2x2JSON,\n    );\n    kpuzzle.definition.experimentalIsPatternSolved = experimentalIs2x2x2Solved;\n    return kpuzzle;\n  }),\n  svg: async () =>\n    (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .cube2x2x2SVG,\n  llSVG: getCached(\n    async () =>\n      (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n        .cube2x2x2LLSVG,\n  ),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube2x2x2, stickering),\n  stickerings: () =>\n    cubeLikeStickeringList(\"2x2x2\", { use3x3x3Fallbacks: true }),\n  algTransformData: cubeMirrorTransforms,\n};\n","import { type AlgLeaf, Move } from \"../../../alg\";\nimport { cube3x3x3KeyMapping } from \"../3x3x3/cube3x3x3KeyMapping\";\n\n// See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n\n// TODO: place this definition in a more shared location.\nexport const cube4x4x4And5x5x5KeyMapping: { [key: number | string]: AlgLeaf } =\n  {\n    ...cube3x3x3KeyMapping,\n    KeyZ: new Move(\"m'\"),\n    KeyB: new Move(\"m\"),\n    Period: new Move(\"m'\"),\n  };\n","import { CubePGPuzzleLoader, PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport { bigCubePuzzleOrientation } from \"../../cubing-private\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport { cube4x4x4And5x5x5KeyMapping } from \"./cube4x4x4And5x5x5KeyMapping\";\n\nconst cube4x4x4: PuzzleLoader = new CubePGPuzzleLoader({\n  id: \"4x4x4\",\n  fullName: \"444 Cube\",\n  inventedBy: [\"Peter Sebestny\"],\n  inventionYear: 1981,\n});\n\ncube4x4x4.llSVG = getCached(async () => {\n  return (await import(\"../dynamic/4x4x4/puzzles-dynamic-4x4x4\"))\n    .cube4x4x4LLSVG;\n});\ncube4x4x4.keyMapping = async () => cube4x4x4And5x5x5KeyMapping; // TODO: async loading\n\ncube4x4x4.kpuzzle = getCached(async () => {\n  const kpuzzle = await PGPuzzleLoader.prototype.kpuzzle.call(cube4x4x4);\n  // TODO: pass up an option to do this instead.\n  kpuzzle.definition.defaultPattern[\"CENTERS\"].pieces = [\n    // U\n    0, 0, 0, 0,\n    // L\n    4, 4, 4, 4,\n    // F\n    8, 8, 8, 8,\n    // R\n    12, 12, 12, 12,\n    // B\n    16, 16, 16, 16,\n    // D\n    20, 20, 20, 20,\n  ];\n  const { experimentalIsBigCubeSolved } = await bigCubePuzzleOrientation();\n  kpuzzle.definition.experimentalIsPatternSolved = experimentalIsBigCubeSolved;\n  return kpuzzle;\n});\n\nexport { cube4x4x4 };\n","import { CubePGPuzzleLoader, PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport { bigCubePuzzleOrientation } from \"../../cubing-private\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport { cube4x4x4And5x5x5KeyMapping } from \"../4x4x4/cube4x4x4And5x5x5KeyMapping\";\n\nconst cube5x5x5: PuzzleLoader = new CubePGPuzzleLoader({\n  id: \"5x5x5\",\n  fullName: \"555 Cube\",\n  inventedBy: [\"Udo Krell\"],\n  inventionYear: 1981,\n});\n\ncube5x5x5.keyMapping = async () => cube4x4x4And5x5x5KeyMapping; // TODO: async loading\n\ncube5x5x5.kpuzzle = getCached(async () => {\n  const kpuzzle = await PGPuzzleLoader.prototype.kpuzzle.call(cube5x5x5);\n\n  const speffzDistinguishableCenters = [\n    // U\n    0, 0, 0, 0,\n    // L\n    4, 4, 4, 4,\n    // F\n    8, 8, 8, 8,\n    // R\n    12, 12, 12, 12,\n    // B\n    16, 16, 16, 16,\n    // D\n    20, 20, 20, 20,\n  ];\n  // TODO: pass up an option to do this instead.\n  kpuzzle.definition.defaultPattern[\"CENTERS\"].pieces =\n    speffzDistinguishableCenters;\n  kpuzzle.definition.defaultPattern[\"CENTERS2\"].pieces =\n    speffzDistinguishableCenters;\n  kpuzzle.definition.defaultPattern[\"CENTERS3\"].orientationMod = new Array(\n    6,\n  ).fill(1);\n  const { experimentalIsBigCubeSolved } = await bigCubePuzzleOrientation();\n  kpuzzle.definition.experimentalIsPatternSolved = experimentalIsBigCubeSolved;\n  return kpuzzle;\n});\n\nexport { cube5x5x5 };\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  type PieceSet,\n  PieceStickering,\n  PuzzleStickering,\n  StickeringManager,\n  type StickeringMask,\n} from \"./mask\";\n\nexport async function ftoStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const experimentalFTO_FC = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = (): PieceSet =>\n    m.or([\n      experimentalFTO_F2T(),\n      m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))]),\n    ]);\n  const experimentalFTO_L2C = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"U\"), m.move(\"F\")]),\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n  const experimentalFTO_LBT = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_FC()),\n        PieceStickering.Ignored,\n      );\n      break;\n    }\n    case \"experimental-fto-f2t\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_F2T()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_FC(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-sc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_SC()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_F2T(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-l2c\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_L2C()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_SC(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-lbt\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_LBT()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_L2C(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-l3t\": {\n      puzzleStickering.set(experimentalFTO_LBT(), PieceStickering.Dim);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function ftoStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\",\n  ];\n}\n","import { type AlgLeaf, Move, Pause } from \"../../../alg\";\n\nexport const ftoKeyMapping: { [key: number | string]: AlgLeaf } = {\n  KeyI: new Move(\"R\"),\n  KeyK: new Move(\"R'\"),\n  KeyW: new Move(\"B\"),\n  KeyO: new Move(\"B'\"),\n  KeyS: new Move(\"D\"),\n  KeyL: new Move(\"D'\"),\n  KeyD: new Move(\"L\"),\n  KeyE: new Move(\"L'\"),\n  KeyJ: new Move(\"U\"),\n  KeyF: new Move(\"U'\"),\n  KeyH: new Move(\"F\"),\n  KeyG: new Move(\"F'\"),\n\n  KeyN: new Move(\"Rv'\"),\n  KeyC: new Move(\"l\"),\n  KeyR: new Move(\"l'\"),\n  KeyU: new Move(\"r\"),\n  KeyM: new Move(\"r'\"),\n\n  KeyX: new Move(\"d\"),\n  Comma: new Move(\"d'\"),\n\n  KeyT: new Move(\"Lv'\"),\n  KeyY: new Move(\"Rv\"),\n  KeyV: new Move(\"Lv\"),\n  Semicolon: new Move(\"Uv\"),\n  KeyA: new Move(\"Uv'\"),\n  KeyP: new Move(\"BR'\"),\n  KeyQ: new Move(\"BL\"),\n\n  KeyZ: new Move(\"BL'\"),\n  KeyB: new Move(\"T\"),\n  Period: new Move(\"BR\"),\n\n  Backquote: new Pause(),\n};\n","import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport { ftoStickering } from \"../../stickerings/fto-stickerings\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport { ftoKeyMapping } from \"../fto/ftoKeyMapping\";\n\nclass BabyFTOPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"skewb diamond\",\n      id: \"baby_fto\",\n      fullName: \"Baby FTO\",\n      inventedBy: [\"Uwe Mffert\"],\n      // inventionYear: TODO\n      setOrientationModTo1ForPiecesOfOrbits: [\"CENTERS\"],\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return ftoStickering(this, stickering);\n  }\n  override svg = getCached(async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .babyFTOSVG;\n  });\n  keyMapping = async () => ftoKeyMapping;\n}\n\nexport const baby_fto = new BabyFTOPuzzleLoader();\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const clock: PuzzleLoader = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988, // Patent application year: https://www.jaapsch.net/puzzles/patents/us4869506.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .clockJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .clockSVG;\n  }),\n};\n","import type { AlgTransformData } from \"cubing/puzzles/cubing-private\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport {\n  ftoStickering,\n  ftoStickerings,\n} from \"../../stickerings/fto-stickerings\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport { ftoKeyMapping } from \"./ftoKeyMapping\";\n\nclass FTOPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"], // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n      inventionYear: 1983, // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return ftoStickering(this, stickering);\n  }\n  stickerings = ftoStickerings;\n  override svg = getCached(async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .ftoSVG;\n  });\n  keyMapping = async () => ftoKeyMapping;\n  algTransformData: AlgTransformData = {\n    \" Mirror (x)\": {\n      replaceMovesByFamily: {\n        L: \"R\",\n        R: \"L\",\n        l: \"r\",\n        r: \"l\",\n        Lw: \"Rw\",\n        Rw: \"Lw\",\n        Lv: \"Rv\",\n        Rv: \"Lv\",\n        BL: \"BR\",\n        BR: \"BL\",\n        bl: \"br\",\n        br: \"bl\",\n        BLw: \"BRw\",\n        BRw: \"BLw\",\n        BLv: \"BRv\",\n        BRv: \"BLv\",\n      },\n      invertExceptByFamily: new Set([\"x\"]),\n    },\n  };\n}\n\nexport const fto = new FTOPuzzleLoader();\n","import type { PuzzleLoader } from \"../..\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport {\n  asyncGetKPuzzleByDesc,\n  descAsyncGetPuzzleGeometry,\n} from \"../../customPGPuzzleLoader\";\n\nconst KILOMINX_PUZZLE_DESCRIPTION = \"d f 0.56\";\n\n// TODO: Make this consistent with Megaminx corners\nexport const kilominx: PuzzleLoader = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(() =>\n    asyncGetKPuzzleByDesc(KILOMINX_PUZZLE_DESCRIPTION, {\n      includeCenterOrbits: false,\n      includeEdgeOrbits: false,\n    }),\n  ),\n  pg: () =>\n    descAsyncGetPuzzleGeometry(KILOMINX_PUZZLE_DESCRIPTION, {\n      includeCenterOrbits: false,\n      includeEdgeOrbits: false,\n    }),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .kilominxSVG;\n  }),\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const loopover: PuzzleLoader = {\n  id: \"loopover\",\n  fullName: \"Loopover\",\n  inventedBy: [\"Cary Huang\"],\n  inventionYear: 2018,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n          .loopoverJSON,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .loopoverSVG;\n  },\n};\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport { from } from \"../../vendor/mit/p-lazy/p-lazy\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"./cube-like-stickerings\";\nimport type { StickeringMask } from \"./mask\";\n\n// TODO: cache calculations?\nexport async function megaminxStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  // TODO: optimize lookup instead of looking through a list\n  if ((await megaminxStickerings()).includes(stickering)) {\n    return cubeLikeStickeringMask(puzzleLoader, stickering);\n  }\n  console.warn(\n    `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n  );\n  return cubeLikeStickeringMask(puzzleLoader, \"full\");\n}\n\nconst megaminxStickeringListPromise: Promise<string[]> = from(() =>\n  cubeLikeStickeringList(\"megaminx\"),\n);\nexport function megaminxStickerings(): Promise<string[]> {\n  return megaminxStickeringListPromise;\n}\n","import { type AlgLeaf, Move, Pause } from \"../../../alg\";\n\n// See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n\nexport const megaminxKeyMapping: { [key: number | string]: AlgLeaf } = {\n  KeyI: new Move(\"R\"),\n  KeyK: new Move(\"R'\"),\n  KeyW: new Move(\"B\"),\n  KeyO: new Move(\"B'\"),\n  KeyS: new Move(\"FR\"),\n  KeyL: new Move(\"FR'\"),\n  KeyD: new Move(\"L\"),\n  KeyE: new Move(\"L'\"),\n  KeyJ: new Move(\"U\"),\n  KeyF: new Move(\"U'\"),\n  KeyH: new Move(\"F\"),\n  KeyG: new Move(\"F'\"),\n\n  KeyC: new Move(\"Lw\"),\n  KeyR: new Move(\"Lw'\"),\n  KeyU: new Move(\"Rw\"),\n  KeyM: new Move(\"Rw'\"),\n\n  KeyX: new Move(\"d\"),\n  Comma: new Move(\"d'\"),\n\n  KeyT: new Move(\"Rv\"),\n  KeyY: new Move(\"Rv\"),\n  KeyV: new Move(\"Rv'\"),\n  KeyN: new Move(\"Rv'\"),\n  Semicolon: new Move(\"y\"),\n  KeyA: new Move(\"y'\"),\n  KeyP: new Move(\"z\"),\n  KeyQ: new Move(\"z'\"),\n\n  KeyZ: new Move(\"2L'\"),\n  KeyB: new Move(\"2R\"),\n  Period: new Move(\"2R'\"),\n\n  Backquote: new Pause(),\n};\n","import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  megaminxStickeringMask,\n  megaminxStickerings,\n} from \"../../stickerings/megaminx-stickerings\";\nimport { megaminxKeyMapping } from \"./megaminxKeyMapping\";\n\nclass MegaminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      // Too many simultaneous inventors to name.\n      inventionYear: 1981, // Earliest date from https://www.jaapsch.net/puzzles/megaminx.htm\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return megaminxStickeringMask(this, stickering);\n  }\n  stickerings = megaminxStickerings;\n\n  llSVG = getCached(async () => {\n    return (await import(\"../dynamic/megaminx/puzzles-dynamic-megaminx\"))\n      .megaminxLLSVG;\n  });\n\n  keyMapping = async () => megaminxKeyMapping; // TODO: async loading\n}\n\nexport const megaminx = new MegaminxPuzzleLoader();\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const melindas2x2x2x2: PuzzleLoader = {\n  id: \"melindas2x2x2x2\",\n  fullName: \"Melinda's 2222\",\n  inventedBy: [\"Melinda Green\"],\n  // inventionYear: 20__, // TODO\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .melindas2x2x2x2OrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .melindas2x2x2x2OrbitSVG;\n  }),\n};\n","import type { AlgTransformData } from \"cubing/puzzles/cubing-private\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\nclass PyraminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"],\n    });\n  }\n  override svg = getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .pyraminxSVG;\n  });\n  algTransformData: AlgTransformData = {\n    \" Mirror (x)\": {\n      replaceMovesByFamily: {\n        L: \"R\",\n        R: \"L\",\n        l: \"r\",\n        r: \"l\",\n        Lw: \"Rw\",\n        Rw: \"Lw\",\n        Lv: \"Rv\",\n        Rv: \"Lv\",\n      },\n      invertExceptByFamily: new Set([]),\n    },\n  };\n}\n\nexport const pyraminx = new PyraminxPuzzleLoader();\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const rediCube: PuzzleLoader = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  // Announced 2009-07-21: https://www.youtube.com/watch?v=cjfMzA1u3vM\n  // https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1520\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n          .rediCubeJSON,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .rediCubeSVG;\n  },\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const square1: PuzzleLoader = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hrel\", \"Vojtech Kopsk\"],\n  inventionYear: 1990, // Czech patent application year: http://spisy.upv.cz/Patents/FullDocuments/277/277266.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .sq1HyperOrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .sq1HyperOrbitSVG;\n  }),\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const tri_quad: PuzzleLoader = {\n  id: \"tri_quad\",\n  fullName: \"TriQuad\",\n  inventedBy: [\"Bram Cohen\", \"Carl Hoff\"],\n  inventionYear: 2018, // https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=6809\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .triQuadJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .triQuadSVG;\n  }),\n};\n","export { eventInfo, twizzleEvents, wcaEventInfo, wcaEvents } from \"./events\";\nexport { cube2x2x2, cube3x3x3 };\nexport type { PuzzleLoader };\n\nimport { CubePGPuzzleLoader, PGPuzzleLoader } from \"./async/async-pg3d\";\nimport { cube2x2x2 } from \"./implementations/2x2x2\";\nimport { cube3x3x3 } from \"./implementations/3x3x3\";\nimport { cube4x4x4 } from \"./implementations/4x4x4\";\nimport { cube5x5x5 } from \"./implementations/5x5x5\";\nimport { baby_fto } from \"./implementations/baby_fto\";\nimport { clock } from \"./implementations/clock\";\nimport { fto } from \"./implementations/fto\";\nimport { kilominx } from \"./implementations/kilominx\";\nimport { loopover } from \"./implementations/loopover\";\nimport { megaminx } from \"./implementations/megaminx\";\nimport { melindas2x2x2x2 } from \"./implementations/melindas2x2x2x2\";\nimport { pyraminx } from \"./implementations/pyraminx\";\nimport { rediCube } from \"./implementations/redi-cube\";\nimport { square1 } from \"./implementations/square1\";\nimport { tri_quad } from \"./implementations/tri_quad\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n/** @category All Puzzles */\nexport const puzzles: Record<string, PuzzleLoader> = {\n  /******** Start of WCA Puzzles *******/\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": cube4x4x4,\n  \"5x5x5\": cube5x5x5,\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"666 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"777 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"404040 Cube\",\n  }),\n  // 3x3x3 Blindfolded\n  // 3x3x3 Fewest Moves\n  // 3x3x3 One-Handed\n  clock,\n  megaminx: megaminx,\n  pyraminx,\n  skewb: new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"], // https://www.jaapsch.net/puzzles/skewb.htm\n    // inventionYear: 1982, // 1982 is actually the year of Hofstadter's column.\n  }),\n  square1,\n  // 4x4x4 Blindfolded\n  // 5x5x5 Blindfolded\n  /******** End of WCA puzzles ********/\n  fto,\n  gigaminx: new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006, // Earliest date from https://www.twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1475\n  }),\n  master_tetraminx: new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"], // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n    inventionYear: 2002, // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n  }),\n  kilominx,\n  redi_cube: rediCube,\n  melindas2x2x2x2,\n  loopover,\n  tri_quad,\n  baby_fto,\n};\n","import type { Alg } from \"./Alg\";\nimport type { AlgLeaf, AlgNode } from \"./alg-nodes/AlgNode\";\nimport type { IterationDirection } from \"./iteration\";\nimport type { ExperimentalSerializationOptions } from \"./SerializationOptions\";\n\nlet writeAlgDebugField = false;\nexport function setAlgDebugField(debug: boolean): void {\n  writeAlgDebugField = debug;\n}\n\nexport abstract class Comparable {\n  is(c: any): boolean {\n    return this instanceof c;\n  }\n\n  as<T>(c: new (...args: any) => T): T | null {\n    return this instanceof c ? this : null;\n  }\n\n  abstract isIdentical(other: Comparable): boolean;\n}\n\nexport interface Repeatable extends Comparable {\n  experimentalExpand(\n    iterDir?: IterationDirection,\n    depth?: number,\n  ): Generator<AlgLeaf>;\n}\n\n// Common to `Alg` or `AlgNode` classes.\nexport abstract class AlgCommon<T extends Alg | AlgNode>\n  extends Comparable\n  implements Repeatable\n{\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        },\n      });\n    }\n  }\n\n  get log(): (message?: any) => void {\n    // By returning a (bound) version of `console.log`, we ensure that DevTools\n    // logs the call site instead of this function.\n    return console.log.bind(console, this, this.toString()) as (\n      message?: any,\n    ) => void;\n  }\n\n  abstract override toString(\n    experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string;\n\n  abstract invert(): T;\n\n  abstract experimentalExpand(iterDir: IterationDirection): Generator<AlgLeaf>;\n}\n","import type { ExperimentalSerializationOptions } from \"cubing/alg/SerializationOptions\";\nimport {\n  type Alg,\n  experimentalEnsureAlg,\n  type FlexibleAlgSource,\n} from \"../../Alg\";\nimport { AlgCommon, type Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Commutator extends AlgCommon<Commutator> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsCommutator = other.as(Commutator);\n    return !!(\n      otherAsCommutator?.A.isIdentical(this.A) &&\n      otherAsCommutator?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Commutator {\n    return new Commutator(this.#B, this.#A);\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      if (iterDir === IterationDirection.Forwards) {\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      } else {\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      }\n    }\n  }\n\n  toString(\n    experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    return `[${this.#A.toString(experimentalSerializationOptions)}, ${this.#B.toString(experimentalSerializationOptions)}]`;\n  }\n}\n","import type { ExperimentalSerializationOptions } from \"cubing/alg/SerializationOptions\";\nimport {\n  type Alg,\n  experimentalEnsureAlg,\n  type FlexibleAlgSource,\n} from \"../../Alg\";\nimport { AlgCommon, type Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Conjugate extends AlgCommon<Conjugate> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsConjugate = other.as(Conjugate);\n    return !!(\n      otherAsConjugate?.A.isIdentical(this.A) &&\n      otherAsConjugate?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Conjugate {\n    return new Conjugate(this.#A, this.#B.invert());\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(IterationDirection.Forwards, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(IterationDirection.Backwards, depth - 1);\n    }\n  }\n\n  toString(\n    experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    return `[${this.A.toString(experimentalSerializationOptions)}: ${this.B.toString(experimentalSerializationOptions)}]`;\n  }\n}\n","export const MAX_INT = 0x7fffffff; // 2^31-1, the max value for signed 32-bit ints.\nexport const MAX_INT_DESCRIPTION = \"2^31 - 1\";\nexport const MIN_INT = -0x80000000;\nexport const MIN_INT_DESCRIPTION = \"-2^31\";\n","import { Alg } from \"./Alg\";\nimport type { AlgNode } from \"./alg-nodes/AlgNode\";\n\n/** @category Alg */\nexport class AlgBuilder {\n  #algNodes: AlgNode[] = [];\n\n  push(u: AlgNode): void {\n    this.#algNodes.push(u);\n  }\n\n  // TODO: Allow FlexibleAlgSource?\n  /** @deprecated */\n  experimentalPushAlg(alg: Alg): void {\n    // TODO: Optimize?\n    for (const u of alg.childAlgNodes()) {\n      this.push(u);\n    }\n  }\n\n  // TODO: can we guarantee this to be fast in the permanent API?\n  experimentalNumAlgNodes(): number {\n    return this.#algNodes.length;\n  }\n\n  // can be called multiple times, even if you push alg nodes inbetween.\n  toAlg(): Alg {\n    return new Alg(this.#algNodes);\n  }\n\n  reset(): void {\n    this.#algNodes = [];\n  }\n}\n","import type { ExperimentalSerializationOptions } from \"cubing/alg/SerializationOptions\";\nimport { AlgCommon, type Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n// TODO: hash\n// TODO: this conflicts with the HTML `LineComment` class\n/** @category Alg Nodes */\nexport class LineComment extends AlgCommon<LineComment> {\n  readonly #text: string;\n\n  constructor(commentText: string) {\n    super();\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    this.#text = commentText;\n  }\n\n  get text(): string {\n    return this.#text;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsLineComment = other as LineComment;\n    return other.is(LineComment) && this.#text === otherAsLineComment.#text;\n  }\n\n  invert(): LineComment {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n\n  toString(\n    _experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    return `//${this.#text}`;\n  }\n  // toJSON(): LineCommentJSON {\n  //   return {\n  //     type: \"comment\",\n  //     text: this.#text,\n  //   };\n  // }\n}\n","import type { ExperimentalSerializationOptions } from \"cubing/alg/SerializationOptions\";\nimport { AlgCommon, type Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Newline extends AlgCommon<Newline> {\n  toString(\n    _experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    return \"\\n\";\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Newline);\n  }\n\n  invert(): Newline {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n}\n","import type { ExperimentalSerializationOptions } from \"cubing/alg/SerializationOptions\";\nimport { AlgCommon, type Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeaf } from \"../AlgNode\";\nimport type { Grouping } from \"../containers/Grouping\";\n\n/** @category Alg Nodes */\nexport class Pause extends AlgCommon<Pause> {\n  experimentalNISSGrouping?: Grouping; // TODO: tie this to the alg\n\n  toString(\n    _experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    return \".\";\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Pause);\n  }\n\n  invert(): Pause {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeaf> {\n    yield this;\n  }\n}\n","type ReportingLevel = \"none\" | \"warn\" | \"error\";\nlet currentReportingLevel = \"warn\";\n\nconst MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nlet numWarned = 0;\n\n// TODO: Avoid creating the string message if it won't be used (e.g. by taking a function?).\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw new Error(msg);\n    case \"warn\": {\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned + 1 === MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n    }\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(\n  level: ReportingLevel,\n): void {\n  currentReportingLevel = level;\n}\n\nexport const algDebugGlobals: { caretNISSNotationEnabled: boolean } = {\n  caretNISSNotationEnabled: true,\n};\n\nexport function setAlgDebug(options: {\n  caretNISSNotationEnabled?: boolean;\n}): void {\n  if (\"caretNISSNotationEnabled\" in options) {\n    algDebugGlobals.caretNISSNotationEnabled =\n      !!options.caretNISSNotationEnabled;\n  }\n}\n","import { Alg } from \"./Alg\";\nimport { AlgBuilder } from \"./AlgBuilder\";\nimport type { AlgNode } from \"./alg-nodes\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"./alg-nodes/containers/Grouping\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move, QuantumMove } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\nimport { algDebugGlobals } from \"./debug\";\n\ntype StoppingChar = \",\" | \":\" | \"]\" | \")\";\n\nfunction parseIntWithEmptyFallback<T>(n: string, emptyFallback: T): number | T {\n  return n ? parseInt(n) : emptyFallback;\n}\n\nconst AMOUNT_REGEX = /^(\\d+)?('?)/;\nconst MOVE_START_REGEX = /^[_\\dA-Za-z]/; // TODO: Handle slash\nconst QUANTUM_MOVE_REGEX = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)/;\nconst COMMENT_TEXT_REGEX = /^[^\\n]*/;\nconst SQUARE1_PAIR_START_REGEX = /^(-?\\d+), ?/; // TODO: match up with other whitespace handling?\nconst SQUARE1_PAIR_END_REGEX = /^(-?\\d+)\\)/; // TODO: match up with other whitespace handling?\n\nexport function parseAlg(s: string): Alg {\n  return new AlgParser().parseAlg(s);\n}\n\nexport function parseMove(s: string): Move {\n  return new AlgParser().parseMove(s);\n}\n\nexport function parseQuantumMove(s: string): QuantumMove {\n  return new AlgParser().parseQuantumMove(s);\n}\n\nexport const startCharIndexKey = Symbol(\"startCharIndex\");\nexport const endCharIndexKey = Symbol(\"endCharIndex\");\n\nexport interface ParserIndexed {\n  [startCharIndexKey]: number;\n  [endCharIndexKey]: number;\n}\n\nexport type Parsed<T extends Alg | AlgNode> = T & ParserIndexed;\n\n// TODO: attach to parser so the end char index can default to `this.#idx`?\nfunction addCharIndices<T extends Alg | AlgNode>(\n  t: T,\n  startCharIndex: number,\n  endCharIndex: number,\n): Parsed<T> {\n  const parsedT = t as ParserIndexed & T;\n  parsedT[startCharIndexKey] = startCharIndex;\n  parsedT[endCharIndexKey] = endCharIndex;\n  return parsedT;\n}\n\nexport function transferCharIndex<T extends Alg | AlgNode>(from: T, to: T): T {\n  if (startCharIndexKey in from) {\n    (to as Parsed<T>)[startCharIndexKey] = (from as Parsed<T>)[\n      startCharIndexKey\n    ];\n  }\n  if (endCharIndexKey in from) {\n    (to as Parsed<T>)[endCharIndexKey] = (from as Parsed<T>)[endCharIndexKey];\n  }\n  return to;\n}\n\ntype MoveSuffix = \"+\" | \"++\" | \"-\" | \"--\";\n\n// TODO: support recording string locations for moves.\nclass AlgParser {\n  #input: string = \"\";\n  #idx: number = 0;\n  #nissQueue: Grouping[] = [];\n\n  parseAlg(input: string): Parsed<Alg> {\n    this.#input = input;\n    this.#idx = 0;\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    const algNodes = Array.from(alg.childAlgNodes());\n    if (this.#nissQueue.length > 0) {\n      for (const nissGrouping of this.#nissQueue.reverse()) {\n        algNodes.push(nissGrouping);\n      }\n    }\n    const newAlg = new Alg(algNodes) as Parsed<Alg>;\n    const {\n      [startCharIndexKey]: startCharIndex,\n      [endCharIndexKey]: endCharIndex,\n    } = alg;\n    addCharIndices(newAlg, startCharIndex, endCharIndex);\n    return newAlg;\n  }\n\n  parseMove(input: string): Parsed<Move> {\n    this.#input = input;\n    this.#idx = 0;\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n\n  parseQuantumMove(input: string): QuantumMove {\n    this.#input = input;\n    this.#idx = 0;\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n\n  private mustBeAtEndOfInput() {\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n\n  private parseAlgWithStopping(stopBefore: StoppingChar[]): Parsed<Alg> {\n    let algStartIdx = this.#idx;\n    let algEndIdx = this.#idx;\n    const algBuilder = new AlgBuilder();\n\n    // We're \"crowded\" if there was not a space or newline since the last alg node.\n    let crowded = false;\n\n    const mustNotBeCrowded = (idx: number): void => {\n      if (crowded) {\n        throw new Error(\n          `Unexpected character at index ${idx}. Are you missing a space?`,\n        ); // TODO better error message\n      }\n    };\n\n    while (this.#idx < this.#input.length) {\n      const savedCharIndex = this.#idx;\n      if ((stopBefore as string[]).includes(this.#input[this.#idx])) {\n        return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n      }\n      if (this.tryConsumeNext(\" \")) {\n        crowded = false;\n        if (algBuilder.experimentalNumAlgNodes() === 0) {\n          algStartIdx = this.#idx;\n        }\n      } else if (MOVE_START_REGEX.test(this.#input[this.#idx])) {\n        mustNotBeCrowded(savedCharIndex);\n        const move = this.parseMoveImpl();\n        algBuilder.push(move);\n        crowded = true;\n        algEndIdx = this.#idx;\n      } else if (this.tryConsumeNext(\"(\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const sq1PairStartMatch = this.tryRegex(SQUARE1_PAIR_START_REGEX);\n        if (sq1PairStartMatch) {\n          const topAmountString = sq1PairStartMatch[1];\n          const savedCharIndexD = this.#idx;\n          const sq1PairEndMatch = this.parseRegex(SQUARE1_PAIR_END_REGEX);\n          const uMove = addCharIndices(\n            new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)),\n            savedCharIndex + 1,\n            savedCharIndex + 1 + topAmountString.length,\n          );\n          const dMove = addCharIndices(\n            new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])),\n            savedCharIndexD,\n            this.#idx - 1,\n          );\n          const alg = addCharIndices(\n            new Alg([uMove, dMove]),\n            savedCharIndex + 1,\n            this.#idx - 1,\n          );\n          algBuilder.push(\n            addCharIndices(new Grouping(alg), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n        } else {\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.mustConsumeNext(\")\");\n          const amount = this.parseAmount();\n          algBuilder.push(\n            addCharIndices(\n              new Grouping(alg, amount),\n              savedCharIndex,\n              this.#idx,\n            ),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n        }\n      } else if (this.tryConsumeNext(\"^\")) {\n        if (!algDebugGlobals.caretNISSNotationEnabled) {\n          throw new Error(\n            \"Alg contained a caret but caret NISS notation is not enabled.\",\n          );\n        }\n\n        this.mustConsumeNext(\"(\");\n        const alg = this.parseAlgWithStopping([\")\"]);\n        this.popNext();\n\n        const grouping = new Grouping(alg, -1);\n        const placeholder = new Pause();\n\n        grouping.experimentalNISSPlaceholder = placeholder;\n        placeholder.experimentalNISSGrouping = grouping;\n\n        this.#nissQueue.push(grouping);\n        algBuilder.push(placeholder);\n      } else if (this.tryConsumeNext(\"[\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const A = this.parseAlgWithStopping([\",\", \":\"]);\n        const separator = this.popNext();\n        const B = this.parseAlgWithStopping([\"]\"]);\n        this.mustConsumeNext(\"]\");\n        let unrepeated: Commutator | Conjugate;\n        switch (separator) {\n          case \":\": {\n            unrepeated = addCharIndices(\n              new Conjugate(A, B),\n              savedCharIndex,\n              this.#idx,\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            break;\n          }\n          case \",\": {\n            unrepeated = addCharIndices(\n              new Commutator(A, B),\n              savedCharIndex,\n              this.#idx,\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            break;\n          }\n          default:\n            throw new Error(\"unexpected parsing error\");\n        }\n        const afterClosingBracketIdx = this.#idx;\n        const amount = this.parseAmount();\n        if (amount === 1) {\n          algBuilder.push(unrepeated);\n        } else {\n          const unrepeatedAlg = addCharIndices(\n            new Alg([unrepeated]),\n            savedCharIndex,\n            afterClosingBracketIdx,\n          );\n          const grouping = addCharIndices(\n            new Grouping(unrepeatedAlg, amount),\n            savedCharIndex,\n            this.#idx,\n          );\n          algBuilder.push(grouping);\n        }\n        crowded = true;\n        algEndIdx = this.#idx;\n      } else if (this.tryConsumeNext(\"\\n\")) {\n        algBuilder.push(\n          addCharIndices(new Newline(), savedCharIndex, this.#idx),\n        );\n        crowded = false;\n        algEndIdx = this.#idx;\n      } else if (this.tryConsumeNext(\"/\")) {\n        if (this.tryConsumeNext(\"/\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const [text] = this.parseRegex(COMMENT_TEXT_REGEX);\n          algBuilder.push(\n            addCharIndices(new LineComment(text), savedCharIndex, this.#idx),\n          );\n          crowded = false;\n          algEndIdx = this.#idx;\n        } else {\n          // We allow crowding here to account for csTimer scrambles, which don't have a space between a Square-1 tuple and the following slash.\n          algBuilder.push(\n            addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n        }\n      } else if (this.tryConsumeNext(\".\")) {\n        mustNotBeCrowded(savedCharIndex);\n        algBuilder.push(addCharIndices(new Pause(), savedCharIndex, this.#idx));\n        crowded = true;\n        algEndIdx = this.#idx;\n      } else {\n        throw new Error(`Unexpected character: ${this.popNext()}`);\n      }\n    }\n\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n\n  private parseQuantumMoveImpl(): QuantumMove {\n    const [, , , outerLayerStr, innerLayerStr, family] =\n      this.parseRegex(QUANTUM_MOVE_REGEX);\n\n    return new QuantumMove(\n      family,\n      parseIntWithEmptyFallback(innerLayerStr, undefined),\n      parseIntWithEmptyFallback(outerLayerStr, undefined),\n    );\n  }\n\n  private parseMoveImpl(): Parsed<Move> {\n    const savedCharIndex = this.#idx;\n\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx);\n    }\n\n    let quantumMove = this.parseQuantumMoveImpl();\n    // Only `hadEmptyAbsAmount` is `const`.\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        // TODO: Handle 1 vs. null\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount other than 1.\",\n        );\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount written as a number.\",\n        );\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\n          \"Clock dial moves must have an amount written as a natural number followed by + or -.\",\n        );\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n        amount *= -1;\n      }\n    }\n\n    const move = addCharIndices(\n      new Move(quantumMove, amount),\n      savedCharIndex,\n      this.#idx,\n    );\n    return move;\n  }\n\n  private parseMoveSuffix(): MoveSuffix | null {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n\n  private parseAmountAndTrackEmptyAbsAmount(): [number, boolean] {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr,\n    ];\n  }\n\n  private parseAmount(): number {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return (\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1)\n    );\n  }\n\n  private parseRegex(regex: RegExp): RegExpExecArray {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\"); // TODO\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  // TOD: can we avoid this?\n  private tryRegex(regex: RegExp): RegExpExecArray | null {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  private remaining(): string {\n    return this.#input.slice(this.#idx);\n  }\n\n  private popNext(): string {\n    const next = this.#input[this.#idx];\n    this.#idx++;\n    return next;\n  }\n\n  private tryConsumeNext(expected: string): boolean {\n    if (this.#input[this.#idx] === expected) {\n      this.#idx++;\n      return true;\n    }\n    return false;\n  }\n\n  private mustConsumeNext(expected: string): string {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(\n        `expected \\`${expected}\\` while parsing, encountered ${next}`,\n      ); // TODO: be more helpful\n    }\n    return next;\n  }\n}\n","const warned = new Set<string>();\nexport function warnOnce(s: string): void {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n","import type { Repeatable } from \"../common\";\nimport { type IterationDirection, toggleDirection } from \"../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION, MIN_INT } from \"../limits\";\nimport type { AlgLeaf } from \"./AlgNode\";\n\nexport class QuantumWithAmount<Q extends Repeatable> {\n  readonly quantum: Q;\n  readonly amount: number;\n\n  constructor(quantum: Q, amount: number = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n\n    if (\n      !Number.isInteger(this.amount) ||\n      this.amount < MIN_INT ||\n      this.amount > MAX_INT\n    ) {\n      throw new Error(\n        `AlgNode amount absolute value must be a non-negative integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n  }\n\n  suffix(): string {\n    let s: string = \"\";\n    // TODO\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n\n  isIdentical(other: QuantumWithAmount<Q>): boolean {\n    return (\n      this.quantum.isIdentical(other.quantum) && this.amount === other.amount\n    );\n  }\n\n  // TODO: `Conjugate` and `Commutator` decrement `depth` inside the quantum, `Grouping` has to do it outside the quantum.\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth: number,\n  ): Generator<AlgLeaf> {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n}\n","export enum IterationDirection {\n  Forwards = 1,\n  Backwards = -1,\n}\n\nexport function toggleDirection(\n  iterationDirection: IterationDirection,\n  flip: boolean = true,\n): IterationDirection {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case IterationDirection.Forwards:\n      return IterationDirection.Backwards;\n    case IterationDirection.Backwards:\n      return IterationDirection.Forwards;\n  }\n}\n\nexport function direct<T>(\n  g: Iterable<T>,\n  iterDir: IterationDirection,\n): Iterable<T> {\n  return iterDir === IterationDirection.Backwards ? Array.from(g).reverse() : g;\n}\n\nexport function reverse<T>(g: Iterable<T>): Iterable<T> {\n  return Array.from(g).reverse();\n}\n\nexport function* directedGenerator<T>(\n  g: Generator<T>,\n  direction: IterationDirection,\n): Generator<T> {\n  direction === IterationDirection.Backwards\n    ? yield* reverseGenerator(g)\n    : yield* g;\n}\n\nexport function* reverseGenerator<T>(g: Generator<T>): Generator<T> {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n","import type { ExperimentalSerializationOptions } from \"cubing/alg/SerializationOptions\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION } from \"../../limits\";\nimport { parseMove, parseQuantumMove, transferCharIndex } from \"../../parseAlg\";\nimport { warnOnce } from \"../../warnOnce\";\nimport type { AlgLeaf } from \"../AlgNode\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\n\ninterface QuantumMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n}\n\nexport class QuantumMove extends Comparable {\n  readonly #family: string;\n  readonly #innerLayer: number | null;\n  readonly #outerLayer: number | null;\n\n  constructor(\n    family: string,\n    innerLayer?: number | null,\n    outerLayer?: number | null,\n  ) {\n    super();\n    this.#family = family;\n    this.#innerLayer = innerLayer ?? null;\n    this.#outerLayer = outerLayer ?? null;\n    Object.freeze(this);\n\n    if (\n      this.#innerLayer !== null &&\n      (!Number.isInteger(this.#innerLayer) ||\n        this.#innerLayer < 1 ||\n        this.#innerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      (!Number.isInteger(this.#outerLayer) ||\n        this.#outerLayer < 1 ||\n        this.#outerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      this.#innerLayer !== null &&\n      this.#innerLayer <= this.#outerLayer\n    ) {\n      throw new Error(\n        \"QuantumMove outer layer must be smaller than inner layer.\",\n      );\n    }\n\n    if (this.#outerLayer !== null && this.#innerLayer === null) {\n      throw new Error(\n        \"QuantumMove with an outer layer must have an inner layer\",\n      ); // TODO: test\n    }\n  }\n\n  static fromString(s: string): QuantumMove {\n    return parseQuantumMove(s);\n  }\n\n  // TODO: `modify`?\n  modified(modifications: QuantumMoveModifications): QuantumMove {\n    return new QuantumMove(\n      modifications.family ?? this.#family,\n      modifications.innerLayer ?? this.#innerLayer,\n      modifications.outerLayer ?? this.#outerLayer,\n    );\n  }\n\n  isIdentical(other: QuantumMove): boolean {\n    const otherAsQuantumMove = other;\n    return (\n      other.is(QuantumMove) &&\n      this.#family === otherAsQuantumMove.#family &&\n      this.#innerLayer === otherAsQuantumMove.#innerLayer &&\n      this.#outerLayer === otherAsQuantumMove.#outerLayer\n    );\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get family(): string {\n    return this.#family;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get outerLayer(): number | null {\n    return this.#outerLayer;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get innerLayer(): number | null {\n    return this.#innerLayer;\n  }\n\n  experimentalExpand(): Generator<AlgLeaf> {\n    throw new Error(\n      \"experimentalExpand() cannot be called on a `QuantumMove` directly.\",\n    );\n  }\n\n  override toString(\n    _experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    let s = this.#family;\n    if (this.#innerLayer !== null) {\n      s = String(this.#innerLayer) + s;\n      if (this.#outerLayer !== null) {\n        s = `${String(this.#outerLayer)}-${s}`;\n      }\n    }\n    return s;\n  }\n}\n\nexport interface MoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\n/** @category Alg Nodes */\nexport class Move extends AlgCommon<Move> {\n  // @ts-ignore False positive due to the `return` in the constructor.\n  readonly #quantumWithAmount: QuantumWithAmount<QuantumMove>;\n\n  constructor(\n    ...args: [QuantumMove] | [QuantumMove, number] | [string] | [string, number]\n  ) {\n    super();\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        this.#quantumWithAmount = new QuantumWithAmount(\n          QuantumMove.fromString(args[0]),\n          args[1],\n        );\n        return;\n      } else {\n        // biome-ignore lint/correctness/noConstructorReturn: https://github.com/rome/tools/issues/4005\n        return Move.fromString(args[0]);\n      }\n    }\n    this.#quantumWithAmount = new QuantumWithAmount<QuantumMove>(\n      args[0],\n      args[1],\n    );\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsMove = other.as(Move);\n    return (\n      !!otherAsMove &&\n      this.#quantumWithAmount.isIdentical(otherAsMove.#quantumWithAmount)\n    );\n  }\n\n  invert(): Move {\n    // TODO: handle char indices more consistently among alg nodes.\n    return transferCharIndex(\n      this,\n      new Move(\n        this.#quantumWithAmount.quantum,\n        this.#isSlash() ? this.amount : -this.amount,\n      ),\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n  ): Generator<AlgLeaf> {\n    if (iterDir === IterationDirection.Forwards) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount,\n      });\n    }\n  }\n\n  get quantum(): QuantumMove {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  // TODO: `modify`?\n  modified(modifications: MoveModifications): Move {\n    // TODO: Avoid creating a new quantum move\n    return new Move(\n      this.#quantumWithAmount.quantum.modified(modifications),\n      modifications.amount ?? this.amount,\n    );\n  }\n\n  static fromString(s: string): Move {\n    return parseMove(s);\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n\n  /** @deprecated */\n  get family(): string {\n    return this.#quantumWithAmount.quantum.family ?? undefined;\n  }\n\n  /** @deprecated */\n  get outerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.outerLayer ?? undefined;\n  }\n\n  /** @deprecated */\n  get innerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.innerLayer ?? undefined;\n  }\n\n  #cachedSlashMove: Move | undefined;\n  #isSlash(): boolean {\n    return this.isIdentical((this.#cachedSlashMove ??= new Move(\"_SLASH_\")));\n  }\n\n  toString(\n    experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    if (experimentalSerializationOptions?.notation !== \"LGN\") {\n      if (this.#isSlash()) {\n        return \"/\"; // TODO: validate no amount\n      }\n      if (this.family.endsWith(\"_PLUS_\")) {\n        return (\n          this.#quantumWithAmount.quantum.toString().slice(0, -6) +\n          Math.abs(this.amount) +\n          (this.amount < 0 ? \"-\" : \"+\")\n        ); // TODO\n      }\n      if (this.family.endsWith(\"_PLUSPLUS_\")) {\n        const absAmount = Math.abs(this.amount);\n        return (\n          this.#quantumWithAmount.quantum.toString().slice(0, -10) +\n          (absAmount === 1 ? \"\" : absAmount) +\n          (this.amount < 0 ? \"--\" : \"++\")\n        ); // TODO\n      }\n    }\n    return (\n      this.#quantumWithAmount.quantum.toString(\n        experimentalSerializationOptions,\n      ) + this.#quantumWithAmount.suffix()\n    );\n  }\n  // // TODO: Serialize as a string?\n  // toJSON(): MoveJSON {\n  //   return {\n  //     type: \"move\",\n  //     family: this.family,\n  //     innerLayer: this.innerLayer,\n  //     outerLayer: this.outerLayer,\n  //   };\n  // }\n}\n","import type { ExperimentalSerializationOptions } from \"cubing/alg/SerializationOptions\";\nimport { Alg, experimentalEnsureAlg, type FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, type Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { Commutator, Conjugate } from \"..\";\nimport type { AlgLeaf, AlgNode } from \"../AlgNode\";\nimport { Move, QuantumMove } from \"../leaves/Move\";\nimport type { Pause } from \"../leaves/Pause\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\n\n// This is a workaround for `jest`, which doesn't handle cycles of imports inside `cubing/alg`.\n// We need to lazy-initialize the reusable quantum moves for Square-1, so we create this wrapper for it.\nclass Square1TupleFormatter {\n  quantumU_SQ_: QuantumMove | null = null;\n  quantumD_SQ_: QuantumMove | null = null;\n\n  format(\n    grouping: Grouping,\n    experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string | null {\n    if (experimentalSerializationOptions?.notation === \"LGN\") {\n      return null;\n    }\n\n    if (grouping.amount !== 1) {\n      return null;\n    }\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n\n  tuple(grouping: Grouping): [moveU: Move, moveD: Move] | null {\n    if (grouping.amount !== 1) {\n      return null;\n    }\n\n    this.quantumU_SQ_ ||= new QuantumMove(\"U_SQ_\");\n    this.quantumD_SQ_ ||= new QuantumMove(\"D_SQ_\");\n\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumChildAlgNodes() === 2) {\n      const [U, D] = quantumAlg.childAlgNodes();\n      if (\n        U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) &&\n        D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)\n      ) {\n        return [U as Move, D as Move]; // TODO: can we reuse the casting from above?\n      }\n    }\n    return null;\n  }\n}\nconst square1TupleFormatterInstance = new Square1TupleFormatter();\n\nexport interface GroupingModifications {\n  alg?: Alg;\n  amount?: number;\n}\n\n/** @category Alg Nodes */\nexport class Grouping extends AlgCommon<Grouping> {\n  readonly #quantumWithAmount: QuantumWithAmount<Alg>;\n  experimentalNISSPlaceholder?: Pause; // TODO: tie this to the alg\n\n  constructor(algSource: FlexibleAlgSource, amount?: number) {\n    super();\n    const alg = experimentalEnsureAlg(algSource);\n    this.#quantumWithAmount = new QuantumWithAmount(alg, amount);\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsGrouping = other as Grouping;\n    return (\n      other.is(Grouping) &&\n      this.#quantumWithAmount.isIdentical(otherAsGrouping.#quantumWithAmount)\n    );\n  }\n\n  get alg(): Alg {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  modified(modifications: GroupingModifications): Grouping {\n    return new Grouping(\n      modifications.alg ?? this.alg,\n      modifications.amount ?? this.amount,\n    );\n  }\n\n  /** @deprecated */\n  get experimentalRepetitionSuffix(): string {\n    return this.#quantumWithAmount.suffix();\n  }\n\n  invert(): Grouping {\n    const amounts = square1TupleFormatterInstance.tuple(this);\n    if (amounts) {\n      const [moveU, moveD] = amounts;\n      return new Grouping(new Alg([moveU.invert(), moveD.invert()]));\n    }\n    return new Grouping(\n      this.#quantumWithAmount.quantum,\n      -this.#quantumWithAmount.amount,\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.#quantumWithAmount.experimentalExpand(iterDir, depth - 1);\n    }\n  }\n\n  static fromString(): Grouping {\n    throw new Error(\"unimplemented\");\n  }\n\n  #unrepeatedString(\n    experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string | null {\n    const insideString = this.#quantumWithAmount.quantum.toString(\n      experimentalSerializationOptions,\n    );\n    const iter = this.alg.childAlgNodes();\n    const { value } = iter.next() as {\n      value: AlgNode;\n      done: boolean;\n    };\n    if (iter.next().done && (value?.is(Commutator) || value?.is(Conjugate))) {\n      return insideString;\n    }\n    return `(${insideString})`;\n  }\n\n  toString(\n    experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    return (\n      square1TupleFormatterInstance.format(\n        this,\n        experimentalSerializationOptions,\n      ) ??\n      `${this.#unrepeatedString(experimentalSerializationOptions)}${this.#quantumWithAmount.suffix()}`\n    );\n  }\n\n  experimentalAsSquare1Tuple(): [moveU: Move, moveD: Move] | null {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n  // toJSON(): GroupingJSON {\n  //   return {\n  //     type: \"grouping\",\n  //     alg: this.#quanta.quantum.toJSON(),\n  //   };\n  // }\n}\n","import type { Alg } from \"./Alg\";\nimport {\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n} from \"./alg-nodes\";\n\nexport function experimentalIs(\n  v: any,\n  c:\n    | typeof Alg\n    | typeof Grouping\n    | typeof LineComment\n    | typeof Commutator\n    | typeof Conjugate\n    | typeof Move\n    | typeof Newline\n    | typeof Pause,\n): boolean {\n  return v instanceof c;\n}\nexport function experimentalIsAlgNode(v: any): boolean {\n  return (\n    experimentalIs(v, Grouping) ||\n    experimentalIs(v, LineComment) ||\n    experimentalIs(v, Commutator) ||\n    experimentalIs(v, Conjugate) ||\n    experimentalIs(v, Move) ||\n    experimentalIs(v, Newline) ||\n    experimentalIs(v, Pause)\n  );\n}\n","import type { Move, QuantumMove } from \"../alg-nodes\";\n\n// TODO: enums?\nconst DEFAULT_DIRECTIONAL = \"any-direction\";\nDEFAULT_DIRECTIONAL;\nexport type QuantumDirectionalCancellation =\n  | typeof DEFAULT_DIRECTIONAL // Cancel any moves with the same quantum.\n  | \"same-direction\" // Cancel two quantums when have non-zero amounts of the same sign (positive/negative). An amount of 0 always counts as the same direction as any other amount.\n  | \"none\";\n\n// Example input: `R7' . R6' . R5' . R6` on a cube.\nexport type ModWrap =\n  | \"none\" // R7' . R6' . R5' . R6\n  | \"gravity\" // R . R2' . R' . R2\n  | \"canonical-centered\" // R . R2 . R' . R2\n  | \"canonical-positive\" // R . R2 . R3 . R2\n  | \"preserve-sign\"; // R3' . R2' . R' . R2\n\nexport interface AppendCancelOptions {\n  directional?: QuantumDirectionalCancellation;\n  puzzleSpecificModWrap?: ModWrap; // Default depends on `directional`\n}\n\n// TODO: preserve single moves even when amount is 0?\nexport interface AppendOptions {\n  cancel?: boolean | AppendCancelOptions; // Set to `true` to use future-proof defaults.\n  // Takes precedence over the direct `puzzleSpecificSimplifyOptions` field.\n  puzzleLoader?: {\n    puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  };\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n}\n\nexport class AppendOptionsHelper {\n  constructor(private config: AppendOptions = {}) {}\n\n  cancelQuantum(): QuantumDirectionalCancellation {\n    const { cancel } = this.config;\n    if (cancel === true) {\n      return DEFAULT_DIRECTIONAL;\n    }\n    if (cancel === false) {\n      return \"none\";\n    }\n    return cancel?.directional ?? \"none\";\n  }\n\n  cancelAny() {\n    return this.config.cancel && this.cancelQuantum() !== \"none\";\n  }\n\n  cancelPuzzleSpecificModWrap(): ModWrap {\n    const { cancel } = this.config;\n    if (cancel === true || cancel === false) {\n      return \"canonical-centered\";\n    }\n    if (cancel?.puzzleSpecificModWrap) {\n      return cancel?.puzzleSpecificModWrap;\n    }\n    return cancel?.directional === \"same-direction\"\n      ? \"preserve-sign\"\n      : \"canonical-centered\";\n  }\n\n  puzzleSpecificSimplifyOptions(): PuzzleSpecificSimplifyOptions | undefined {\n    return (\n      this.config.puzzleLoader?.puzzleSpecificSimplifyOptions ??\n      this.config.puzzleSpecificSimplifyOptions\n    );\n  }\n}\n\nexport interface SimplifyOptions extends AppendOptions {\n  depth?: number | null; // TODO: test\n}\n\nexport interface PuzzleSpecificAxisSimplifyInfo {\n  // All moves on the same axis *must* commute.\n  areQuantumMovesSameAxis: (\n    quantumMove1: QuantumMove,\n    quantumMove2: QuantumMove,\n  ) => boolean;\n  simplifySameAxisMoves: (moves: Move[], quantumMod: boolean) => Move[];\n}\n\n// TODO: allow \"normal\" \"twisty\" puzzles to hardcode axis concepts without hardcoding too much in `Alg` that's not relevant to all puzzles.\nexport interface PuzzleSpecificSimplifyOptions {\n  quantumMoveOrder?: (quantumMove: QuantumMove) => number;\n  // TODO: implement cancellation for non-axis commuting moves (e.g. Megaminx: `BL R BL'`  `R`)\n  // // Commutation is not transitive. For example, on Megaminx: BR and BL both commute with F, but not with each other.\n  // doQuantumMovesCommute?: (\n  //   quantumMove1: QuantumMove,\n  //   quantumMove2: QuantumMove,\n  // ) => boolean;\n  axis?: PuzzleSpecificAxisSimplifyInfo;\n}\n","import { Alg } from \"../Alg\";\nimport type { AlgNode } from \"../alg-nodes\";\nimport type { AlgLeaf } from \"../alg-nodes/AlgNode\";\nimport { Move } from \"../alg-nodes/leaves/Move\";\nimport { type AppendOptions, AppendOptionsHelper } from \"./options\";\n\nfunction areSameDirection(direction: -1 | 1, move2: Move): boolean {\n  // This multiplication has two properties:\n  // - If either amount is 0, returns true.\n  // - Otherwise, the signs have to match.\n  return direction * Math.sign(move2.amount) >= 0;\n}\n\nexport function offsetMod(\n  x: number,\n  positiveMod: number,\n  offset: number = 0,\n): number {\n  return ((((x - offset) % positiveMod) + positiveMod) % positiveMod) + offset;\n}\n\nexport function experimentalAppendMove(\n  alg: Alg,\n  addedMove: Move,\n  options?: AppendOptions,\n): Alg {\n  const optionsHelper = new AppendOptionsHelper(options);\n\n  const outputPrefix: AlgNode[] = Array.from(alg.childAlgNodes());\n  let outputSuffix: Move[] = [addedMove];\n  function output() {\n    return new Alg([...outputPrefix, ...outputSuffix]); // TODO: What's the most efficient way to do this?\n  }\n\n  function modMove(move: Move): Move {\n    if (optionsHelper.cancelPuzzleSpecificModWrap() === \"none\") {\n      return move;\n    }\n    const quantumMoveOrder =\n      optionsHelper.puzzleSpecificSimplifyOptions()?.quantumMoveOrder;\n    if (!quantumMoveOrder) {\n      return move;\n    }\n    const mod = quantumMoveOrder(addedMove.quantum)!; // TODO: throw if `undefined`?\n    let offset: number;\n    switch (optionsHelper.cancelPuzzleSpecificModWrap()) {\n      case \"gravity\": {\n        offset = -Math.floor((mod - (move.amount < 0 ? 0 : 1)) / 2); // TODO: dedup this calculation for the most common path?\n        break;\n      }\n      case \"canonical-centered\": {\n        offset = -Math.floor((mod - 1) / 2); // TODO: dedup this calculation for the most common path?\n        break;\n      }\n      case \"canonical-positive\": {\n        offset = 0;\n        break;\n      }\n      case \"preserve-sign\": {\n        offset = move.amount < 0 ? 1 - mod : 0;\n        break;\n      }\n      default: {\n        throw new Error(\"Unknown mod wrap\");\n      }\n    }\n    const offsetAmount = offsetMod(move.amount, mod, offset);\n    return move.modified({ amount: offsetAmount });\n  }\n\n  if (optionsHelper.cancelAny()) {\n    let canCancelMoveBasedOnQuantum: (move: Move) => boolean;\n    const axis = optionsHelper.puzzleSpecificSimplifyOptions()?.axis;\n    if (axis) {\n      canCancelMoveBasedOnQuantum = (move: Move): boolean =>\n        axis.areQuantumMovesSameAxis(addedMove.quantum, move.quantum);\n    } else {\n      const newMoveQuantumString = addedMove.quantum.toString();\n      canCancelMoveBasedOnQuantum = (move: Move): boolean =>\n        move.quantum.toString() === newMoveQuantumString;\n    }\n\n    const sameDirectionOnly =\n      optionsHelper.cancelQuantum() === \"same-direction\";\n\n    const quantumDirections = new Map<string, 1 | 0 | -1>();\n    quantumDirections.set(\n      addedMove.quantum.toString(),\n      Math.sign(addedMove.amount) as -1 | 0 | 1,\n    );\n    let i: number;\n    for (i = outputPrefix.length - 1; i >= 0; i--) {\n      const move = outputPrefix[i].as(Move);\n      if (!move) {\n        break;\n      }\n      if (!canCancelMoveBasedOnQuantum(move)) {\n        break;\n      }\n      const quantumKey = move.quantum.toString();\n      if (sameDirectionOnly) {\n        const existingQuantumDirectionOnAxis =\n          quantumDirections.get(quantumKey);\n        if (\n          existingQuantumDirectionOnAxis && // Short-circuits, but that's actually okay here.\n          !areSameDirection(existingQuantumDirectionOnAxis, move)\n        ) {\n          break;\n        }\n        quantumDirections.set(quantumKey, Math.sign(move.amount) as -1 | 0 | 1);\n      }\n    }\n    const suffix = [...(outputPrefix.splice(i + 1) as Move[]), addedMove];\n\n    if (axis) {\n      // TODO: pass down quantum mod\n      outputSuffix = axis.simplifySameAxisMoves(\n        suffix,\n        optionsHelper.cancelPuzzleSpecificModWrap() !== \"none\",\n      );\n    } else {\n      const amount = suffix.reduce(\n        (sum: number, move: Move) => sum + move.amount,\n        0,\n      );\n      if (quantumDirections.size !== 1) {\n        throw new Error(\n          \"Internal error: multiple quantums when one was expected\",\n        );\n      }\n      outputSuffix = [new Move(addedMove.quantum, amount)];\n    }\n  }\n  outputSuffix = outputSuffix\n    .map((m) => modMove(m))\n    .filter((move: Move) => move.amount !== 0);\n  return output();\n}\n\nexport function experimentalAppendNode(\n  alg: Alg,\n  leaf: AlgLeaf,\n  options: AppendOptions,\n): Alg {\n  const maybeMove = leaf.as(Move);\n  if (maybeMove) {\n    return experimentalAppendMove(alg, maybeMove, options);\n  } else {\n    return new Alg([...alg.childAlgNodes(), leaf]);\n  }\n}\n","import type { Alg } from \"./Alg\";\nimport type { AlgNode } from \"./alg-nodes/AlgNode\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"./alg-nodes/containers/Grouping\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\nimport type { Comparable } from \"./common\";\n\nfunction dispatch<DataDown, DataAlgUp, DataAlgNodeUp>(\n  t: TraversalDownUp<DataDown, DataAlgUp, DataAlgNodeUp>,\n  algNode: AlgNode,\n  dataDown: DataDown,\n): DataAlgNodeUp {\n  // TODO: Can we turn this back into a `switch` or something more efficiently?\n  if (algNode.is(Grouping)) {\n    return t.traverseGrouping(algNode as Grouping, dataDown);\n  }\n  if (algNode.is(Move)) {\n    return t.traverseMove(algNode as Move, dataDown);\n  }\n  if (algNode.is(Commutator)) {\n    return t.traverseCommutator(algNode as Commutator, dataDown);\n  }\n  if (algNode.is(Conjugate)) {\n    return t.traverseConjugate(algNode as Conjugate, dataDown);\n  }\n  if (algNode.is(Pause)) {\n    return t.traversePause(algNode as Pause, dataDown);\n  }\n  if (algNode.is(Newline)) {\n    return t.traverseNewline(algNode as Newline, dataDown);\n  }\n  if (algNode.is(LineComment)) {\n    return t.traverseLineComment(algNode as LineComment, dataDown);\n  }\n  throw new Error(\"unknown AlgNode\");\n}\n\nfunction mustBeAlgNode(t: Comparable): AlgNode {\n  if (\n    t.is(Grouping) ||\n    t.is(Move) ||\n    t.is(Commutator) ||\n    t.is(Conjugate) ||\n    t.is(Pause) ||\n    t.is(Newline) ||\n    t.is(LineComment)\n  ) {\n    return t as AlgNode;\n  }\n  throw new Error(\"internal error: expected AlgNode\"); // TODO: Make more helpful, add tests\n}\n\nexport abstract class TraversalDownUp<\n  DataDown,\n  DataAlgUp,\n  DataAlgNodeUp = DataAlgUp,\n> {\n  // Immediate subclasses should overwrite this.\n  public traverseAlgNode(algNode: AlgNode, dataDown: DataDown): DataAlgNodeUp {\n    return dispatch(this, algNode, dataDown);\n  }\n\n  public traverseIntoAlgNode(algNode: AlgNode, dataDown: DataDown): AlgNode {\n    return mustBeAlgNode(this.traverseAlgNode(algNode, dataDown) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg, dataDown: DataDown): DataAlgUp;\n\n  public abstract traverseGrouping(\n    grouping: Grouping,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseMove(move: Move, dataDown: DataDown): DataAlgNodeUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traversePause(\n    pause: Pause,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n  public abstract traverseNewline(\n    newline: Newline,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseLineComment(\n    comment: LineComment,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n}\n\nexport abstract class TraversalUp<\n  DataAlgUp,\n  DataAlgNodeUp = DataAlgUp,\n> extends TraversalDownUp<undefined, DataAlgUp, DataAlgNodeUp> {\n  public override traverseAlgNode(algNode: AlgNode): DataAlgNodeUp {\n    return dispatch<unknown, DataAlgUp, DataAlgNodeUp>(\n      this,\n      algNode,\n      undefined,\n    );\n  }\n\n  public override traverseIntoAlgNode(algNode: AlgNode): AlgNode {\n    return mustBeAlgNode(this.traverseAlgNode(algNode) as any);\n  }\n\n  public abstract override traverseAlg(alg: Alg): DataAlgUp;\n  public abstract override traverseGrouping(grouping: Grouping): DataAlgNodeUp;\n  public abstract override traverseMove(move: Move): DataAlgNodeUp;\n  public abstract override traverseCommutator(\n    commutator: Commutator,\n  ): DataAlgNodeUp;\n  public abstract override traverseConjugate(\n    conjugate: Conjugate,\n  ): DataAlgNodeUp;\n  public abstract override traversePause(pause: Pause): DataAlgNodeUp;\n  public abstract override traverseNewline(newline: Newline): DataAlgNodeUp;\n  public abstract override traverseLineComment(\n    comment: LineComment,\n  ): DataAlgNodeUp;\n}\n\nexport function functionFromTraversal<\n  DataDown,\n  DataAlgUp,\n  ConstructorArgs extends unknown[],\n>(\n  traversalConstructor: {\n    new (...args: ConstructorArgs): TraversalDownUp<DataDown, DataAlgUp, any>;\n  },\n  constructorArgs?: ConstructorArgs,\n): undefined extends DataDown\n  ? (alg: Alg) => DataAlgUp\n  : (alg: Alg, v: DataDown) => DataAlgUp {\n  const instance = new traversalConstructor(\n    ...(constructorArgs ?? ([] as any)),\n  );\n  return instance.traverseAlg.bind(instance) as any;\n}\n","import { Alg } from \"../Alg\";\nimport type { AlgNode } from \"../alg-nodes/AlgNode\";\nimport { Commutator } from \"../alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"../alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"../alg-nodes/containers/Grouping\";\nimport type { LineComment } from \"../alg-nodes/leaves/LineComment\";\nimport { Move } from \"../alg-nodes/leaves/Move\";\nimport type { Newline } from \"../alg-nodes/leaves/Newline\";\nimport { Pause } from \"../alg-nodes/leaves/Pause\";\nimport { functionFromTraversal, TraversalDownUp } from \"../traversal\";\nimport { experimentalAppendNode } from \"./append\";\nimport { AppendOptionsHelper, type SimplifyOptions } from \"./options\";\n\n// TODO: Test that inverses are bijections.\nclass Simplify extends TraversalDownUp<SimplifyOptions, Generator<AlgNode>> {\n  #newPlaceholderAssociationsMap?: Map<Grouping, Pause>;\n  #newPlaceholderAssociations(): Map<Grouping, Pause> {\n    return (this.#newPlaceholderAssociationsMap ??= new Map<Grouping, Pause>());\n  }\n\n  // TODO: avoid allocations?\n  #descendOptions(options: SimplifyOptions): SimplifyOptions {\n    return {\n      ...options,\n      depth: options.depth ? options.depth - 1 : null,\n    };\n  }\n\n  // TODO: Handle\n  public *traverseAlg(alg: Alg, options: SimplifyOptions): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield* alg.childAlgNodes();\n      return;\n    }\n\n    let output: AlgNode[] = [];\n\n    const newOptions: SimplifyOptions = this.#descendOptions(options); // TODO: avoid allocations?\n    for (const algNode of alg.childAlgNodes()) {\n      for (const traversedNode of this.traverseAlgNode(algNode, newOptions)) {\n        output = Array.from(\n          experimentalAppendNode(\n            new Alg(output),\n            traversedNode,\n            newOptions,\n          ).childAlgNodes(),\n        );\n      }\n    }\n\n    // TODO: try to use `yield* output[Symbol.iterator]();`?\n    for (const newAlgNode of output) {\n      yield newAlgNode;\n    }\n  }\n\n  public *traverseGrouping(\n    grouping: Grouping,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    if (grouping.amount === 0) {\n      // TODO: Are we okay with throwing away nested comments?\n      return;\n    }\n    const newGrouping = new Grouping(\n      this.traverseAlg(grouping.alg, this.#descendOptions(options)),\n      grouping.amount,\n    );\n    if (newGrouping.alg.experimentalIsEmpty()) {\n      return;\n    }\n\n    const newPlaceholder = this.#newPlaceholderAssociations().get(grouping);\n    if (newPlaceholder) {\n      newGrouping.experimentalNISSPlaceholder = newPlaceholder;\n      newPlaceholder.experimentalNISSGrouping = newGrouping;\n    }\n\n    yield newGrouping;\n  }\n\n  public *traverseMove(\n    move: Move,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield move;\n  }\n\n  #doChildrenCommute(A: Alg, B: Alg, options: SimplifyOptions): boolean {\n    if (\n      A.experimentalNumChildAlgNodes() === 1 &&\n      B.experimentalNumChildAlgNodes() === 1\n    ) {\n      // Handle the special case where each side has been reduced to a single move.\n      const aMove = Array.from(A.childAlgNodes())[0]?.as(Move);\n      const bMove = Array.from(B.childAlgNodes())[0]?.as(Move);\n      if (!(aMove && bMove)) {\n        return false;\n      }\n      if (bMove.quantum.isIdentical(aMove.quantum)) {\n        return true;\n      }\n      const appendOptionsHelper = new AppendOptionsHelper(options); // TODO: avoid re-allocating every time.\n      if (\n        appendOptionsHelper\n          .puzzleSpecificSimplifyOptions()\n          ?.axis?.areQuantumMovesSameAxis(aMove.quantum, bMove.quantum)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public *traverseCommutator(\n    commutator: Commutator,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = this.#descendOptions(options);\n    const newCommutator = new Commutator(\n      this.traverseAlg(commutator.A, newOptions),\n      this.traverseAlg(commutator.B, newOptions),\n    );\n    if (\n      newCommutator.A.experimentalIsEmpty() ||\n      newCommutator.B.experimentalIsEmpty() ||\n      newCommutator.A.isIdentical(newCommutator.B) ||\n      newCommutator.A.isIdentical(newCommutator.B.invert()) ||\n      this.#doChildrenCommute(newCommutator.A, newCommutator.B, options)\n    ) {\n      return;\n    }\n    yield newCommutator;\n  }\n\n  public *traverseConjugate(\n    conjugate: Conjugate,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = this.#descendOptions(options);\n    const newConjugate = new Conjugate(\n      this.traverseAlg(conjugate.A, newOptions),\n      this.traverseAlg(conjugate.B, newOptions),\n    );\n    if (newConjugate.B.experimentalIsEmpty()) {\n      return;\n    }\n    if (\n      newConjugate.A.experimentalIsEmpty() ||\n      newConjugate.A.isIdentical(newConjugate.B) ||\n      newConjugate.A.isIdentical(newConjugate.B.invert()) ||\n      this.#doChildrenCommute(newConjugate.A, newConjugate.B, options)\n    ) {\n      yield* conjugate.B.childAlgNodes();\n      return;\n    }\n    yield newConjugate;\n  }\n\n  public *traversePause(\n    pause: Pause,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (pause.experimentalNISSGrouping) {\n      const newPause = new Pause();\n      this.#newPlaceholderAssociations().set(\n        pause.experimentalNISSGrouping,\n        newPause,\n      );\n      yield newPause;\n    } else {\n      yield pause;\n    }\n  }\n\n  public *traverseNewline(\n    newline: Newline,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield newline;\n  }\n\n  public *traverseLineComment(\n    comment: LineComment,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield comment;\n  }\n}\n\nexport const simplify = functionFromTraversal(Simplify);\n","// https://js.cubing.net/cubing/alg/\n\nimport { Grouping, Pause } from \"./alg-nodes\";\nimport type { AlgLeaf, AlgNode } from \"./alg-nodes/AlgNode\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { AlgCommon, type Comparable } from \"./common\";\nimport { experimentalIs, experimentalIsAlgNode } from \"./is\";\nimport { direct, IterationDirection, reverse } from \"./iteration\";\nimport { parseAlg } from \"./parseAlg\";\nimport type { ExperimentalSerializationOptions } from \"./SerializationOptions\";\nimport { type SimplifyOptions, simplify } from \"./simplify\";\nimport { warnOnce } from \"./warnOnce\";\n\nexport type FlexibleAlgSource = string | Iterable<AlgNode> | Alg;\n\n// TODO: validate\nfunction toIterable(input?: FlexibleAlgSource): Iterable<AlgNode> {\n  if (!input) {\n    return [];\n  }\n\n  if (experimentalIs(input, Alg)) {\n    return (input as Alg).childAlgNodes();\n  }\n\n  if (typeof input === \"string\") {\n    return parseAlg(input).childAlgNodes(); // TODO: something more direct?\n  }\n\n  const iter = input as Iterable<AlgNode>;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter; // TODO: avoid allocations\n  }\n\n  throw new Error(\"Invalid AlgNode\");\n}\n\n// Preserves the alg if it's already an `Alg`.\nexport function experimentalEnsureAlg(alg: FlexibleAlgSource): Alg {\n  if (experimentalIs(alg, Alg)) {\n    return alg as Alg;\n  }\n  return new Alg(alg);\n}\n\n/**\n * `Alg` is a class that encapsulates a structured alg. To create an `Alg` from a string, use:\n *\n *     new Alg(\"R U R'\"); // Convenient\n *     Alg.fromString(dynamicString); // Recommended when the string input is user-provided.\n *\n * Once you have an `Alg`, you can call methods to transform it:\n *\n *     new Alg(\"[[R: U], R U R2']\").expand().experimentalSimplify({cancel: true}).invert().log()\n *\n * To convert an `Alg` to a string, use .toString():\n *\n *     new Alg(\"R U F\").invert().toString();\n *\n * If you need to debug, you may also find it convenient to use .log():\n *\n *     if (alg.isIdentical(alg.invert())) {\n *       alg.log(\"A self-inverse!\")\n *     }\n *\n * For more information, see: {@link https://js.cubing.net/cubing/alg/}\n *\n * @category Alg\n */\nexport class Alg extends AlgCommon<Alg> {\n  // #debugString: string;\n  #algNodes: Iterable<AlgNode>; // TODO: freeze?\n  constructor(alg?: FlexibleAlgSource) {\n    super();\n    this.#algNodes = Array.from(toIterable(alg)); // TODO: can we avoid array-casting?\n    // this.#debugString = this.toString();\n\n    for (const algNode of this.#algNodes) {\n      if (!experimentalIsAlgNode(algNode)) {\n        throw new Error(\"An alg can only contain alg nodes.\");\n      }\n    }\n  }\n\n  /**\n   * Checks whether this Alg is structurally identical to another Alg. This\n   * essentially means that they are written identically apart from whitespace.\n   *\n   *     const alg1 = new Alg(\"R U L'\");\n   *     const alg2 = new Alg(\"L U' R'\").invert();\n   *     // true\n   *     alg1.isIdentical(alg2);\n   *\n   *     // false\n   *     new Alg(\"[R, U]\").isIdentical(new Alg(\"R U R' U'\"));\n   *     // true\n   *     new Alg(\"[R, U]\").expand().isIdentical(new Alg(\"R U R' U'\"));\n   *\n   * Note that .isIdentical() efficiently compares algorithms, but mainly exists\n   * to help optimize code when the structure of an algorithm hasn't changed.\n   * There are many ways to write the \"same\" alg on most puzzles, but is\n   * *highly* recommended to avoid expanding two Alg instances to compare them,\n   * since that can easily slow your program to a crawl if someone inputs an alg\n   * containing a large repetition. In general, you should use `cubing/kpuzzle`\n   * to compare if two algs have the same effect on a puzzle.\n   *\n   * Also note that parser annotations are not taken into account while comparing\n   * algs:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\")]);\n   *     // true, even though one of the algs has parser annotations\n   *     alg.isIdentical(new Alg(\"R U2\"))\n   *\n   */\n  isIdentical(other: Comparable): boolean {\n    const otherAsAlg = other as Alg;\n    if (!other.is(Alg)) {\n      return false;\n    }\n\n    // TODO: avoid converting to array\n    const l1 = Array.from(this.#algNodes);\n    const l2 = Array.from(otherAsAlg.#algNodes);\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the inverse of the given alg.\n   *\n   * Note that that this does not make any assumptions about what puzzle the alg\n   * is for. For example, U2 is its own inverse on a cube, but U2' has the same\n   * effect U3 (and not U2) on Megaminx:\n   *\n   *     // Outputs: R U2' L'\n   *     new Alg(\"L U2 R'\").invert().log();\n   */\n  invert(): Alg {\n    // TODO: Handle newLines and comments correctly\n    // TODO: Make more efficient.\n    return new Alg(reverse(Array.from(this.#algNodes).map((u) => u.invert())));\n  }\n\n  /** @deprecated Use {@link Alg.expand} instead. */\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeaf> {\n    depth ??= Infinity;\n    for (const algNode of direct(this.#algNodes, iterDir)) {\n      yield* algNode.experimentalExpand(iterDir, depth);\n    }\n  }\n\n  /**\n   * Expands all Grouping, Commutator, and Conjugate parts nested inside the\n   * alg.\n   *\n   *     // F R U R' U' F'\n   *     new Alg(\"[F: [R, U]]\").expand().log();\n   *\n   *     // F [R, U] F'\n   *     new Alg(\"[F: [R, U]]\").expand(({ depth: 1 }).log();\n   *\n   * Avoid calling this on a user-provided alg unless the user explicitly asks\n   * to see the expanded alg. Otherwise, it's easy to make your program freeze\n   * when someone passes in an alg like: (R U)10000000\n   *\n   * Generally, if you want to perform an operation on an entire alg, you'll\n   * want to use something based on the `Traversal` mechanism, like countMoves()\n   * from `cubing/notation`.\n   */\n  expand(options?: { depth?: number }): Alg {\n    return new Alg(\n      this.experimentalExpand(\n        IterationDirection.Forwards,\n        options?.depth ?? Infinity,\n      ),\n    );\n  }\n\n  /** @deprecated */\n  *experimentalLeafMoves(): Generator<Move> {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf as Move;\n      }\n    }\n  }\n\n  concat(input: FlexibleAlgSource): Alg {\n    return new Alg(\n      Array.from(this.#algNodes).concat(Array.from(toIterable(input))),\n    );\n  }\n\n  /** @deprecated */\n  experimentalIsEmpty(): boolean {\n    for (const _ of this.#algNodes) {\n      return false;\n    }\n    return true;\n  }\n\n  static fromString(s: string): Alg {\n    return parseAlg(s);\n  }\n\n  /** @deprecated */\n  units(): Generator<AlgNode> {\n    return this.childAlgNodes();\n  }\n\n  *childAlgNodes(): Generator<AlgNode> {\n    for (const algNode of this.#algNodes) {\n      yield algNode;\n    }\n  }\n\n  /** @deprecated */\n  experimentalNumUnits(): number {\n    return this.experimentalNumChildAlgNodes();\n  }\n\n  experimentalNumChildAlgNodes(): number {\n    return Array.from(this.#algNodes).length;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n\n  /**\n   * Converts the Alg to a string:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\"), new Move(\"L\")])\n   *     // R U2 L\n   *     console.log(alg.toString())\n   */\n  toString(\n    experimentalSerializationOptions?: ExperimentalSerializationOptions,\n  ): string {\n    let output = \"\";\n    let previousVisibleAlgNode: AlgNode | null = null;\n    for (const algNode of this.#algNodes) {\n      if (previousVisibleAlgNode) {\n        output += spaceBetween(previousVisibleAlgNode, algNode);\n      }\n      const nissGrouping = algNode.as(Pause)?.experimentalNISSGrouping;\n      if (nissGrouping) {\n        if (nissGrouping.amount !== -1) {\n          throw new Error(\"Invalid NISS Grouping amount!\");\n        }\n        output += `^(${nissGrouping.alg.toString(experimentalSerializationOptions)})`;\n      } else if (algNode.as(Grouping)?.experimentalNISSPlaceholder) {\n        // do not serialize (rely on the placeholder instead)\n      } else {\n        output += algNode.toString(experimentalSerializationOptions);\n      }\n      previousVisibleAlgNode = algNode;\n    }\n    return output;\n  }\n\n  /**\n   * `experimentalSimplify` can perform several mostly-syntactic simplifications on an alg:\n   *\n   *     // Logs: R' U3\n   *     import { Alg } from \"cubing/alg\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({ cancel: true }).log()\n   *\n   * You can pass in a `PuzzleLoader` (currently only for 3x3x3) for puzzle-specific simplifications:\n   *\n   *     // Logs: R' U'\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({ cancel: true, puzzleLoader: cube3x3x3 }).log()\n   *\n   * You can also cancel only moves that are in the same direction:\n   *\n   *     // Logs: R R2' U'\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R R2' U U2\").experimentalSimplify({\n   *       cancel: { directional: \"same-direction\" },\n   *       puzzleLoader: cube3x3x3\n   *     }).log()\n   *\n   * Additionally, you can specify how moves are \"wrapped\":\n   *\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *\n   *     function example(puzzleSpecificModWrap) {\n   *       alg.experimentalSimplify({\n   *         cancel: { puzzleSpecificModWrap },\n   *         puzzleLoader: cube3x3x3\n   *       }).log()\n   *     }\n   *\n   *     const alg = new Alg(\"R7' . R6' . R5' . R6\")\n   *     example(\"none\")               // R7' . R6' . R5' . R6\n   *     example(\"gravity\")            // R . R2' . R' . R2\n   *     example(\"canonical-centered\") // R . R2 . R' . R2\n   *     example(\"canonical-positive\") // R . R2 . R3 . R2\n   *     example(\"preserve-sign\")      // R3' . R2' . R' . R2\n   *\n   * Same-axis and simultaneous move canonicalization is not implemented yet:\n   *\n   *     // Logs: R L R\n   *     import { Alg } from \"cubing/alg\";\n   *     import { cube3x3x3 } from \"cubing/puzzles\";\n   *     new Alg(\"R L R\").experimentalSimplify({ cancel: true, puzzleLoader: cube3x3x3 }).log()\n   */\n  experimentalSimplify(options?: SimplifyOptions): Alg {\n    return new Alg(simplify(this, options ?? {}));\n  }\n\n  /** @deprecated See {@link experimentalSimplify} */\n  simplify(options?: SimplifyOptions): Alg {\n    return this.experimentalSimplify(options);\n  }\n}\n\nfunction spaceBetween(u1: AlgNode, u2: AlgNode): string {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u2.as(Grouping)?.experimentalNISSPlaceholder) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\"; /// TODO\n  }\n  return \" \";\n}\n","// tslint:disable-next-line no-namespace // TODO: nested module\n\nimport { Alg } from \"./Alg\";\nimport { Grouping } from \"./alg-nodes\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\n\nexport const Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1),\n  ]),\n\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n  ]),\n\n  SuneCommutator: new Alg([\n    new Commutator(\n      new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]),\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n    ),\n  ]),\n\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1),\n  ]),\n\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(\n      new Alg([\n        new Conjugate(\n          new Alg([new Move(\"R\", 1)]),\n          new Alg([new Move(\"U\", -1)]),\n        ),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Commutator(\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Move(\"x\", 1),\n  ]),\n\n  FURURFCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"U\", 1)]),\n          new Alg([new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  APermCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"R\", 2)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"F\", 2)]),\n          new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  HeadlightSwaps: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Grouping(\n          new Alg([\n            new Commutator(\n              new Alg([new Move(\"R\", 1)]),\n              new Alg([new Move(\"U\", 1)]),\n            ),\n          ]),\n          3,\n        ),\n      ]),\n    ),\n  ]),\n\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()]),\n  // AllAlgParts: [\n  //   new Alg([new Move(\"R\", 1), new Move(\"U\", -1)]),\n  //   new Grouping(new Alg([new Move(\"F\", 1)]), 2),\n  //   // new Rotation(\"y\", -1),\n  //   new Move(\"R\", 2),\n  //   new Commutator(new Alg([new Move(\"R\", 2)]), new Alg([new Move(\"U\", 2)]), 2),\n  //   new Conjugate(new Alg([new Move(\"L\", 2)]), new Alg([new Move(\"D\", -1)]), 2),\n  //   new Pause(),\n  //   new Newline(),\n  //   new LineComment(\"line comment\"),\n  // ],\n};\n"],"names":["MAX_JS_PRECISE_INT","UPPER_HALF_MULTIPLIER","LOWER_HALF_RIGHT_SHIFT_BITS","arr","Uint32Array","random53BitNumber","globalThis","crypto","getRandomValues","upper","lower","Math","floor","randomUIntBelow","max","val","blockMax","Error","validateMax","randomChoice","arr2","length","CountAnimatedLeaves","TraversalUp","traverseAlg","alg","total","part","childAlgNodes","this","traverseAlgNode","traverseGrouping","grouping","abs","amount","traverseMove","_move","traverseCommutator","commutator","A","B","traverseConjugate","conjugate","traversePause","_pause","traverseNewline","_newline","traverseLineComment","_comment","functionFromTraversal","CountMoves","constructor","metric","super","r","algNode","move","_newLine","CountLeavesInExpansionForSimultaneousMoveIndexer","isCharUppercase","c","rangeBlockTurnMetric","fam","family","countMoves","TrembleSolver","kpuzzle","sgs","trembleMoveNames","searchMoves","moveNames","moveName","rootMove","Move","transformation","identityTransformation","i","applyMove","isIdentityTransformation","push","modified","calculateMoves","Object","keys","definition","moves","solve","pattern","stage1DepthLimit","arguments","undefined","quantumMoveOrder","experimentalToTransformation","bestAlg","bestLen","recur","recursiveTransformation","togo","sofar","sgsAlg","sgsPhaseSolve","newAlg","concat","experimentalSimplify","cancel","directional","puzzleSpecificModWrap","puzzleSpecificSimplifyOptions","len","searchMove","applyTransformation","d","Alg","initialTransformation","bestLenSofar","algBuilder","AlgBuilder","step","ordering","cubieSeq","pieceOrdering","key","inverseTransformation","invert","loc","orbitName","idx","permutationIdx","transformationData","permutation","orientationDelta","info","lookup","experimentalPushAlg","experimentalNumAlgNodes","location","toAlg","twsearchPromise","from","async","wasmTwsearch","def","options","wasmTwsearch2","searchDynamicSideEvents","cachedTrembleSolver","preInitialize222","sgsCachedData","cachedData222","puzzles","split","getCachedTrembleSolver","dynamic4x4x4Solver","randomSuffixes","initialize444","initialize","random444Scramble","mustBeInsideWorker","random444OrientedScramble","addOrientationSuffix","dynamicFTO","randomFTOScramble","getRandomFTOScramble","dynamicKilominxSolver","randomKilominxScramble","getRandomKilominxScramble","dynamicMasterTetraminxSolver","randomMasterTetraminxScramble","randomMasterTetraminxScrambleString","cachedTrembleSolver2","solveMegaminx","trembleSolver","json","cachedSGSDataMegaminx","cachedMegaminxKPuzzleWithoutMO","getCachedTrembleSolver2","patternDataWithoutMO","structuredClone","patternData","orientation","Array","fill","patternWithoutMO","KPattern","cachedTrembleSolver3","solvePyraminx","sgsDataPyraminx","getCachedTrembleSolver3","searchDynamicUnofficial","randomRediCubeScramble","getRandomRediCubeScramble","cachedTrembleSolver4","solveSkewb","sgsDataSkewb","skewbKPuzzleWithoutMOCached","getCachedTrembleSolver4","CORNERS","CENTERS","pieces","resetCenterOrientation","quantumMove","setIsInsideWorker","DEBUG_MEASURE_PERF","now","performance","Date","measurePerf","name","f","start","result","then","end","console","warn","isPrefetch","round","scrambleActivityLock","prefetchPromises","Map","queuedPrefetchTimeoutID","randomScrambleForEvent","eventID","wasm","JSON","stringify","wasmRandomScrambleForEvent","wasmRandomScrambleForEvent2","random333Scramble","random333OrientedScramble","currentPrefetchLevel","insideAPI","initialize333","setScramblePrefetchLevel","prefetchLevel","promise","get","delete","clearTimeout","setTimeout","set","randomScrambleStringForEvent","toString","solve333ToString","solve333","solve222ToString","cube2x2x2","generatorMoves","solve222","solveSkewbToString","solvePyraminxToString","solveMegaminxToString","setDebugMeasurePerf","measure","solveTwsearchToString","KPuzzle","expose","isInsideWorker","inside","suffixSpec","suffix","choice","fromString","dynamic3x3x3min2phase","reidEdgeOrder","reidCornerOrder","centerOrder","map","rotateLeft","s","slice","toMin2PhasePattern","reid","output","toReid333Struct","_ref","orbit","perm","ori","join","isEquivalentTranformationIgnoringCENTERS","t1","t2","t1NoCenterOri","EDGES","t2NoCenterOri","isIdentical","sgs3x3x3","random333Pattern","defaultPattern","piece","applyAlg","randomChoice2","face","moveToTransformation","toKPattern","passesFilter","solvePattern","combineTransformationData","transformationData1","transformationData2","newTransformationData","orbitDefinition","orbits","orbit1","orbit2","isOrbitTransformationDataIdentityUncached","numOrientations","newPerm","numPieces","newOri","applyTransformationDataToKPatternData","newPatternData","patternOrbit","transformationOrbit","newPieces","newOrbitData","newOrientation","newOrientationMod","orientationMod","transformationIdx","mod","identityOrbitCache","constructIdentityOrbitTransformation","cached","newPermutation","orbitTransformation","KTransformation","_KTransformation","toJSON","experimentalPuzzleName","invertTransformation","experimentalConstructIdentity","constructIdentityTransformationDataUncached","isOrbitTransformationDataIdentical","isTransformationDataIdentical","apply","source","toTransformation","algToTransformation","fromTransformation","repetitionOrder","order","orbitPieces","startIdx","currentIdx","orientationSum","cycleLength","gcd","transformationRepetitionOrder","selfMultiply","repeatTransformationUncached","orbitTransformationData","log","orbitTransformationData1","orbitTransformationData2","ignorePieceOrientations","ignorePiecePermutation","isOrbitPatternDataIdentical","orbitPatternData1","orbitPatternData2","ignorePieceIndices","fromIdx","halfish","twiceHalfish","AlgToTransformationTraversal","TraversalDownUp","algTransformation","aTransformation","bTransformation","_","a","b","_KPattern","other","patternData1","patternData2","isPatternDataIdentical","canConvertDefaultPatternToUniqueTransformation","patternOrbitData","entries","experimentalIsSolved","experimentalIsPatternSolved","experimentalPGNotation","lookupOrbitDefinition","indexedOrbits","cacheKey","cachedTransformationData","lookupMove","getTransformationData","multiplyAmount","movesDef","derivedDef","derivedMoves","data","quantum","moveToTransformationUncached","is","PLazy","_PLazy","Promise","executor","resolve","_executor","function_","value","reject","error","_resolve","onFulfilled","onRejected","_promise","catch","PieceAnnotation","stickerings","defaultValue","regular","ignored","oriented","invisible","dim","mystery","pieceStickerings","facelets","getPieceStickeringMask","pieceStickering","PuzzleStickering","pieceSet","toStickeringMask","stickeringMask","pieceStickerings2","orbitStickeringMask","StickeringManager","and","pieceSets","newPieceSet","pieceLoop","or","not","all","moveSource","moveSources","orbitNames","orbitPrefix","startsWith","LL","LS","megaAnd3x3x3LL","megaminx","megaAnd3x3x3LS","experimentalStickerings","full","groups","OLL","PLL","EOLL","COLL","OCLL","CPLL","CLL","EPLL","ELL","ZBLL","LSOLL","LSOCLL","ELS","CLS","ZBLS","VLS","WVLS","F2L","Daisy","Cross","EO","EOline","EOcross","FirstBlock","SecondBlock","CMLL","L10P","L6E","L6EO","EODF","G1","L2C","PBL","picture","fto","cubeLikeStickeringMask","puzzleLoader","stickering","puzzleStickering","m","LL2","orUD","orLR","M","CENTER","faceMove","EDGE","faceMoves","centerLL","edgeFR","cornerDFR","slotFR","dimF2L","setPLL","setOLL","dimOLL","id","cubeLikePuzzleStickering","cubeLikeStickeringList","puzzleID","stickeringsFallback","use3x3x3Fallbacks","getCached","getValue","cachedPromise","asyncGetPuzzleGeometry","puzzleName","getPuzzleGeometryByName","allMoves","orientCenters","addRotations","asyncGetKPuzzle","pgPromise","setOrientationModTo1ForPiecesOfOrbits","pg","kpuzzleDefinition","getKPuzzleDefinition","pgNotation","ExperimentalPGNotation","getOrbitsDef","setOrientationModTo1ForPiecesOfOrbitsSet","Set","orbitData","has","remapKPuzzleDefinition","PGPuzzleLoader","pgId","fullName","inventedBy","inventionYear","pgID","basePG","asyncGetBasePuzzleGeometry","svg","generatesvg","puzzleSpecificSimplifyOptionsPromise","bind","CubePGPuzzleLoader","algTransformData","cubeMirrorTransforms","kpuzzlePromiseFn","cube3x3x3KPuzzleDefinition","U","y","x","L","F","R","D","z","E","S","u","l","Uw","Lw","Fw","Rw","Bw","Dw","Uv","Lv","Fv","Rv","Bv","Dv","puzzleOrientation3x3x3Idx","idxU","idxD","unadjustedIdxL","idxL","puzzleOrientationCacheRaw","normalize3x3x3Orientation","orientationTransformation","uAlgs","yAlg","uAlg","experimental3x3x3KPuzzle","puzzleOrientation3x3x3Cache","TransformAlg","dataDown","algNodes","invertExceptByFamily","replaceMovesByFamily","Commutator","Conjugate","pause","_dataDown","newLine","comment","descAsyncGetPuzzleGeometry","desc","getPuzzleGeometryByDesc","asyncGetKPuzzleByDesc","puzzleOrientation2x2x2Idx","inverseDFL","puzzleOrientationCacheRaw2","puzzleOrientationCacheInitialized2","normalize2x2x2Orientation","puzzleOrientation2x2x2Cache","normalizedPattern","normalizationAlg","experimentalIs2x2x2Solved","ignorePuzzleOrientation","ignoreCenterOrientation","bigCubePuzzleOrientation","cube3x3x3KeyMapping","KeyI","KeyK","KeyW","KeyO","KeyS","KeyL","KeyD","KeyE","KeyJ","KeyF","KeyH","KeyG","KeyC","KeyR","KeyU","KeyM","KeyX","Comma","KeyT","KeyY","KeyV","KeyN","Semicolon","KeyA","KeyP","KeyQ","KeyZ","KeyB","Period","Backquote","Pause","makeSourceInfo","moveStrings","type","from2","to","moveString","direction","includes","axisInfos","sliceDiameter","extendsThroughEntirePuzzle","moveSourceInfos","byFamily","axis","moveSourceInfo","byAxisThenType","entry","byAxisThenSpecificSlices","firstOfType","moveSourceType","simplestMove","directedAmount","sliceSpecificInfo","QuantumMove","axisInfo","moveSourceInfo2","far","outerLayer","innerLayer","puzzleSpecificSimplifyOptions333","areQuantumMovesSameAxis","quantumMove1","quantumMove2","simplifySameAxisMoves","quantumMod","sliceDeltas","lastCandidateRange","adjustValue","relativeDelta","newDelta","suffixLength","reverse","directedAmount2","size","cube3x3x3","cube3x3x3SVG","llSVG","cube3x3x3LLSVG","llFaceSVG","cube3x3x3LLFaceSVG","keyMapping","wcaEvents","eventName","scramblesImplemented","clock","minx","pyram","skewb","sq1","cube2x2x2JSON","cube2x2x2SVG","cube2x2x2LLSVG","cube4x4x4And5x5x5KeyMapping","cube4x4x4","cube4x4x4LLSVG","prototype","call","experimentalIsBigCubeSolved","cube5x5x5","ftoStickering","experimentalFTO_FC","experimentalFTO_F2T","experimentalFTO_SC","experimentalFTO_L2C","experimentalFTO_LBT","ftoStickerings","speffzDistinguishableCenters","ftoKeyMapping","baby_fto","babyFTOSVG","clockJSON","clockSVG","ftoSVG","BL","BR","bl","br","BLw","BRw","BLv","BRv","KILOMINX_PUZZLE_DESCRIPTION","kilominx","includeCenterOrbits","includeEdgeOrbits","kilominxSVG","loopover","loopoverJSON","loopoverSVG","megaminxStickeringListPromise","megaminxStickerings","megaminxKeyMapping","megaminxStickeringMask","megaminxLLSVG","melindas2x2x2x2","melindas2x2x2x2OrbitJSON","melindas2x2x2x2OrbitSVG","pyraminx","pyraminxSVG","rediCube","rediCubeJSON","rediCubeSVG","square1","sq1HyperOrbitJSON","sq1HyperOrbitSVG","tri_quad","triQuadJSON","triQuadSVG","gigaminx","master_tetraminx","redi_cube","Comparable","as","AlgCommon","_Commutator","aSource","bSource","experimentalEnsureAlg","otherAsCommutator","experimentalExpand","_this","iterDir","depth","Infinity","experimentalSerializationOptions","_Conjugate","otherAsConjugate","MAX_INT","MAX_INT_DESCRIPTION","reset","LineComment","_LineComment","commentText","text","otherAsLineComment","_this2","_experimentalSerializationOptions","Newline","_Newline","_this3","_Pause","experimentalNISSGrouping","_this4","algDebugGlobals","caretNISSNotationEnabled","parseIntWithEmptyFallback","n","emptyFallback","parseInt","AMOUNT_REGEX","MOVE_START_REGEX","QUANTUM_MOVE_REGEX","COMMENT_TEXT_REGEX","SQUARE1_PAIR_START_REGEX","SQUARE1_PAIR_END_REGEX","parseAlg","AlgParser","startCharIndexKey","Symbol","endCharIndexKey","addCharIndices","t","startCharIndex","endCharIndex","parsedT","input","parseAlgWithStopping","mustBeAtEndOfInput","nissGrouping","parseMove","parseMoveImpl","parseQuantumMove","parseQuantumMoveImpl","stopBefore","algStartIdx","algEndIdx","crowded","mustNotBeCrowded","savedCharIndex","tryConsumeNext","test","sq1PairStartMatch","tryRegex","topAmountString","savedCharIndexD","sq1PairEndMatch","parseRegex","uMove","dMove","Grouping","mustConsumeNext","parseAmount","popNext","placeholder","experimentalNISSPlaceholder","separator","unrepeated","afterClosingBracketIdx","unrepeatedAlg","outerLayerStr","innerLayerStr","hadEmptyAbsAmount","parseAmountAndTrackEmptyAbsAmount","parseMoveSuffix","savedIdx","absAmountStr","primeStr","regex","exec","remaining","next","expected","warned","warnOnce","add","QuantumWithAmount","Number","isInteger","absAmount","newIterDir","iterationDirection","toggleDirection","_QuantumMove","freeze","modifications","otherAsQuantumMove","String","_Move","otherAsMove","_this5","notation","endsWith","square1TupleFormatterInstance","quantumU_SQ_","quantumD_SQ_","format","amounts","tuple","quantumAlg","experimentalNumChildAlgNodes","_Grouping","algSource","otherAsGrouping","experimentalRepetitionSuffix","moveU","moveD","_this6","insideString","iter","done","experimentalAsSquare1Tuple","experimentalIs","v","experimentalIsAlgNode","AppendOptionsHelper","config","cancelQuantum","cancelAny","cancelPuzzleSpecificModWrap","areSameDirection","move2","sign","experimentalAppendMove","addedMove","optionsHelper","outputPrefix","outputSuffix","canCancelMoveBasedOnQuantum","newMoveQuantumString","sameDirectionOnly","quantumDirections","quantumKey","existingQuantumDirectionOnAxis","splice","reduce","sum","offset","offsetAmount","positiveMod","offsetMod","modMove","filter","experimentalAppendNode","leaf","maybeMove","dispatch","mustBeAlgNode","traverseIntoAlgNode","traversalConstructor","constructorArgs","instance","simplify","newOptions","traversedNode","newAlgNode","newGrouping","experimentalIsEmpty","newPlaceholder","_options","aMove","bMove","appendOptionsHelper","newCommutator","newConjugate","newPause","newline","toIterable","iterator","_Alg","otherAsAlg","l1","l2","g","_this7","direct","expand","experimentalLeafMoves","units","experimentalNumUnits","previousVisibleAlgNode","spaceBetween","u1","u2"],"sourceRoot":""}